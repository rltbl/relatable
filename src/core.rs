//! # rltbl/relatable
//!
//! This is [relatable](crate) (rltbl::[core](crate::core)).

use crate as rltbl;
use rltbl::{git, sql, sql::VecInto as _};

use anyhow::Result;
use csv::{QuoteStyle, ReaderBuilder, WriterBuilder};
use enquote::unquote;
use indexmap::IndexMap;
use minijinja::{path_loader, Environment};
use regex::Regex;
use serde::{Deserialize, Serialize};
use serde_json::{json, to_value, Map as JsonMap, Value as JsonValue};
use std::{fmt::Display, fs::File, io::Write, path::Path as FilePath, str::FromStr};
use tabwriter::TabWriter;

/// Various errors generated by [relatable](crate)
#[derive(Debug)]
pub enum RelatableError {
    /// An error in the configuration of a ChangeSet:
    ChangeError(String),
    /// An error in the [relatable](crate) configuration:
    ConfigError(String),
    // /// An error that occurred while reading or writing to a CSV/TSV:
    // CsvError(csv::Error),
    /// An error involving the data:
    DataError(String),
    // /// An error generated by the underlying database:
    // DatabaseError(sqlx::Error),
    /// An error that occurred while interacting with git
    GitError(String),
    /// An error generated when the database is missing
    InitError(String),
    /// An error from an unsupported format
    FormatError(String),
    /// An error in the inputs to a function:
    InputError(String),
    /// An error that occurred while reading/writing to stdio:
    IOError(std::io::Error),
    /// An error when a record cannot be found.
    MissingError(String),
    /// An error that occurred while serialising or deserialising to/from JSON:
    SerdeJsonError(serde_json::Error),
    /// An error that occurred while parsing a regex:
    RegexError(regex::Error),
    /// An error when a table cannot be found.
    TableError(String),
    /// An error that occurred because of a user's action
    UserError(String),
}

impl std::fmt::Display for RelatableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

/// Default location of the [relatable](crate) database
pub static RLTBL_DEFAULT_DB: &str = ".relatable/relatable.db";

/// Used to calculate the _order field when a new row is added to a table that has metacolumns
pub static NEW_ORDER_MULTIPLIER: usize = 1000;

// The maximum length of the list of previously (un)done commands to fetch when retrieving a user's
// history.
static HISTORY_MAX: usize = 1000;

impl std::error::Error for RelatableError {}

/// The main [rltbl](crate) struct.
#[derive(Debug)]
pub struct Relatable {
    pub root: String,
    pub readonly: bool,
    pub connection: sql::DbConnection,
    // pub minijinja: Environment<'static>,
    pub default_limit: usize,
    pub max_limit: usize,
}

impl Relatable {
    /// Connect to a relatable database at the given path, or, if not given, at the location
    /// indicated by the environment variable RLTBL_CONNECTION, or, if that is not given,
    /// at [RLTBL_DEFAULT_DB]
    pub async fn connect(path: Option<&str>) -> Result<Self> {
        tracing::trace!("Relatable::connect({path:?})");
        let root = std::env::var("RLTBL_ROOT").unwrap_or_default();
        // Set up database connection.
        let readonly = match std::env::var("RLTBL_READONLY") {
            Ok(value) if value.to_lowercase() != "false" => true,
            _ => false,
        };
        let path = match path {
            Some(path) => path.to_string(),
            None => {
                match std::env::var_os("RLTBL_CONNECTION").and_then(|p| Some(p.into_string())) {
                    Some(Ok(path)) => path,
                    _ => RLTBL_DEFAULT_DB.to_string(),
                }
            }
        };
        if !path.starts_with("postgresql://") {
            let file = FilePath::new(&path);
            if !file.exists() {
                return Err(RelatableError::InitError(
                    "First create a database with `rltbl init`".into(),
                )
                .into());
            }
        }
        let (connection, _) = sql::DbConnection::connect(&path).await?;
        Ok(Self {
            root,
            readonly,
            connection,
            // minijinja: env,
            default_limit: 100,
            max_limit: 1000,
        })
    }

    /// Initialize a [relatable](crate) database at the given path, or, if not given, at
    /// the location indicated by the environment variable RLTBL_CONNECTION, or, if that is not
    /// given, at [RLTBL_DEFAULT_DB]. Overwrites an existing database if `force` is set to true.
    pub async fn init(force: &bool, path: Option<&str>) -> Result<Self> {
        tracing::trace!("Relatable::init({force:?}, {path:?})");
        let path = match path {
            Some(path) => path.to_string(),
            None => {
                match std::env::var_os("RLTBL_CONNECTION").and_then(|p| Some(p.into_string())) {
                    Some(Ok(path)) => path,
                    _ => RLTBL_DEFAULT_DB.to_string(),
                }
            }
        };
        if !path.starts_with("postgresql://") {
            let dir = FilePath::new(&path)
                .parent()
                .expect("Parent path must be defined");
            if !dir.exists() {
                std::fs::create_dir_all(&dir)?;
                tracing::info!("Created '{dir:?}' directory");
            }
            let file = FilePath::new(&path);
            if file.exists() {
                if *force {
                    std::fs::remove_file(&file)?;
                    tracing::info!("Removed '{file:?}' file");
                } else {
                    return Err(RelatableError::InitError(format!(
                        "File {file:?} already exists. Use --force to overwrite"
                    ))
                    .into());
                }
            }
            File::create(&path)?;
        }

        // Create the meta tables:
        let rltbl = Relatable::connect(Some(&path)).await?;
        let ddl = sql::generate_meta_tables_ddl(*force, &rltbl.connection.kind());
        for sql in ddl {
            rltbl.connection.query(&sql, None).await?;
        }

        Ok(rltbl)
    }

    pub fn render<T: Serialize>(&self, template: &str, context: T) -> Result<String> {
        tracing::trace!("Relatable::render({template:?}, context)");
        // TODO: Optionally we should set up the environment once and store it,
        // but during development it's very convenient to rebuild every time.
        let mut env = Environment::new();

        // Load default template strings at compile time.
        let templates = IndexMap::from([
            ("page.html", include_str!("templates/page.html")),
            ("table.html", include_str!("templates/table.html")),
            ("row_menu.html", include_str!("templates/row_menu.html")),
            (
                "column_menu.html",
                include_str!("templates/column_menu.html"),
            ),
            ("cell_menu.html", include_str!("templates/cell_menu.html")),
        ]);

        // Load templates dynamically if src/templates/ exists,
        // otherwise use strings from compile time.
        // TODO: This should be a configuration option.
        let dir = "src/templates/";
        if FilePath::new(dir).is_dir() {
            env.set_loader(path_loader(dir));
        };
        for (name, content) in templates {
            match env.get_template(name) {
                Ok(_) => (),
                Err(_) => env.add_template(name, content).unwrap(),
            }
        }

        env.get_template(template)?
            .render(context)
            .map_err(|e| e.into())
    }

    pub fn from(&self, table_name: &str) -> Select {
        tracing::trace!("Relatable::from({table_name:?})");
        Select {
            table_name: table_name.to_string(),
            view_name: format!("{table_name}_default_view"),
            limit: self.default_limit,
            ..Default::default()
        }
    }

    /// Returns a tuple whose first position contains a list of the given table's columns, and whose
    /// second position contains a list of the given table's metacolumns.
    pub async fn fetch_all_columns(&self, table_name: &str) -> Result<(Vec<Column>, Vec<Column>)> {
        tracing::trace!("Relatable::fetch_all_columns({table_name:?})");
        // Fetch the columns corresponding to `table_name` from the database's metadata:
        let mut columns = vec![];
        let mut meta_columns = vec![];
        let table = self.get_table(table_name).await?;
        for column in self.connection.get_table_columns(table_name).await? {
            // Decorate the column using the information from the column table that we collected
            // above:
            match column.get_string("name")? {
                name if name.starts_with("_") => meta_columns.push(Column {
                    name,
                    table: table.name.to_string(),
                    ..Default::default()
                }),
                name => columns.push(Column {
                    // The fields are assigned in this particular order to satisfy the constraints
                    // of rust's ownership model. Because `name` is a String and not a reference,
                    // we cannot assign it and then afterwards borrow it to use as an argument
                    // to a function. But doing that in the opposite order is fine.
                    label: table.get_column_attribute(&name.as_str(), "label"),
                    description: table.get_column_attribute(&name.as_str(), "description"),
                    nulltype: table.get_column_attribute(&name.as_str(), "nulltype"),
                    name,
                    table: table.name.to_string(),
                    ..Default::default()
                }),
            };
        }
        if columns.is_empty() && meta_columns.is_empty() {
            return Err(RelatableError::DataError(format!(
                "No db columns found for: {}",
                table.name
            ))
            .into());
        }
        Ok((columns, meta_columns))
    }

    /// Returns a list of the given table's columns (not including metacolumns)
    pub async fn fetch_columns(&self, table_name: &str) -> Result<Vec<Column>> {
        tracing::trace!("Relatable::fetch_columns({table_name:?})");
        Ok(self.fetch_all_columns(table_name).await?.0)
    }

    /// Returns a list of the given table's metacolumns
    pub async fn fetch_metacolumns(&self, table_name: &str) -> Result<Vec<Column>> {
        tracing::trace!("Relatable::fetch_metacolumns({table_name:?})");
        Ok(self.fetch_all_columns(table_name).await?.1)
    }

    /// Use the given [Select] to fetch data from the database.
    pub async fn fetch(&self, select: &Select) -> Result<ResultSet> {
        tracing::trace!("Relatable::fetch({select:?})");

        // Get the table and column information and ensure that the view has been created:
        let mut table = self.get_table(select.table_name.as_str()).await?;
        let columns = table.ensure_default_view_created(self).await?;

        // Fetch the data
        let (statement, params) = select.to_sql(&self.connection.kind())?;
        tracing::debug!("SQL {statement}");
        let params = json!(params);
        let json_rows = self.connection.query(&statement, Some(&params)).await?;
        let count = json_rows.len();
        tracing::info!("Received {count} rows.");
        if count > 4 {
            tracing::debug!("The first 4 are: {:#?}", json_rows[..4].to_vec());
        } else if count > 0 {
            tracing::debug!("They are: {json_rows:#?}");
        }

        // Return the data:
        let total = match json_rows.get(0) {
            Some(row) => row
                .content
                .get("_total")
                .and_then(|x| x.as_u64())
                .unwrap_or(0) as usize,
            None => 0,
        };
        let rows: Vec<Row> = json_rows.vec_into();
        Ok(ResultSet {
            range: Range {
                count,
                total,
                start: select.offset + 1,
                end: select.offset + count,
            },
            select: select.clone(),
            table,
            columns,
            rows,
        })
    }

    /// Use the given [Select] to fetch data from the database.
    pub async fn fetch_json_rows(&self, select: &Select) -> Result<Vec<sql::JsonRow>> {
        tracing::trace!("Relatable::fetch_json_rows({select:?})");
        let (statement, params) = select.to_sql(&self.connection.kind())?;
        let params = json!(params);
        self.connection.query(&statement, Some(&params)).await
    }

    /// Loads the given table from the given path. When `force` is set to true, deletes any
    /// existing table of the same name in the database first. Note that this function may panic.
    pub async fn load_table(&self, table_name: &str, path: &str, force: bool) {
        tracing::trace!("Relatable::load_table({table_name:?}, {path:?})");
        // Read the records from the given TSV file:
        let mut rdr = ReaderBuilder::new()
            .has_headers(false)
            .delimiter(b'\t')
            .from_reader(File::open(path).expect(&format!("Unable to open '{path}'")));
        let mut records = rdr.records();

        // Extract the headers from the first line of the file, which we will need for the CREATE
        // TABLE statement:
        let headers = {
            let headers = match records.next() {
                None => panic!("'{path}' is empty"),
                Some(record) => match record {
                    Err(err) => panic!("Error reading from '{path}': {err}"),
                    Ok(headers) => headers.iter().map(|s| s.to_string()).collect::<Vec<_>>(),
                },
            };
            for header in &headers {
                if header.trim().is_empty() {
                    panic!("One or more of the header fields is empty for table '{table_name}'");
                }
            }
            headers
        };

        let db_kind = self.connection.kind();

        // Add an entry corresponding to the table being loaded to the table table:
        if force {
            let sql = format!(
                r#"DELETE FROM "table" WHERE "table" = {sql_param}"#,
                sql_param = sql::SqlParam::new(&db_kind).next(),
            );
            let params = json!([table_name]);
            self.connection
                .query(&sql, Some(&params))
                .await
                .expect("Error deleting from table table");
        }
        let sql = format!(
            r#"INSERT INTO "table" ("table", "path") VALUES ({sql_params})"#,
            sql_params = sql::SqlParam::new(&db_kind).get_as_list(2)
        );
        let params = json!([table_name, path]);
        self.connection
            .query(&sql, Some(&params))
            .await
            .expect("Error inserting to table table");
        tracing::debug!("Table {table_name} (path: {path}) added to table table");

        // Initialize a new table struct that we will use to generate DDL to create it in the
        // database if we need to:
        let mut table = Table::new(table_name);
        for header in headers.iter() {
            table.columns.insert(
                header.to_string(),
                Column {
                    name: header.to_string(),
                    table: table_name.to_string(),
                    ..Default::default()
                },
            );
        }

        // Generate the SQL statements needed to create the table and execute them:
        for sql in sql::generate_table_ddl(&table, force, &db_kind).expect("Error getting DDL") {
            self.connection
                .query(&sql, None)
                .await
                .expect("Error creating table");
        }

        // Insert the data into the table:
        let table = self
            .get_table(table_name)
            .await
            .expect(&format!("Error getting info for {table_name}"));
        let mut columns = vec!["_id".to_string(), "_order".to_string()];
        columns.append(
            &mut headers
                .iter()
                .map(|k| format!(r#"{k}"#))
                .collect::<Vec<_>>(),
        );
        let columns_line = columns
            .iter()
            .map(|k| format!(r#""{k}""#))
            .collect::<Vec<_>>()
            .join(", ");
        let mut id = 1;
        let mut order = id * NEW_ORDER_MULTIPLIER;
        let sql_first_part = format!(r#"INSERT INTO "{table_name}" ({columns_line}) VALUES "#);
        let mut sql_value_parts = vec![];
        let mut sql_param_gen = sql::SqlParam::new(&self.connection.kind());
        let mut params = vec![];
        let max_params = match db_kind {
            sql::DbKind::Sqlite => sql::MAX_PARAMS_SQLITE,
            sql::DbKind::Postgres => sql::MAX_PARAMS_POSTGRES,
        };
        while let Some(row) = records.next() {
            let row = row.expect("Error processing row");
            // We add 2 here because of _id and _order:
            if (params.len() + row.len() + 2) >= max_params {
                let sql = format!(
                    "{sql_first_part} {sql_value_part}",
                    sql_value_part = sql_value_parts.join(", ")
                );
                let params_so_far = json!(params);
                self.connection
                    .query(&sql, Some(&params_so_far))
                    .await
                    .expect("Error inserting to table");
                tracing::info!(
                    "{num_rows} rows loaded to table {table_name}",
                    num_rows = id - 1
                );
                params.clear();
                sql_value_parts.clear();
                sql_param_gen.reset()
            }

            let mut sql_params = vec![];
            params.push(json!(id));
            sql_params.push(sql_param_gen.next());
            params.push(json!(order));
            sql_params.push(sql_param_gen.next());
            let sql_params = {
                for (i, value) in row.iter().enumerate() {
                    let nulltype = {
                        if value == "" {
                            // We add 2 here because of _id and _order:
                            match columns.get(i + 2) {
                                Some(column) => Some(
                                    table
                                        .get_column_attribute(column, "nulltype")
                                        .unwrap_or("".to_string()),
                                ),
                                None => panic!("Unable to retrieve column {}", i + 2),
                            }
                        } else {
                            None
                        }
                    };
                    match nulltype {
                        Some(nulltype) if nulltype == "empty" => {
                            sql_params.push("NULL".to_string());
                        }
                        _ => {
                            sql_params.push(sql_param_gen.next());
                            params.push(json!(value))
                        }
                    };
                }
                sql_params.join(", ")
            };
            // Add two extra SQL_PARAM for _id and _order:
            sql_value_parts.push(format!("({sql_params})"));
            id += 1;
            order += NEW_ORDER_MULTIPLIER;
        }
        if params.len() > 0 {
            let sql = format!(
                "{sql_first_part} {sql_value_part}",
                sql_value_part = sql_value_parts.join(", ")
            );
            let params = json!(params);
            self.connection
                .query(&sql, Some(&params))
                .await
                .expect(&format!("Error inserting to {table_name}"));
            tracing::info!(
                "{num_rows} rows loaded to table {table_name}",
                num_rows = id - 1
            );
        }

        self.commit_to_git().await.expect("Error committing to git");
    }

    /// Save all of the tables that have entries in the table table to the path indicated for each
    /// table there, unless `save_dir` has been given, in which case save them all there instead.
    pub async fn save_all(&self, save_dir: Option<&str>) -> Result<()> {
        tracing::trace!("Relatable::save_all({save_dir:?})");
        let sql = format!(
            r#"SELECT "table", "path" FROM "table" WHERE "path" {is_not} NULL"#,
            is_not = sql::is_not_clause(&self.connection.kind())
        );
        let table_rows = self.connection.query(&sql, None).await?;
        for table_row in table_rows {
            let table_name = table_row.get_string("table")?;
            let path = match save_dir {
                Some(save_dir) => format!("{save_dir}/{table_name}.tsv"),
                None => table_row.get_string("path")?,
            };
            let mut writer = WriterBuilder::new()
                .delimiter(b'\t')
                .quote_style(QuoteStyle::Never)
                .from_path(path)?;

            let header_row = self
                .fetch_columns(&table_name)
                .await?
                .iter()
                .map(|c| c.name.to_string())
                .collect::<Vec<_>>();
            writer.write_record(header_row.clone())?;

            let sql = format!(
                r#"SELECT {columns} FROM "{table_name}" ORDER BY "_order""#,
                columns = header_row
                    .iter()
                    .map(|c| format!(r#""{c}""#))
                    .collect::<Vec<_>>()
                    .join(", ")
            );
            let data_rows = self.connection.query(&sql, None).await?;
            let table = self.get_table(&table_name).await?;
            for data_row in data_rows {
                let values = {
                    let mut str_values = vec![];
                    for (column, value) in data_row.content.iter() {
                        match value {
                            JsonValue::String(s) => str_values.push(s.to_string()),
                            JsonValue::Null => {
                                let nulltype = {
                                    table
                                        .get_column_attribute(column, "nulltype")
                                        .unwrap_or("".to_string())
                                };
                                match nulltype.as_str() {
                                    // Note that the behaviour for the 'empty' nulltype happens
                                    // to be the same as that for no nulltype, but in general
                                    // that won't be true for every nulltype.
                                    "empty" | _ => str_values.push("".to_string()),
                                };
                            }
                            _ => {
                                return Err(RelatableError::DataError(
                                    "Not a string or a NULL".to_string(),
                                )
                                .into());
                            }
                        }
                    }
                    str_values
                };
                writer.write_record(values)?;
            }
        }

        Ok(())
    }

    /// Save all of the tables and commit the changes to git.
    pub async fn commit_to_git(&self) -> Result<()> {
        tracing::trace!("Relatable::commit_to_git()");
        let author = match std::env::var("RLTBL_GIT_AUTHOR") {
            Err(err) => match err {
                std::env::VarError::NotPresent => {
                    tracing::info!("Not committing to git because RLTBL_GIT_AUTHOR not defined");
                    return Ok(());
                }
                _ => {
                    return Err(RelatableError::InputError(format!(
                        "Could not read from the environment: {err}"
                    ))
                    .into())
                }
            },
            Ok(author) => author,
        };
        tracing::info!("Committing to git on behalf of RLTBL_GIT_AUTHOR: '{author}'");

        // Save all the tables:
        self.save_all(None).await?;

        // Get the git status:
        let status = git::get_status()?;
        if status.behind != 0 {
            return Err(RelatableError::GitError(
                "Refusing to commit to a local repository that is behind the remote".to_string(),
            )
            .into());
        }

        // Possibly only amend the last commit, if it is by the same author and performed
        // on the same day:
        let (last_commit_author, days_ago) = git::get_last_commit_info()?;
        let is_amendment = (last_commit_author == author) && (days_ago < 1);

        // Stage any modified table files that have a path in the table table:
        let sql = format!(
            r#"SELECT "path" FROM "table" WHERE "path" {is_not} NULL"#,
            is_not = sql::is_not_clause(&self.connection.kind()),
        );
        let paths = self
            .connection
            .query(&sql, None)
            .await?
            .iter()
            .map(|row| row.get_string("path").expect("No 'path' found"))
            .collect::<Vec<_>>();
        git::add(&paths)?;

        // Finally, commit to git:
        git::commit("commit by rltbl", &author, is_amendment)?;
        Ok(())
    }

    /// Get the details of the last change made by the user from the change table.
    fn _get_last_change_for_user(
        &self,
        tx: &mut sql::DbTransaction<'_>,
        user: &str,
        action: &ChangeAction,
    ) -> Result<Option<(usize, ChangeSet)>> {
        tracing::trace!("Relatable::_get_last_change_for_user(tx, {user:?}, {action:?})");
        let mut sql_param = sql::SqlParam::new(&tx.kind());
        let sql = format!(
            r#"SELECT "change_id", "user", "table", "description", "content"
               FROM "change"
               WHERE "user" = {sql_param_1} AND "action" = {sql_param_2}
               ORDER BY "change_id" DESC LIMIT 1"#,
            sql_param_1 = sql_param.next(),
            sql_param_2 = sql_param.next(),
        );
        let params = json!([user, format!("{action}")]);
        let records = tx.query(&sql, Some(&params))?;
        match records.len() {
            0 => Ok(None),
            _ => {
                let change_id = records[0].get_unsigned("change_id")?;
                let user = records[0].get_string("user")?;
                let table = records[0].get_string("table")?;
                let description = records[0].get_string("description")?;
                let content = records[0].get_string("content")?;
                let changes = Change::many_from_str(&content)?;
                Ok(Some((
                    change_id,
                    ChangeSet {
                        action: *action,
                        table: table,
                        user: user,
                        description: description,
                        changes: changes,
                    },
                )))
            }
        }
    }

    /// Record the given [ChangeSet] to the change and history tables.
    pub fn record_changeset(
        &self,
        changeset: &ChangeSet,
        tx: &mut sql::DbTransaction<'_>,
    ) -> Result<()> {
        tracing::trace!("Relatable::record_changeset({changeset:?}, tx)");
        let user = changeset.user.clone();
        let action = changeset.action.to_string();
        let table = changeset.table.clone();
        let description = changeset.description.clone();

        // Begin by getting the current last change_id for this user, which we may need to look
        // up previous values of the row's columns in the history table later:
        let old_change_id = match &changeset.action {
            ChangeAction::Undo => {
                let (change_id, _) = self
                    ._get_last_change_for_user(tx, &changeset.user, &ChangeAction::Do)?
                    .ok_or(RelatableError::DataError(
                        "No action for user found".to_string(),
                    ))?;
                Some(change_id)
            }
            ChangeAction::Redo => {
                let (change_id, _) = self
                    ._get_last_change_for_user(tx, &changeset.user, &ChangeAction::Undo)?
                    .ok_or(RelatableError::DataError(
                        "No undo for user found".to_string(),
                    ))?;
                Some(change_id)
            }
            ChangeAction::Do => None,
        };

        // Now write the current change, which will generate a new last change_id:
        let statement = format!(
            r#"INSERT INTO change("user", "action", "table", "description", "content")
               VALUES ({sql_params})
               RETURNING change_id"#,
            sql_params = sql::SqlParam::new(&tx.kind()).get_as_list(5)
        );
        let content = to_value(&changeset.changes).unwrap_or_default();
        let params = json!([user, action, table, description, content]);
        let change_id = tx.query_value(&statement, Some(&params))?;
        let change_id = change_id
            .ok_or(RelatableError::DataError(
                "Expected a change_id".to_string(),
            ))?
            .as_u64()
            .ok_or(RelatableError::DataError("Expected an integer".to_string()))?;

        for change in &changeset.changes {
            match change {
                Change::Update {
                    row,
                    column,
                    before,
                    after,
                } => {
                    let sql = format!(
                        r#"INSERT INTO "history"
                           ("change_id", "table", "row", "before", "after")
                           VALUES ({sql_params})
                           RETURNING "history_id""#,
                        sql_params = sql::SqlParam::new(&tx.kind()).get_as_list(5)
                    );
                    let before = json!({column: before}).to_string();
                    let after = json!({column: after}).to_string();
                    let params = json!([change_id, table, row, before, after]);
                    tx.query_value(&sql, Some(&params))?;
                }
                Change::Add { row, after: _ } => {
                    // If the row has just been newly added, it will be found in the table,
                    // otherwise we will use the old_change_id to look for it in the history
                    // table:
                    let json_row = match self._get_row(&table, *row, tx)? {
                        Some(json_row) => json_row,
                        None => match old_change_id {
                            Some(change_id) => {
                                let sql = format!(
                                    r#"SELECT "before"
                                         FROM "history"
                                        WHERE "change_id" = {sql_param}"#,
                                    sql_param = sql::SqlParam::new(&tx.kind()).next()
                                );
                                let params = json!([change_id]);
                                let before = tx
                                    .query_one(&sql, Some(&params))?
                                    .ok_or(RelatableError::DataError(format!(
                                        "No history row found with change_id {change_id}"
                                    )))?
                                    .get_string("before")?;
                                let before = match serde_json::from_str::<JsonValue>(&before) {
                                    Err(err) => return Err(err.into()),
                                    Ok(JsonValue::Object(o)) => o,
                                    Ok(_) => {
                                        return Err(RelatableError::InputError(
                                            "The content parameter is not an object".to_string(),
                                        )
                                        .into());
                                    }
                                };
                                sql::JsonRow { content: before }
                            }
                            None => {
                                return Err(RelatableError::DataError(format!(
                                    "Row {row} not found"
                                ))
                                .into())
                            }
                        },
                    };
                    let sql = format!(
                        r#"INSERT INTO "history"
                           ("change_id", "table", "row", "after")
                           VALUES ({sql_params})
                           RETURNING "history_id""#,
                        sql_params = sql::SqlParam::new(&tx.kind()).get_as_list(4)
                    );
                    let json_row_str = json!(json_row.content).to_string();
                    let params = json!([change_id, table, row, json_row_str]);
                    tx.query_value(&sql, Some(&params))?;
                }
                Change::Move {
                    row,
                    from_after: _,
                    to_after: _,
                } => {
                    let sql = format!(
                        r#"INSERT INTO "history"
                           ("change_id", "table", "row")
                           VALUES ({sql_params})
                           RETURNING "history_id""#,
                        sql_params = sql::SqlParam::new(&tx.kind()).get_as_list(3)
                    );
                    let params = json!([change_id, table, row]);
                    tx.query_value(&sql, Some(&params))?;
                }
                Change::Delete { row, after: _ } => {
                    let json_row = match self._get_row(&table, *row, tx)? {
                        Some(json_row) => json_row,
                        None => {
                            // It must be there since we supposedly just added it, so if it is
                            // not found return an error.
                            return Err(
                                RelatableError::DataError(format!("Row {row} not found")).into()
                            );
                        }
                    };
                    let sql = format!(
                        r#"INSERT INTO "history"
                           ("change_id", "table", "row", "before")
                           VALUES ({sql_params})
                           RETURNING "history_id""#,
                        sql_params = sql::SqlParam::new(&tx.kind()).get_as_list(4)
                    );
                    let json_row_str = json!(json_row.content).to_string();
                    let params = json!([change_id, table, row, json_row_str]);
                    tx.query_value(&sql, Some(&params))?;
                }
            };
        }
        Ok(())
    }

    /// Get information about the given user from the database and return it as an [Account]. If
    /// there is no user with the given username, return a default Account.
    pub async fn get_user(&self, username: &str) -> Account {
        tracing::trace!("Relatable::get_user({username:?})");
        let statement = format!(
            r#"SELECT "name", "color", "cursor", "datetime"
               FROM user WHERE name = '{username}' LIMIT 1"#
        );
        let user = self.connection.query_one(&statement, None).await;
        if let Ok(user) = user {
            if let Some(user) = user {
                return Account {
                    name: username.to_string(),
                    color: user.get_string("color").expect("No 'color' found"),
                };
            }
        }
        Account {
            ..Default::default()
        }
    }

    /// Returns a map with information about all of the users who have corresponding records in
    /// the user table.
    pub async fn get_users(&self) -> Result<IndexMap<String, UserCursor>> {
        tracing::trace!("Relatable::get_users()");
        let mut users = IndexMap::new();
        // let statement = format!(
        //     r#"SELECT "name", color", "cursor", "datetime" FROM user WHERE cursor IS NOT NULL
        //        AND "datetime" >= DATETIME('now', '-10 minutes')"#
        // );
        let statement = format!(
            r#"SELECT "name", "color", "cursor", "datetime" FROM user WHERE cursor {is_not} NULL"#,
            is_not = sql::is_not_clause(&self.connection.kind()),
        );
        let rows = self.connection.query(&statement, None).await?;
        for row in rows {
            let name = row.get_string("name")?;
            if name.trim() == "" {
                continue;
            }
            users.insert(
                name.clone(),
                UserCursor {
                    name: name.clone(),
                    color: row.get_string("color")?,
                    cursor: serde_json::from_str(&row.get_string("cursor")?)?,
                    datetime: row.get_string("datetime")?,
                },
            );
        }
        Ok(users)
    }

    /// Converts a vector of [JsonRow](sql::JsonRow)s to a map from column names to [Column]s.
    fn json_to_columns_map(json_cols: &Vec<sql::JsonRow>) -> Result<IndexMap<String, Column>> {
        tracing::trace!("Relatable::json_to_columns_map({json_cols:?})");
        let mut columns = IndexMap::new();
        for json_col in json_cols {
            columns.insert(
                json_col.get_string("column")?,
                Column {
                    name: json_col.get_string("column")?,
                    table: json_col.get_string("table")?,
                    label: json_col.get_string("label").ok(),
                    description: json_col.get_string("description").ok(),
                    nulltype: json_col.get_string("nulltype").ok(),
                    ..Default::default()
                },
            );
        }
        Ok(columns)
    }

    /// Returns the given table's columns as a map from column names to [Column]s.
    pub async fn get_columns_map(&self, table_name: &str) -> Result<IndexMap<String, Column>> {
        tracing::trace!("Relatable::get_columns_map({table_name:?})");
        let sql = format!(
            r#"SELECT * FROM "column" WHERE "table" = {sql_param}"#,
            sql_param = sql::SqlParam::new(&self.connection.kind()).next()
        );
        let params = json!([table_name]);
        let json_columns = self
            .connection
            .query(&sql, Some(&params))
            .await
            .unwrap_or(vec![]);
        Self::json_to_columns_map(&json_columns)
    }

    /// Returns the given table's columns as a map from column names to [Column]s using the
    /// given transaction.
    fn _get_columns_map(
        table_name: &str,
        tx: &mut sql::DbTransaction<'_>,
    ) -> Result<IndexMap<String, Column>> {
        tracing::trace!("Relatable::_get_columns_map({table_name:?}, tx)");
        let sql = format!(
            r#"SELECT * FROM "column" WHERE "table" = {sql_param}"#,
            sql_param = sql::SqlParam::new(&tx.kind()).next()
        );
        let params = json!([table_name]);
        let json_columns = tx.query(&sql, Some(&params)).unwrap_or(vec![]);
        Self::json_to_columns_map(&json_columns)
    }

    /// Returns a [Table] corresponding to the given table.
    pub async fn get_table(&self, table_name: &str) -> Result<Table> {
        tracing::trace!("Relatable::get_table({table_name:?})");
        let mut conn = self.connection.reconnect()?;
        // Begin a transaction:
        let mut tx = self.connection.begin(&mut conn).await?;

        let table = self._get_table(table_name, &mut tx)?;

        // Commit the transaction:
        tx.commit()?;

        Ok(table)
    }

    /// Returns a [Table] corresponding to the given table using the given transaction.
    fn _get_table(&self, table_name: &str, tx: &mut sql::DbTransaction<'_>) -> Result<Table> {
        tracing::trace!("Relatable::_get_table({table_name:?}, tx)");
        let statement = format!(
            r#"SELECT "table" FROM "table" WHERE "table" = {sql_param}"#,
            sql_param = sql::SqlParam::new(&tx.kind()).next()
        );
        let params = json!([table_name]);
        match tx.query_value(&statement, Some(&params))? {
            Some(_) => (),
            None => {
                return Err(RelatableError::TableError(format!(
                    "Table '{table_name}' is not in the 'table' table"
                ))
                .into())
            }
        }

        let result = tx.view_exists_for(table_name)?;
        let view = if result {
            format!("{table_name}_default_view")
        } else {
            String::from(table_name)
        };

        let statement = format!(
            r#"SELECT max(change_id) FROM history WHERE "table" = {sql_param}"#,
            sql_param = sql::SqlParam::new(&tx.kind()).next()
        );
        let params = json!([table_name]);
        let change_id = match tx.query_value(&statement, Some(&params))? {
            Some(value) => value.as_u64().unwrap_or_default() as usize,
            None => 0,
        };
        let name = table_name.to_string();

        Ok(Table {
            name,
            view,
            change_id,
            columns: Self::_get_columns_map(table_name, tx)?,
            ..Default::default()
        })
    }

    /// Returns all of the tables that have entries in the table table as a map from table names
    /// to Table structs.
    pub async fn get_tables(&self) -> Result<IndexMap<String, Table>> {
        tracing::trace!("Relatable::get_tables()");
        let mut tables = IndexMap::new();
        let statement = format!(
            r#"SELECT "_id", "_order", "table", "path",
                 (SELECT max(change_id)
                  FROM history
                  WHERE history."table" = "table"."table"
                 ) AS _change_id
               FROM 'table'"#
        );

        let rows = self.connection.query(&statement, None).await?;
        for row in rows {
            let name = row.get_string("table")?;
            tables.insert(
                name.clone(),
                Table {
                    name: name.clone(),
                    change_id: row
                        .content
                        .get("_change_id")
                        .and_then(|i| i.as_u64())
                        .unwrap_or_default() as usize,
                    columns: self.get_columns_map(&name).await?,
                    view: format!("{name}_default_view"),
                    ..Default::default()
                },
            );
        }
        Ok(tables)
    }

    /// Returns the value of the _order column of the given row from the given table using the
    /// given transaction.
    fn _get_row_order(
        &self,
        table: &str,
        row: usize,
        tx: &mut sql::DbTransaction<'_>,
    ) -> Result<usize> {
        tracing::trace!("Relatable::_get_row_order({table:?}, {row}, tx)");
        let sql = format!(
            r#"SELECT "_order" FROM "{table}" WHERE "_id" = {sql_param}"#,
            sql_param = sql::SqlParam::new(&tx.kind()).next()
        );
        let params = json!([row]);
        let rows = tx.query(&sql, Some(&params))?;
        if rows.len() == 0 {
            return Err(
                RelatableError::InputError(format!("No row {row} in table '{table}'")).into(),
            );
        }
        Ok(rows[0].get_unsigned("_order")?)
    }

    /// Returns the row id that comes before the given row in the given table, using the given
    /// transaction.
    fn _get_previous_row_id(
        &self,
        table: &str,
        row: usize,
        tx: &mut sql::DbTransaction<'_>,
    ) -> Result<usize> {
        tracing::trace!("Relatable::_get_previous_row_id({table:?}, {row}, tx)");
        let curr_row_order = self._get_row_order(table, row, tx)?;
        let sql = format!(
            r#"SELECT "_id" FROM "{table}" WHERE "_order" < {sql_param}
               ORDER BY "_order" DESC LIMIT 1"#,
            sql_param = sql::SqlParam::new(&tx.kind()).next()
        );
        let params = json!([curr_row_order]);
        let rows = tx.query(&sql, Some(&params))?;
        if rows.len() == 0 {
            Ok(0)
        } else {
            rows[0].get_unsigned("_id")
        }
    }

    /// Return a [JsonRow](sql::JsonRow) representing the given row of the given table, using the
    /// given transaction.
    fn _get_row(
        &self,
        table: &str,
        row: usize,
        tx: &mut sql::DbTransaction<'_>,
    ) -> Result<Option<sql::JsonRow>> {
        tracing::trace!("Relatable::_get_row({table:}?, {row}, tx)");
        let sql = format!(
            r#"SELECT * FROM "{table}" WHERE "_id" = {sql_param}"#,
            sql_param = sql::SqlParam::new(&tx.kind()).next()
        );
        let params = json!([row]);
        tx.query_one(&sql, Some(&params))
    }

    /// Returns a [Site] corresponding to the given username.
    pub async fn get_site(&self, username: &str) -> Site {
        tracing::trace!("Relatable::get_site({username:?})");
        let mut users = self.get_users().await.unwrap_or_default();
        users.shift_remove(username);
        Site {
            title: "RLTBL".to_string(),
            root: self.root.clone(),
            editable: !self.readonly,
            user: self.get_user(username).await,
            users,
            tables: self.get_tables().await.unwrap_or_default(),
        }
    }

    /// Updates the cursor field in the user table for the user associated with the given
    /// changeset.
    pub fn prepare_user_cursor(
        &self,
        changeset: &ChangeSet,
        tx: &mut sql::DbTransaction<'_>,
    ) -> Result<()> {
        tracing::trace!("Relatable::prepare_user_cursor({changeset:?}, tx)");
        // Make sure the user is present in the user table
        let user = changeset.user.clone();
        let color = random_color::RandomColor::new().to_hex();
        let statement = format!(
            r#"SELECT 1 FROM "user" WHERE "name" = {sql_param}"#,
            sql_param = sql::SqlParam::new(&tx.kind()).next()
        );
        let params = json!([user]);
        if let None = tx.query_value(&statement, Some(&params))? {
            let statement = format!(
                r#"INSERT INTO "user" ("name", "color") VALUES ({sql_params})"#,
                sql_params = sql::SqlParam::new(&tx.kind()).get_as_list(2)
            );
            let params = json!([user, color]);
            tx.query(&statement, Some(&params))?;
        }

        // Update the user's cursor position.
        let mut cursor = changeset.to_cursor()?;
        match changeset.action {
            ChangeAction::Undo | ChangeAction::Redo => match changeset.changes.first() {
                Some(Change::Delete { row, after: _ }) => {
                    cursor.row = self._get_previous_row_id(&changeset.table, *row, tx)?;
                }
                _ => (),
            },
            ChangeAction::Do => (),
        };

        let mut sql_param = sql::SqlParam::new(&tx.kind());
        let statement = format!(
            r#"UPDATE "user"
               SET "cursor" = {sql_param_1}, "datetime" = CURRENT_TIMESTAMP
               WHERE "name" = {sql_param_2}"#,
            sql_param_1 = sql_param.next(),
            sql_param_2 = sql_param.next(),
        );
        let params = json!([to_value(cursor).unwrap_or_default(), user]);
        tx.query_value(&statement, Some(&params))?;

        Ok(())
    }

    /// Get the last set of changes that can be redone for the given user
    pub async fn get_last_redoable_changeset_for_user(
        &self,
        user: &str,
    ) -> Result<Option<(usize, ChangeSet)>> {
        tracing::trace!("Relatable::get_last_redoable_changeset_for_user({user:?})");
        let history = self.get_user_history(user, Some(1)).await?;
        match history.changes_undone_stack.first() {
            None => Ok(None),
            Some(change) => {
                let change_id = change.get_unsigned("change_id")?;
                let content = change.get_string("content")?;
                let changes = Change::many_from_str(&content)?;
                Ok(Some((
                    change_id,
                    ChangeSet {
                        action: ChangeAction::from_str(&change.get_string("action")?)?,
                        table: change.get_string("table")?,
                        user: change.get_string("user")?,
                        description: change.get_string("user")?,
                        changes: changes,
                    },
                )))
            }
        }
    }

    /// Get the last set of changes that can be undone for the given user
    pub async fn get_last_undoable_changeset_for_user(
        &self,
        user: &str,
    ) -> Result<Option<(usize, ChangeSet)>> {
        tracing::trace!("Relatable::get_last_undoable_changeset_for_user({user:?})");
        let history = self.get_user_history(user, Some(1)).await?;
        match history.changes_done_stack.first() {
            None => Ok(None),
            Some(change) => {
                let change_id = change.get_unsigned("change_id")?;
                let content = change.get_string("content")?;
                let changes = Change::many_from_str(&content)?;
                Ok(Some((
                    change_id,
                    ChangeSet {
                        action: ChangeAction::from_str(&change.get_string("action")?)?,
                        table: change.get_string("table")?,
                        user: change.get_string("user")?,
                        description: change.get_string("user")?,
                        changes: changes,
                    },
                )))
            }
        }
    }

    /// Return a [History] for the given user with at most `context` (or [HISTORY_MAX] if this
    /// is not given) undoable and/or redoable previous changes.
    pub async fn get_user_history(&self, user: &str, context: Option<usize>) -> Result<History> {
        tracing::trace!("Relatable::get_user_history({user:?}, {context:?})");
        fn content_to_json_row(content: &str) -> Result<sql::JsonRow> {
            tracing::debug!("Entering content_to_json_row(content: {content})");
            match serde_json::from_str::<JsonValue>(content) {
                Ok(content) => match content
                    .as_array()
                    .and_then(|a| a.first())
                    .and_then(|o| o.as_object())
                {
                    Some(object) => Ok(sql::JsonRow {
                        content: object.clone(),
                    }),
                    None => {
                        return Err(RelatableError::InputError(format!(
                            "Received invalid or empty content: {content}. Expected a non-empty \
                             object array."
                        ))
                        .into())
                    }
                },
                Err(err) => {
                    return Err(
                        RelatableError::InputError(format!("Error reading content: {err}")).into(),
                    )
                }
            }
        }

        fn on_the_same_target(change1: &sql::JsonRow, change2: &sql::JsonRow) -> Result<bool> {
            tracing::trace!("Relatable::on_the_same_target({change1:?}, {change2:?})");
            let change1 = content_to_json_row(&change1.get_string("content")?)?;
            let change2 = content_to_json_row(&change2.get_string("content")?)?;
            let row1 = change1.get_unsigned("row")?;
            let row2 = change2.get_unsigned("row")?;
            if row1 != row2 {
                return Ok(false);
            }
            if let Ok(column1) = change1.get_string("column") {
                if let Ok(column2) = change2.get_string("column") {
                    return Ok(column1 == column2);
                }
            }
            Ok(true)
        }

        fn prune_stacks(
            changes_done_stack: &Vec<sql::JsonRow>,
            changes_undone_stack: &Vec<sql::JsonRow>,
        ) -> (Vec<sql::JsonRow>, Vec<sql::JsonRow>) {
            tracing::trace!(
                "Relatable::prune_stacks({changes_done_stack:?}, {changes_undone_stack:?})"
            );
            let mut pruned_dones = vec![];
            let mut pruned_undones = vec![];
            for change in changes_done_stack.iter() {
                if !pruned_dones.iter().any(|done: &sql::JsonRow| {
                    on_the_same_target(&done, &change).expect("Error looking for a common target")
                }) {
                    pruned_dones.push(change.clone());
                }
            }
            for change in changes_undone_stack.iter() {
                if !pruned_undones.iter().any(|undone: &sql::JsonRow| {
                    on_the_same_target(&undone, &change).expect("Error looking for a common target")
                }) {
                    pruned_undones.push(change.clone());
                }
            }
            (pruned_dones, pruned_undones)
        }

        // TODO: Think about paging when there are a lot of change records to go through.
        let sql = format!(
            r#"SELECT "change_id", "user", "table", "description", "action", "content"
                 FROM "change"
                WHERE "user" = {sql_param}
                ORDER BY "change_id" DESC"#,
            sql_param = sql::SqlParam::new(&self.connection.kind()).next()
        );
        let params = json!([user]);
        let history = self.connection.query(&sql, Some(&params)).await?;

        // Initialize the stacks to be returned and counters:
        let mut changes_done_stack = vec![];
        let mut changes_undone_stack = vec![];
        let mut do_redo_count: usize;
        let mut undo_count: usize;

        // Begin with the last change that was made:
        let (final_change, final_action) = match history.first() {
            None => return Ok(History::default()),
            Some(final_change) => {
                let final_action = ChangeAction::from_str(&final_change.get_string("action")?)?;
                (final_change, final_action)
            }
        };
        match final_action {
            ChangeAction::Do | ChangeAction::Redo => {
                do_redo_count = 1;
                undo_count = 0;
            }
            ChangeAction::Undo => {
                do_redo_count = 0;
                undo_count = 1;
            }
        };
        let mut change_to_push = final_change;
        let mut action_to_push = final_action;
        tracing::debug!("Setting the change to push ({action_to_push}) to: {change_to_push:?}");
        tracing::debug!(
            "The do/redo count is now {do_redo_count}, and the undo count is \
             {undo_count}."
        );

        // For each action, find the point where it began, and then place it onto changes_done_stack
        // or changes_undone_stack, as appropriate:
        for prior_change in &history[1..] {
            let prior_action = ChangeAction::from_str(&prior_change.get_string("action")?)?;
            tracing::debug!("The change prior to it is a {prior_action}: {prior_change:?}.");
            match action_to_push {
                ChangeAction::Do => match prior_action {
                    ChangeAction::Do | ChangeAction::Redo => {
                        tracing::debug!(
                            "Pushing change {cid} to changes_done",
                            cid = change_to_push.get_string("change_id")?
                        );
                        changes_done_stack.push(change_to_push.clone());
                        change_to_push = prior_change;
                        action_to_push =
                            ChangeAction::from_str(&change_to_push.get_string("action")?)?;
                        do_redo_count = 1;
                        undo_count = 0;
                        tracing::debug!(
                            "The next change to push is a {action_to_push}: {change_to_push:?}"
                        );
                    }
                    ChangeAction::Undo => {
                        tracing::debug!(
                            "Pushing change {cid} to changes_done",
                            cid = change_to_push.get_string("change_id")?
                        );
                        changes_done_stack.push(change_to_push.clone());
                        change_to_push = prior_change;
                        action_to_push =
                            ChangeAction::from_str(&change_to_push.get_string("action")?)?;
                        do_redo_count = 0;
                        undo_count = 1;
                        tracing::debug!(
                            "The next change to push is a {action_to_push}: {change_to_push:?}"
                        );
                    }
                },
                ChangeAction::Undo => match prior_action {
                    ChangeAction::Undo => {
                        if do_redo_count == 0 {
                            tracing::debug!(
                                "Pushing change {cid} to changes_undone",
                                cid = change_to_push.get_string("change_id")?
                            );
                            changes_undone_stack.push(change_to_push.clone());
                            change_to_push = prior_change;
                            action_to_push =
                                ChangeAction::from_str(&change_to_push.get_string("action")?)?;
                            tracing::debug!(
                                "The next change to push is a {action_to_push}: {change_to_push:?}"
                            );
                            undo_count += 1;
                        } else {
                            do_redo_count -= 1;
                            undo_count += 1;
                        }
                    }
                    ChangeAction::Do | ChangeAction::Redo => {
                        if undo_count == 0 {
                            tracing::debug!(
                                "Pushing change {cid} to changes_undone",
                                cid = change_to_push.get_string("change_id")?
                            );
                            changes_undone_stack.push(change_to_push.clone());
                            change_to_push = prior_change;
                            action_to_push =
                                ChangeAction::from_str(&change_to_push.get_string("action")?)?;
                            do_redo_count = 1;
                            tracing::debug!(
                                "The next change to push is a {action_to_push}: {change_to_push:?}"
                            );
                        } else {
                            do_redo_count += 1;
                            undo_count -= 1;
                        }
                    }
                },
                ChangeAction::Redo => match prior_action {
                    ChangeAction::Redo => {
                        if undo_count == 0 {
                            tracing::debug!(
                                "Pushing change {cid} to changes_done",
                                cid = change_to_push.get_string("change_id")?
                            );
                            changes_done_stack.push(change_to_push.clone());
                            change_to_push = prior_change;
                            action_to_push =
                                ChangeAction::from_str(&change_to_push.get_string("action")?)?;
                            tracing::debug!(
                                "The next change to push is a {action_to_push}: {change_to_push:?}"
                            );
                            do_redo_count += 1;
                        } else {
                            do_redo_count += 1;
                            undo_count -= 1;
                        }
                    }
                    ChangeAction::Do => {
                        if undo_count == 0 {
                            tracing::debug!(
                                "Pushing change {cid} to changes_done",
                                cid = change_to_push.get_string("change_id")?
                            );
                            changes_done_stack.push(change_to_push.clone());
                            change_to_push = prior_change;
                            action_to_push =
                                ChangeAction::from_str(&change_to_push.get_string("action")?)?;
                            tracing::debug!(
                                "The next change to push is a {action_to_push}: {change_to_push:?}"
                            );
                            // Dos begin anew.
                            do_redo_count = 1;
                        } else {
                            do_redo_count += 1;
                            undo_count -= 1;
                        }
                    }
                    ChangeAction::Undo => {
                        if do_redo_count == 0 {
                            tracing::debug!(
                                "Pushing change {cid} to changes_done",
                                cid = change_to_push.get_string("change_id")?
                            );
                            changes_done_stack.push(change_to_push.clone());
                            change_to_push = prior_change;
                            action_to_push =
                                ChangeAction::from_str(&change_to_push.get_string("action")?)?;
                            tracing::debug!(
                                "The next change to push is a {action_to_push}: {change_to_push:?}"
                            );
                            undo_count = 1;
                        } else {
                            do_redo_count -= 1;
                            undo_count += 1;
                        }
                    }
                },
            };

            tracing::debug!(
                "Updated the do/redo count to {do_redo_count}, and the undo count to \
                 {undo_count}."
            );

            // Remove duplicate entries from the stacks. These can result when a row is repeatedly
            // undone and redone. These are harmless, logically speaking, but they may potentially
            // confuse the user if they are included in the output.
            (changes_done_stack, changes_undone_stack) =
                prune_stacks(&changes_done_stack, &changes_undone_stack);

            // Check if we have exceeded the (max) context, and if so, stop looking for more
            // actions:
            let mut done_len = changes_done_stack.len();
            let mut undone_len = changes_undone_stack.len();
            match action_to_push {
                ChangeAction::Do | ChangeAction::Redo => done_len += 1,
                ChangeAction::Undo => undone_len += 1,
            };
            if let Some(context) = context {
                if done_len >= context && undone_len >= context {
                    break;
                }
            } else if done_len >= HISTORY_MAX || undone_len >= HISTORY_MAX {
                break;
            }
        }

        // Once we have finished iterating, there will be one action left over to push, which we
        // do now:
        match action_to_push {
            ChangeAction::Do | ChangeAction::Redo => {
                tracing::debug!("Pushing the last change to changes_done: {change_to_push:?}");
                changes_done_stack.push(change_to_push.clone());
            }
            ChangeAction::Undo => {
                tracing::debug!("Pushing the last change to changes_undone: {change_to_push:?}");
                changes_undone_stack.push(change_to_push.clone());
            }
        };

        // Don't return the contents of changes_undone if the last change was a do. Dos can never be
        // redone. If the last change was an undo or a redo, the logic will take care of itself and
        // it should never be possible to undo or redo inappropriately.
        let mut changes_undone_stack = match final_action {
            ChangeAction::Do => vec![],
            _ => changes_undone_stack,
        };

        // Prune the stacks one last time, in case by adding the final action we created a situation
        // in which one of the stacks contains duplicates:
        (changes_done_stack, changes_undone_stack) =
            prune_stacks(&changes_done_stack, &changes_undone_stack);

        // Similarly, crop for context one last time if a context has been defined:
        let history = match context {
            None => History {
                changes_done_stack,
                changes_undone_stack,
            },
            Some(context) => {
                let mut done_len = changes_done_stack.len();
                if done_len > context {
                    done_len = context;
                }
                let changes_done_stack = changes_done_stack[..done_len].to_vec();

                let mut undone_len = changes_undone_stack.len();
                if undone_len > context {
                    undone_len = context;
                }
                let changes_undone_stack = changes_undone_stack[..undone_len].to_vec();
                History {
                    changes_done_stack,
                    changes_undone_stack,
                }
            }
        };
        tracing::debug!("Returning history: {history:#?}");
        Ok(history)
    }

    /// Reverse the given changeset in the database
    async fn _reverse(&self, change_id: usize, changeset: &ChangeSet) -> Result<Option<ChangeSet>> {
        tracing::trace!("Relatable::_reverse({change_id}, {changeset:?})");
        match changeset.changes.first() {
            None => Ok(None),
            Some(change) => {
                if let Change::Update { .. } = change {
                    let conn = self.connection.reconnect()?;
                    let actual_changes = self._set_values(conn, &changeset).await?;
                    Ok(Some(actual_changes))
                } else {
                    let mut actual_changes = vec![];
                    for change in changeset.changes.iter() {
                        let conn = self.connection.reconnect()?;
                        match change {
                            Change::Update { .. } => (), // Change::Update already handled above.
                            Change::Add { row, after: _ } => {
                                let num_deleted = self
                                    ._delete_row(
                                        conn,
                                        &changeset.action,
                                        &changeset.table,
                                        &changeset.user,
                                        *row,
                                    )
                                    .await?;
                                if num_deleted > 0 {
                                    actual_changes.push(change.clone());
                                }
                            }
                            Change::Move {
                                row,
                                from_after,
                                to_after: _,
                            } => {
                                let new_order = self
                                    ._move_and_record_row(
                                        conn,
                                        &changeset.action,
                                        &changeset.table,
                                        &changeset.user,
                                        *row,
                                        *from_after,
                                    )
                                    .await?;
                                if new_order > 0 {
                                    actual_changes.push(change.clone());
                                }
                            }
                            Change::Delete { row, after } => {
                                // Get the row, as it was before it was deleted, from the history
                                // table:
                                let sql = format!(
                                    r#"SELECT "before" FROM "history"
                                       WHERE "change_id" = {sql_param}"#,
                                    sql_param = sql::SqlParam::new(&self.connection.kind()).next()
                                );
                                let params = json!([change_id]);
                                let before = self
                                    .connection
                                    .query_one(&sql, Some(&params))
                                    .await?
                                    .ok_or(RelatableError::DataError(format!(
                                        "No history row found with change_id {change_id}"
                                    )))?
                                    .get_string("before")?;
                                let before = match serde_json::from_str::<JsonValue>(&before) {
                                    Err(err) => return Err(err.into()),
                                    Ok(JsonValue::Object(o)) => o,
                                    Ok(_) => {
                                        return Err(RelatableError::InputError(
                                            "The content parameter is not an object".to_string(),
                                        )
                                        .into());
                                    }
                                };
                                let before = sql::JsonRow { content: before };
                                tracing::debug!(
                                    "Re-adding row '{before}' to table '{}'",
                                    changeset.table
                                );
                                self._add_row(
                                    conn,
                                    &changeset.action,
                                    &changeset.table,
                                    &changeset.user,
                                    Some(*row),
                                    Some(*after),
                                    &before,
                                )
                                .await?;
                                actual_changes.push(change.clone());
                            }
                        };
                    }
                    Ok(Some(ChangeSet {
                        action: changeset.action,
                        table: changeset.table.clone(),
                        user: changeset.user.clone(),
                        description: changeset.description.clone(),
                        changes: actual_changes,
                    }))
                }
            }
        }
    }

    /// Undo the last change made by the given user
    pub async fn undo(&self, user: &str) -> Result<Option<ChangeSet>> {
        tracing::trace!("Relatable::undo({user:?})");
        let (change_id, mut changeset) =
            match self.get_last_undoable_changeset_for_user(user).await? {
                None => {
                    tracing::warn!("Nothing to undo for '{user}'");
                    return Ok(None);
                }
                Some(changeset) => changeset,
            };
        changeset.action = ChangeAction::Undo;
        let changeset = self._reverse(change_id, &changeset).await?;
        if let Some(_) = changeset {
            self.commit_to_git().await?;
        }
        Ok(changeset)
    }

    /// Redo the last change undone by the given user
    pub async fn redo(&self, user: &str) -> Result<Option<ChangeSet>> {
        tracing::trace!("Relatable::redo({user:?})");
        let (change_id, mut changeset) =
            match self.get_last_redoable_changeset_for_user(user).await? {
                None => {
                    tracing::warn!("Nothing to redo for '{user}'");
                    return Ok(None);
                }
                Some(changeset) => changeset,
            };
        tracing::debug!("Last redoable action (ID {change_id}) for user {user} was {changeset:?}");
        changeset.action = ChangeAction::Redo;
        let changeset = self._reverse(change_id, &changeset).await?;
        if let Some(_) = changeset {
            self.commit_to_git().await?;
        }
        Ok(changeset)
    }

    /// Update the database using the given [ChangeSet]
    async fn _set_values(
        &self,
        mut conn: Option<sql::DbActiveConnection>,
        changeset: &ChangeSet,
    ) -> Result<ChangeSet> {
        tracing::trace!("Relatable::set_values(conn, {changeset:?})");
        // Begin a transaction:
        let mut tx = self.connection.begin(&mut conn).await?;

        // Update the user cursor
        self.prepare_user_cursor(changeset, &mut tx)?;

        let table = self._get_table(&changeset.table, &mut tx)?;
        let nullify_value = |column: &str, value: &JsonValue| -> Result<JsonValue> {
            match value {
                JsonValue::String(s) if s == "" => {
                    let nulltype = {
                        table
                            .get_column_attribute(column, "nulltype")
                            .unwrap_or("".to_string())
                    };
                    if nulltype == "empty" {
                        Ok(JsonValue::Null)
                    } else {
                        Ok(value.clone())
                    }
                }
                _ => Ok(value.clone()),
            }
        };

        // Actually make the changes:
        let mut actual_changes = vec![];
        for change in &changeset.changes {
            match change {
                Change::Update {
                    row,
                    column,
                    before,
                    after,
                } => {
                    // Depending on whether this is an undo/redo or an original action, the
                    // new value will be taken from either `before` or `after`.
                    let before = nullify_value(column, before)?;
                    let after = nullify_value(column, after)?;
                    let value = match &changeset.action {
                        ChangeAction::Undo | ChangeAction::Redo => before.clone(),
                        ChangeAction::Do => after.clone(),
                    };
                    let db_kind = self.connection.kind();
                    let (sql, params) = {
                        let mut sql_param = sql::SqlParam::new(&db_kind);
                        let sql = format!(
                            r#"UPDATE "{table}"
                               SET "{column}" = {value}
                               WHERE _id = {sql_param}
                               RETURNING 1 AS "updated""#,
                            table = changeset.table,
                            value = match value {
                                JsonValue::Null => "NULL".to_string(),
                                _ => sql_param.next(),
                            },
                            sql_param = sql_param.next()
                        );
                        let params = match value {
                            JsonValue::Null => json!([row]),
                            _ => json!([sql::json_to_string(&value), row]),
                        };
                        (sql, params)
                    };

                    if tx.query(&sql, Some(&params))?.len() < 1 {
                        tracing::warn!("No row with _id {row} found to update");
                    } else {
                        actual_changes.push(Change::Update {
                            row: *row,
                            column: column.clone(),
                            before: match &changeset.action {
                                ChangeAction::Undo | ChangeAction::Redo => after.clone(),
                                ChangeAction::Do => before.clone(),
                            },
                            after: match &changeset.action {
                                ChangeAction::Undo | ChangeAction::Redo => before.clone(),
                                ChangeAction::Do => after.clone(),
                            },
                        });
                    }
                }
                _ => {
                    return Err(RelatableError::InputError(format!(
                        "Invalid change in changeset argument to set_values(): {change:?}"
                    ))
                    .into());
                }
            };
        }

        let num_changes = actual_changes.len();
        let actual_changeset = ChangeSet {
            action: changeset.action,
            table: changeset.table.clone(),
            user: changeset.user.clone(),
            description: changeset.description.clone(),
            changes: actual_changes,
        };
        if num_changes > 0 {
            // Record the changes to the change and history tables:
            self.record_changeset(&actual_changeset, &mut tx)?;
        }

        // Commit the transaction:
        tx.commit()?;

        Ok(actual_changeset)
    }

    /// Update the database using the given [ChangeSet]
    pub async fn set_values(&self, changeset: &ChangeSet) -> Result<ChangeSet> {
        tracing::trace!("Relatable::set_values({changeset:?})");
        let conn = self.connection.reconnect()?;
        let changeset = self._set_values(conn, changeset).await?;
        if changeset.changes.len() > 0 {
            self.commit_to_git().await?;
        }
        Ok(changeset)
    }

    /// Add a message to the message table.
    pub async fn add_message(
        &self,
        user: &str,
        table_name: &str,
        row: usize,
        column: &str,
        level: &str,
        rule: &str,
        message: &str,
    ) -> Result<(usize, Message)> {
        tracing::trace!(
            "Relatable::add_message({user:?}, {table_name:?}, {row}, \
                         {column:?}, {level:?}, {rule:?}, {message:?})"
        );
        let sql = format!(
            r#"SELECT "{column}" FROM "{table_name}" WHERE _id = {sql_param}"#,
            sql_param = sql::SqlParam::new(&self.connection.kind()).next()
        );
        let params = json!([row]);
        let value = match self.connection.query_value(&sql, Some(&params)).await? {
            Some(JsonValue::String(s)) => s.as_str().to_string(),
            Some(JsonValue::Null) | None => "".to_string(),
            Some(value) => value.to_string(),
        };

        let sql = format!(
            r#"INSERT INTO "message"
               ("added_by", "table", "row", "column", "value",
                "level", "rule", "message")
               VALUES
               ({sql_params})
               RETURNING "message_id""#,
            sql_params = sql::SqlParam::new(&self.connection.kind()).get_as_list(8)
        );
        let params = json!([user, table_name, row, column, value, level, rule, message]);
        let message_id = self
            .connection
            .query_one(&sql, Some(&params))
            .await?
            .ok_or(RelatableError::DataError(
                "Error inserting message".to_string(),
            ))?
            .get_unsigned("message_id")?;

        Ok((
            message_id,
            Message {
                level: level.to_string(),
                rule: rule.to_string(),
                message: message.to_string(),
            },
        ))
    }

    /// Add a row to the given table
    async fn _add_row(
        &self,
        mut conn: Option<sql::DbActiveConnection>,
        action: &ChangeAction,
        table_name: &str,
        user: &str,
        new_row_id: Option<usize>,
        after_id: Option<usize>,
        row: &sql::JsonRow,
    ) -> Result<Row> {
        tracing::trace!(
            "Relatable::_add_row(conn, {action:?}, {user:?}, {new_row_id:?}, \
                         {after_id:?}, {row:?})"
        );

        // Begin a transaction:
        let mut tx = self.connection.begin(&mut conn).await?;

        // Get the current database information for the table:
        let table = self._get_table(table_name, &mut tx)?;
        if !table.editable {
            return Err(
                RelatableError::InputError(format!("{} is not editable.", table_name,)).into(),
            );
        }

        // Nullify the JSON row by setting any column values whose content matches the column's
        // nulltype to Null:
        let row = sql::JsonRow::nullified(row, &table);

        // Prepare a new row to be inserted using the JSON row as a base:
        let mut new_row = Row::prepare_new(&table, Some(&row), &mut tx)?;

        // A new_row_id will have been passed if the row is being added as part of an undo/redo.
        // In that case an after_id must have been passed as well but we leave the row order as
        // is for now, since we are not assured that the old row order is actually still free in
        // the table (recall that there is a unique constraint on _order). However the row_order
        // currently assigned is at the end of the table so there should not be any conflicts.
        if let Some(new_row_id) = new_row_id {
            tracing::debug!("Changing new row ID to {new_row_id}");
            new_row.id = new_row_id;
        }

        // Add the row to the table:
        let (sql, params) = new_row.as_insert(&table.name, &tx.kind());
        tracing::info!("_add_row {sql} {params:?}");
        tx.query(&sql, Some(&params))?;

        let after_id = match after_id {
            None => self._get_previous_row_id(table_name, new_row.id, &mut tx)?,
            Some(after_id) => {
                // Move the row to its assigned spot within the table:
                tracing::debug!(
                    "Moving new row {id} to after row {after_id} in '{table}'",
                    id = new_row.id,
                    table = table.name
                );
                let new_order = self._move_row(&mut tx, &table, new_row.id, after_id)?;
                new_row.order = new_order;
                after_id
            }
        };

        tracing::debug!(
            "Added new row {id} to table '{table}' after row {after_id}",
            id = new_row.id,
            table = table.name
        );

        // Prepare a changeset to be recorded, consisting of a single change record indicating
        // the addition of one new row with the new_row's id and position in the table:
        let changeset = ChangeSet {
            action: *action,
            table: table_name.to_string(),
            user: user.to_string(),
            description: "Add one row".to_string(),
            changes: vec![Change::Add {
                row: new_row.id,
                after: after_id,
            }],
        };

        // Use the changeset to prepare the user cursor:
        self.prepare_user_cursor(&changeset, &mut tx)?;

        // Record the changes to the history table:
        self.record_changeset(&changeset, &mut tx)?;

        // Commit the transaction:
        tx.commit()?;

        Ok(new_row)
    }

    /// Add a row to the given table
    pub async fn add_row(
        &self,
        table_name: &str,
        user: &str,
        after_id: Option<usize>,
        row: &sql::JsonRow,
    ) -> Result<Row> {
        tracing::trace!("Relatable::add_row({table_name:?}, {user:?}, {after_id:?}, {row:?})");
        let conn = self.connection.reconnect()?;
        let new_row = self
            ._add_row(
                conn,
                &ChangeAction::Do,
                table_name,
                user,
                None,
                after_id,
                row,
            )
            .await?;
        self.commit_to_git().await?;
        Ok(new_row)
    }

    /// Delete a row from the table
    async fn _delete_row(
        &self,
        mut conn: Option<sql::DbActiveConnection>,
        action: &ChangeAction,
        table_name: &str,
        user: &str,
        row: usize,
    ) -> Result<usize> {
        tracing::trace!(
            "Relatable::_delete_row(conn, {action:?}, {table_name:?}, {user:?} \
                         {row})"
        );
        // Begin a transaction:
        let mut tx = self.connection.begin(&mut conn).await?;

        // Get the current database information for the table:
        let table = self._get_table(table_name, &mut tx)?;
        if !table.editable {
            return Err(
                RelatableError::InputError(format!("{} is not editable.", table_name,)).into(),
            );
        }

        // Prepare a changeset to be recorded, consisting of a single change record indicating
        // that a row with the given row number at the given table position has been deleted:
        let changeset = ChangeSet {
            action: *action,
            table: table_name.to_string(),
            user: user.to_string(),
            description: "Delete one row".to_string(),
            changes: vec![Change::Delete {
                row: row,
                after: self._get_previous_row_id(table_name, row, &mut tx)?,
            }],
        };

        // Use the changeset to prepare the user cursor:
        self.prepare_user_cursor(&changeset, &mut tx)?;

        // Delete the row:
        let sql = format!(
            r#"DELETE FROM "{}" WHERE "_id" = {sql_param} RETURNING 1 AS "deleted""#,
            table.name,
            sql_param = sql::SqlParam::new(&self.connection.kind()).next()
        );
        let params = json!([row]);

        // Record the change to the history table:
        self.record_changeset(&changeset, &mut tx)?;

        let num_deleted = tx.query(&sql, Some(&params))?.len();
        if num_deleted < 1 {
            tracing::warn!("No row found with _id {row} to delete");
            // Roll back the changes to the history and change table. The reason we made these
            // prior to the actual delete was so that we could record the row's position in the
            // table before it was deleted.
            tx.rollback()?;
        } else {
            // Commit the transaction:
            tx.commit()?;
        }

        Ok(num_deleted)
    }

    /// Delete a row from a given table
    pub async fn delete_row(&self, table_name: &str, user: &str, row: usize) -> Result<usize> {
        tracing::trace!("Relatable::delete_row({table_name:?}, {user:?}, {row})");
        let conn = self.connection.reconnect()?;
        let num_deleted = self
            ._delete_row(conn, &ChangeAction::Do, table_name, user, row)
            .await?;
        if num_deleted > 0 {
            self.commit_to_git().await?;
        }
        Ok(num_deleted)
    }

    // Delete a message from the message table
    pub async fn delete_message(
        &self,
        table: &str,
        row: Option<usize>,
        column: Option<&str>,
        target_rule: Option<&str>,
        target_user: Option<&str>,
    ) -> Result<usize> {
        tracing::trace!(
            "Relatable::delete_message({table:?}, {row:?}, {column:?}, \
                         {target_rule:?}, {target_user:?})"
        );
        let mut sql_param = sql::SqlParam::new(&self.connection.kind());
        let mut sql = format!(
            r#"DELETE FROM "message" WHERE "table" = {sql_param}"#,
            sql_param = sql_param.next()
        );
        let mut params = vec![json!(table)];

        if let Some(row) = row {
            sql.push_str(&format!(
                r#" AND "row" = {sql_param}"#,
                sql_param = sql_param.next(),
            ));
            params.push(json!(row));
        }
        if let Some(column) = column {
            sql.push_str(&format!(
                r#" AND "column" = {sql_param}"#,
                sql_param = sql_param.next()
            ));
            params.push(json!(column));
        }
        if let Some(target_rule) = target_rule {
            sql.push_str(&format!(
                r#" AND "rule" LIKE {sql_param}"#,
                sql_param = sql_param.next()
            ));
            params.push(json!(target_rule));
        }
        if let Some(target_user) = target_user {
            sql.push_str(&format!(
                r#" AND "added_by" = {sql_param}"#,
                sql_param = sql_param.next()
            ));
            params.push(json!(target_user));
        }

        sql.push_str(r#" RETURNING 1 AS "deleted""#);
        let num_deleted = self
            .connection
            .query(&sql, Some(&json!(params)))
            .await?
            .len();
        Ok(num_deleted)
    }

    /// Move a row and record the change in the change table
    async fn _move_and_record_row(
        &self,
        mut conn: Option<sql::DbActiveConnection>,
        action: &ChangeAction,
        table_name: &str,
        user: &str,
        id: usize,
        after_id: usize,
    ) -> Result<usize> {
        tracing::trace!(
            "Relatable::_move_and_record_row(conn, {action:?}, {table_name:?}, \
                         {user:?}, {id}, {after_id})"
        );

        // Begin a transaction:
        let mut tx = self.connection.begin(&mut conn).await?;

        // Get the current database information for the table:
        let table = self._get_table(table_name, &mut tx)?;
        if !table.editable {
            return Err(
                RelatableError::InputError(format!("{} is not editable.", table_name,)).into(),
            );
        }

        // Prepare a changeset to be recorded, consisting of a single change record indicating
        // that a row has been displaced from somewhere to somewhere else.
        let changeset = ChangeSet {
            action: *action,
            table: table_name.to_string(),
            user: user.to_string(),
            description: "Move one row".to_string(),
            changes: vec![Change::Move {
                row: id,
                from_after: self._get_previous_row_id(table_name, id, &mut tx)?,
                to_after: after_id,
            }],
        };

        // Use the changeset to prepare the user cursor:
        self.prepare_user_cursor(&changeset, &mut tx)?;

        // Move the row within the table:
        let new_order = self._move_row(&mut tx, &table, id, after_id)?;

        if new_order != 0 {
            // Record the change to the history table:
            self.record_changeset(&changeset, &mut tx)?;
        }

        // Commit the transaction:
        tx.commit()?;

        Ok(new_order)
    }

    /// Move a row to a different position in a given table
    fn _move_row(
        &self,
        tx: &mut sql::DbTransaction<'_>,
        table: &Table,
        id: usize,
        after_id: usize,
    ) -> Result<usize> {
        tracing::trace!("Relatable::_move_row(tx, {table:?}, {id}, {after_id})");
        fn get_row_order(
            tx: &mut sql::DbTransaction<'_>,
            table: &Table,
            row_id: usize,
        ) -> Result<usize> {
            let sql = format!(
                r#"SELECT "_order" FROM "{}" WHERE "_id" = {sql_param}"#,
                table.name,
                sql_param = sql::SqlParam::new(&tx.kind()).next()
            );
            let params = json!([row_id]);
            let rows = tx.query(&sql, Some(&params))?;
            if rows.is_empty() {
                return Err(RelatableError::DataError(format!(
                    "Unable to fetch _order for row {row_id} of table '{table}'",
                    table = table.name
                ))
                .into());
            }
            match rows[0].content.get("_order").and_then(|o| o.as_u64()) {
                Some(order) => Ok(order as usize),
                None => {
                    return Err(
                        RelatableError::DataError("No integer '_order' in row".to_string()).into(),
                    )
                }
            }
        }

        // Get the order, (A), of `after_id`:
        let order_prev = {
            if after_id > 0 {
                let mut id_to_try = after_id;
                let mut result = get_row_order(tx, table, id_to_try);
                // This handles the case in which the after row has been deleted for some reason
                // (this might happen if we are redoing).
                while let Err(_) = result {
                    if id_to_try == 0 {
                        break;
                    }
                    tracing::debug!("Could not obtain _order for row {id_to_try}");
                    id_to_try -= 1;
                    tracing::debug!("Trying to find the _order of row {id_to_try}");
                    result = get_row_order(tx, table, id_to_try);
                }
                result?
            } else {
                // It is not possible for a row to be assigned a order of zero. We allow it as a
                // possible value of `after_id`, however, which is used as a special value that we
                // should move the row identified by `id` to the beginning of the table.
                0
            }
        };

        // Run a query to get the minimum order, (B), that is greater than (A).
        let order_next = {
            let sql = format!(
                r#"SELECT MIN("_order") AS "_order" FROM "{}" WHERE "_order" > {sql_param}"#,
                table.name,
                sql_param = sql::SqlParam::new(&tx.kind()).next()
            );
            let params = json!([order_prev]);
            let rows = tx.query(&sql, Some(&params))?;
            if rows.is_empty() {
                return Err(RelatableError::DataError(format!(
                    "Could not determine the minimum row order greater than {order_prev}"
                ))
                .into());
            }

            match rows[0].content.get("_order") {
                Some(value) => match value {
                    JsonValue::Null => {
                        // The row_order will be null if we ask Relatable to move a row to
                        // a position after the last row in the table.
                        order_prev + NEW_ORDER_MULTIPLIER
                    }
                    _ => match value.as_u64() {
                        Some(order) => order as usize,
                        None => {
                            return Err(RelatableError::DataError(
                                "Field '_order' in row is not an integer".to_string(),
                            )
                            .into());
                        }
                    },
                },
                None => {
                    return Err(RelatableError::DataError("No '_order' in row".to_string()).into());
                }
            }
        };

        let mut new_order = {
            if order_prev + 1 < order_next {
                // If the next order is not occupied just use it:
                order_prev + 1
            } else {
                // Otherwise, get all the orders that need to be moved. We sort the results in
                // descending order so that when we later update each value, no duplicate key
                // violations will ensue:
                let upper_bound = (order_next as f32 / NEW_ORDER_MULTIPLIER as f32).ceil() as usize
                    * NEW_ORDER_MULTIPLIER as usize;
                let mut sql_param = sql::SqlParam::new(&tx.kind());
                let sql = format!(
                    r#"SELECT "_order"
                         FROM "{}"
                        WHERE "_order" >= {sql_param_1} AND "_order" < {sql_param_2}
                     ORDER BY "_order" DESC"#,
                    table.name,
                    sql_param_1 = sql_param.next(),
                    sql_param_2 = sql_param.next()
                );
                let params = json!([order_next, upper_bound]);
                let rows = tx.query(&sql, Some(&params))?;
                if rows.is_empty() {
                    return Err(RelatableError::DataError(
                        "Could not determine the highest row order".to_string(),
                    )
                    .into());
                }
                let highest_order = match rows[0].content.get("_order").and_then(|o| o.as_u64()) {
                    Some(order) => order as usize,
                    None => {
                        return Err(RelatableError::DataError(
                            "No field '_order' in row or it is not an integer".to_string(),
                        )
                        .into())
                    }
                };
                if highest_order + 1 >= upper_bound {
                    // Return an error
                    return Err(RelatableError::DataError(format!(
                        "Impossible to move row {} after row {}: No more room",
                        id, after_id
                    ))
                    .into());
                }

                for row in rows {
                    let current_order = match row.content.get("_order").and_then(|o| o.as_u64()) {
                        Some(order) => order as usize,
                        None => {
                            return Err(RelatableError::DataError(
                                "No field '_order' in row or it is not an integer".to_string(),
                            )
                            .into())
                        }
                    };
                    let sql = format!(
                        r#"UPDATE "{}"
                              SET "_order" = "_order" + 1
                            WHERE "_order" = {sql_param}"#,
                        table.name,
                        sql_param = sql::SqlParam::new(&tx.kind()).next()
                    );
                    let params = json!([current_order]);
                    tx.query(&sql, Some(&params))?;
                }
                // Now that we have made some room, we can use order_prev + 1,
                // which should no longer be occupied:
                order_prev + 1
            }
        };

        tracing::debug!(
            "Updating _order in table '{table}' for row {id} to {new_order}",
            table = table.name
        );

        let mut sql_param = sql::SqlParam::new(&tx.kind());
        let sql = format!(
            r#"UPDATE "{}" SET "_order" = {sql_param_1}
               WHERE "_id" = {sql_param_2}
               RETURNING 1 AS "moved""#,
            table.name,
            sql_param_1 = sql_param.next(),
            sql_param_2 = sql_param.next(),
        );
        let params = json!([new_order, id]);
        if tx.query(&sql, Some(&params))?.len() < 1 {
            tracing::warn!("Now row with _id {id} found to move");
            // It is not possible for a row to have an order of zero. It is used here to
            // represent the case where no row was actually moved to the caller.
            new_order = 0;
        }
        Ok(new_order)
    }

    /// Change the _id of the given row in the given table.
    fn _change_row_id(
        &self,
        tx: &mut sql::DbTransaction<'_>,
        table: &Table,
        id: usize,
        new_id: usize,
    ) -> Result<()> {
        tracing::trace!("Relatable::_change_row_id(tx, {table:?}, {id}, {new_id})");
        let mut sql_param = sql::SqlParam::new(&tx.kind());
        let sql = format!(
            r#"UPDATE "{table}"
                  SET "_id" = {sql_param_1}, "_order" = {sql_param_2}
                WHERE "_id" = {sql_param_3}
            RETURNING "_id" AS "_id""#,
            table = table.name,
            sql_param_1 = sql_param.next(),
            sql_param_2 = sql_param.next(),
            sql_param_3 = sql_param.next(),
        );
        let params = json!([new_id, id, id * NEW_ORDER_MULTIPLIER]);
        tx.query_one(&sql, Some(&params))?
            .ok_or(RelatableError::DataError(format!("No row with _id = {id}")))?
            .get_unsigned("_id")?;
        Ok(())
    }

    /// Move a row to a different position in a given table.
    pub async fn move_row(
        &self,
        table_name: &str,
        user: &str,
        id: usize,
        after_id: usize,
    ) -> Result<usize> {
        tracing::trace!("Relatable::move_row({table_name:?}, {user:?}, {after_id:?})");
        let conn = self.connection.reconnect()?;
        let new_order = self
            ._move_and_record_row(conn, &ChangeAction::Do, table_name, user, id, after_id)
            .await?;
        if new_order != 0 {
            self.commit_to_git().await?;
        }
        Ok(new_order)
    }
}

/// A set of changes made by a user to a table.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ChangeSet {
    pub action: ChangeAction,
    pub table: String,
    pub user: String,
    pub description: String,
    pub changes: Vec<Change>,
}

impl ChangeSet {
    /// Given a change, returns the a [Cursor] representing where the user's cursor
    /// should be placed in the frontend.
    fn to_cursor(&self) -> Result<Cursor> {
        tracing::trace!("ChangeSet::to_cursor()");
        let table = self.table.clone();
        match self.changes.first() {
            Some(change) => match change {
                Change::Update {
                    row,
                    column,
                    before: _,
                    after: _,
                } => Ok(Cursor {
                    table,
                    row: *row,
                    column: column.to_string(),
                }),
                Change::Add { row, after: _ } => Ok(Cursor {
                    table,
                    row: *row,
                    column: "".to_string(),
                }),
                Change::Move {
                    row,
                    from_after: _,
                    to_after: _,
                } => Ok(Cursor {
                    table,
                    row: *row,
                    column: "".to_string(),
                }),
                Change::Delete { row, after: _ } => Ok(Cursor {
                    table,
                    row: *row,
                    column: "".to_string(),
                }),
            },
            None => Err(RelatableError::ChangeError("No changes in set".into()).into()),
        }
    }
}

/// The kind of action that is performed by a change
#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq)]
pub enum ChangeAction {
    Do,
    Undo,
    Redo,
}

impl FromStr for ChangeAction {
    type Err = anyhow::Error;

    fn from_str(action: &str) -> Result<Self> {
        tracing::trace!("ChangeAction::from_str({action:?})");
        match action.to_lowercase().as_str() {
            "do" => Ok(Self::Do),
            "undo" => Ok(Self::Undo),
            "redo" => Ok(Self::Redo),
            _ => {
                return Err(
                    RelatableError::InputError(format!("Unrecognized action: {action}")).into(),
                );
            }
        }
    }
}

impl Display for ChangeAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ChangeAction::Do => write!(f, "do"),
            ChangeAction::Undo => write!(f, "undo"),
            ChangeAction::Redo => write!(f, "redo"),
        }
    }
}

/// A change to a table in the database
#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum Change {
    Update {
        /// The id of the row that was updated
        row: usize,
        /// The column whose value was updated
        column: String,
        /// The value of the column before the change
        before: JsonValue,
        /// The value of the column after the change
        after: JsonValue,
    },
    Add {
        /// The id of the row that was added
        row: usize,
        /// The _id of the row whose _order this comes immediately after in the table
        after: usize,
    },
    Move {
        /// The id of the row that was moved
        row: usize,
        /// The row that this row came after before the change
        from_after: usize,
        /// The row that this row came after after the change
        to_after: usize,
    },
    Delete {
        /// The id of the row that was deleted
        row: usize,
        /// The _id of the row whose _order this row came immediately after in the table before
        /// being deleted.
        after: usize,
    },
}

impl Change {
    /// Converts a JSON string representing an array of changes to an array of [Change] structs.
    pub fn many_from_str(content: &str) -> Result<Vec<Self>> {
        tracing::trace!("Change::many_from_str({content:?})");
        let json_content = match serde_json::from_str::<JsonValue>(content) {
            Err(err) => return Err(err.into()),
            Ok(JsonValue::Array(v)) => v,
            Ok(_) => {
                return Err(RelatableError::InputError(
                    "The content parameter is not an array".to_string(),
                )
                .into());
            }
        };

        let mut changes = vec![];
        for change_json in json_content.iter() {
            let change_json = match change_json.as_object() {
                Some(change_object) => sql::JsonRow {
                    content: change_object.clone(),
                },
                None => {
                    return Err(RelatableError::InputError(format!(
                        "Not an object: {change_json}"
                    ))
                    .into());
                }
            };

            let change_type = change_json.get_string("type")?;
            let row = change_json.get_unsigned("row")?;
            match change_type.as_str() {
                "Update" => changes.push(Change::Update {
                    row: row,
                    column: change_json.get_string("column")?,
                    before: change_json.get_value("before")?,
                    after: change_json.get_value("after")?,
                }),
                "Add" => changes.push(Change::Add {
                    row: row,
                    after: change_json.get_unsigned("after")?,
                }),
                "Delete" => changes.push(Change::Delete {
                    row: row,
                    after: change_json.get_unsigned("after")?,
                }),
                "Move" => changes.push(Change::Move {
                    row: row,
                    from_after: change_json.get_unsigned("from_after")?,
                    to_after: change_json.get_unsigned("to_after")?,
                }),
                _ => {
                    return Err(RelatableError::InputError(format!(
                        "Unrecognized change type for change: {change_json}"
                    ))
                    .into());
                }
            };
        }
        Ok(changes)
    }

    /// Convers a [JsonRow](sql::JsonRow) to a [Change]
    pub fn from_json_row(json_row: &sql::JsonRow) -> Result<Self> {
        tracing::trace!("Change::from_json_row({json_row:?})");
        match json_row.get_string("type")?.as_str() {
            "Update" => Ok(Self::Update {
                row: json_row.get_unsigned("row")?,
                column: json_row.get_string("column")?,
                before: json_row.get_value("before")?,
                after: json_row.get_value("after")?,
            }),
            "Add" => Ok(Self::Add {
                row: json_row.get_unsigned("row")?,
                after: json_row.get_unsigned("after")?,
            }),
            "Move" => Ok(Self::Move {
                row: json_row.get_unsigned("row")?,
                from_after: json_row.get_unsigned("from_after")?,
                to_after: json_row.get_unsigned("to_after")?,
            }),
            "Delete" => Ok(Self::Delete {
                row: json_row.get_unsigned("row")?,
                after: json_row.get_unsigned("after")?,
            }),
            _ => {
                return Err(RelatableError::InputError(format!(
                    "Unrecognized action type for change {json_row}"
                ))
                .into());
            }
        }
    }
}

/// Describes a history of changes that have been done and undone.
#[derive(Default, Debug, Serialize, Deserialize)]
pub struct History {
    pub changes_done_stack: Vec<sql::JsonRow>,
    pub changes_undone_stack: Vec<sql::JsonRow>,
}

impl Display for Change {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Change::Update {
                row,
                column,
                before,
                after,
            } => {
                write!(
                    f,
                    "Update '{column}' in row {row} from {before} to {after}",
                    before = sql::json_to_string(before),
                    after = sql::json_to_string(after)
                )
            }
            Change::Add { row, after } => {
                write!(f, "Add row {row} after row {after}")
            }
            Change::Move {
                row,
                from_after,
                to_after,
            } => {
                write!(
                    f,
                    "Move row {row} from after row {from_after} to after row {to_after}"
                )
            }
            Change::Delete { row, after: _ } => write!(f, "Delete row {row}"),
        }
    }
}

/// Represents a validation message
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Message {
    /// The severity of the message.
    pub level: String,
    /// The rule violation that the message is about.
    pub rule: String,
    /// The contents of the message.
    pub message: String,
}

/// Represents a cell from a row in a given table
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Cell {
    pub value: JsonValue,
    pub text: String,
    pub messages: Vec<Message>,
}

impl From<&JsonValue> for Cell {
    /// Converts a [JsonValue] to a [Cell]
    fn from(value: &JsonValue) -> Self {
        tracing::trace!("Cell::from({value:?})");
        Self {
            value: value.clone(),
            text: match value {
                JsonValue::String(value) => value.to_string(),
                value => format!("{value}"),
            },
            messages: vec![],
        }
    }
}

/// Represents a row from some table
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Row {
    pub id: usize,
    pub order: usize,
    pub change_id: usize,
    pub cells: IndexMap<String, Cell>,
}

impl Row {
    /// Prepares a new [Row] for insertion to the given [Table], with its [id](Row::id) and
    /// [order](Row::order) fields pre-assigned with their correct next values for this table
    fn prepare_new(
        table: &Table,
        json_row: Option<&sql::JsonRow>,
        tx: &mut sql::DbTransaction<'_>,
    ) -> Result<Self> {
        tracing::trace!("Row::prepare_new({table:?}, {json_row:?}, tx)");
        let json_row = match json_row {
            None => {
                let columns = {
                    let columns = tx.get_table_columns(&table.name)?;
                    if columns.is_empty() {
                        return Err(RelatableError::DataError(format!(
                            "No defined columns for: {table}",
                            table = table.name
                        ))
                        .into());
                    }
                    columns
                        .iter()
                        .map(|c| c.get_string("name").expect("No 'name' found"))
                        .filter(|n| !n.starts_with("_"))
                        .collect::<Vec<_>>()
                };
                let columns = columns.iter().map(|c| c.as_str()).collect::<Vec<_>>();
                sql::JsonRow::from_strings(&columns)
            }
            Some(json_row) => json_row.clone(),
        };
        let mut row = Row::from(json_row);
        row.id = tx.get_next_id(table.name.as_str())?;
        row.order = NEW_ORDER_MULTIPLIER * row.id;
        row.change_id = table.change_id;
        tracing::debug!("Prepared a new row: {row:?}");
        Ok(row)
    }

    /// Convert the [text](Cell::text) values of all of the row's [cells](Row::cells) to
    /// strings and return them to the caller as a vector
    fn to_strings(&self) -> Vec<String> {
        tracing::trace!("Row::to_strings()");
        self.cells.values().map(|cell| cell.text.clone()).collect()
    }

    /// Generate an insert statement and a [JsonValue] representing an [Array](JsonValue::Array) of
    /// parameters that need to be bound to the statement before it is executed.
    fn as_insert(&self, table: &str, db_kind: &sql::DbKind) -> (String, JsonValue) {
        tracing::trace!("Row::as_insert({table:?})");
        let id = self.id;
        let order = self.order;
        let quoted_column_names = self
            .cells
            .keys()
            .map(|k| format!(r#""{k}""#))
            .collect::<Vec<_>>();

        let (value_placeholders, params) = {
            let mut value_placeholders = vec![];
            let mut params = vec![json!(id), json!(order)];
            for cell in self.cells.values() {
                if cell.value == JsonValue::Null {
                    value_placeholders.push("NULL".to_string());
                } else {
                    value_placeholders.push(sql::SqlParam::new(db_kind).next());
                    params.push(cell.value.clone());
                }
            }
            (value_placeholders, params)
        };

        let sql = if quoted_column_names.len() == 0 {
            format!(
                r#"INSERT INTO "{table}"
                   ("_id", "_order")
                   VALUES ({sql_params})"#,
                sql_params = sql::SqlParam::new(db_kind).get_as_list(2)
            )
        } else {
            format!(
                r#"INSERT INTO "{table}"
                   ("_id", "_order", {quoted_column_names})
                   VALUES ({sql_params}, {column_values})"#,
                quoted_column_names = quoted_column_names.join(", "),
                column_values = value_placeholders.join(", "),
                sql_params = sql::SqlParam::new(db_kind).get_as_list(2)
            )
        };
        (sql, json!(params))
    }
}

impl From<Row> for Vec<String> {
    /// Wrapper around [Row::to_strings()]
    fn from(row: Row) -> Self {
        tracing::trace!("Row::from({row:?})");
        row.to_strings()
    }
}

impl From<sql::JsonRow> for Row {
    fn from(row: sql::JsonRow) -> Self {
        tracing::trace!("Row::from({row:?})");
        let id = row
            .content
            .get("_id")
            .and_then(|i| i.as_u64())
            .unwrap_or_default() as usize;
        let order = row
            .content
            .get("_order")
            .and_then(|i| i.as_u64())
            .unwrap_or_default() as usize;
        let change_id = row
            .content
            .get("_change_id")
            .and_then(|i| i.as_u64())
            .unwrap_or_default() as usize;
        let cells = row
            .content
            .iter()
            // Ignore columns that start with "_"
            .filter(|(k, _)| !k.starts_with("_"))
            .map(|(k, v)| (k.clone(), v.into()))
            .collect();

        Self {
            id,
            order,
            change_id,
            cells,
        }
    }
}

/// Represents a column from some table
#[derive(Clone, Default, Debug, Serialize, Deserialize)]
pub struct Column {
    pub name: String,
    pub table: String,
    pub label: Option<String>,
    pub description: Option<String>,
    pub nulltype: Option<String>,
    pub primary_key: bool,
    pub unique: bool,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Table {
    pub name: String,
    /// The name of the view (blank if there is none) associated with the table
    pub view: String,
    /// The id of the most recent change to this table.
    pub change_id: usize,
    // We may eventually want to turn `columns` into a special-purpose struct, but for now a
    // simple IndexMap suffices.
    /// The table's column configuration, implemented as a map from column names to [Column]s.
    pub columns: IndexMap<String, Column>,
    pub editable: bool,
    /// Indicates whether the table has the _id and _order meta columns enabled:
    pub has_meta: bool,
}

impl Default for Table {
    fn default() -> Self {
        Self {
            name: "".into(),
            view: "".into(),
            change_id: 0,
            columns: IndexMap::new(),
            editable: true,
            has_meta: true,
        }
    }
}

impl Table {
    pub fn new(name: &str) -> Self {
        Self {
            // By default, view and table name are the same
            name: name.to_string(),
            view: name.to_string(),
            ..Default::default()
        }
    }

    /// Use the given [relatable](crate) instance to ensure that the default view for this
    /// table has been created, and to set the [view name](Table::view) for this table to
    /// TABLENAME_default_view
    pub async fn ensure_default_view_created(&mut self, rltbl: &Relatable) -> Result<Vec<Column>> {
        tracing::trace!("Table::ensure_view_created({rltbl:?})");
        let (columns, meta_columns) = rltbl.fetch_all_columns(&self.name).await?;
        self.view = format!("{}_default_view", self.name);
        tracing::debug!(r#"Creating view "{}" with columns {columns:?}"#, self.view);
        let id_col = match meta_columns.iter().any(|c| c.name == "_id") {
            false => r#"rowid"#, // This *must* be lowercase.
            true => r#"_id"#,
        };
        let order_col = match meta_columns.iter().any(|c| c.name == "_order") {
            false => r#"rowid"#, // This *must* be lowercase.
            true => r#"_order"#,
        };

        for sql in sql::generate_view_ddl(
            &self.name,
            &self.view,
            id_col,
            order_col,
            &columns,
            &rltbl.connection.kind(),
        ) {
            rltbl.connection.query(&sql, None).await?;
        }
        Ok(columns)
    }

    /// Retrieve the given attribute of the given column from this table's
    /// [column configuration](Table::columns)
    pub fn get_column_attribute(&self, column: &str, attribute: &str) -> Option<String> {
        tracing::trace!("Table::get_column_attribute({column:?}, {attribute:?})");
        self.columns.get(column).and_then(|col| match attribute {
            "table" => Some(col.table.to_string()),
            "column" => Some(col.name.to_string()),
            "label" => match &col.label {
                None => None,
                Some(label) if label == "" => None,
                Some(_) => col.label.clone(),
            },
            "description" => match &col.description {
                None => None,
                Some(description) if description == "" => None,
                Some(_) => col.description.clone(),
            },
            "nulltype" => match &col.nulltype {
                None => None,
                Some(nulltype) if nulltype == "" => None,
                Some(_) => col.nulltype.clone(),
            },
            _ => None,
        })
    }
}

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct Range {
    count: usize,
    total: usize,
    start: usize,
    end: usize,
}

impl std::fmt::Display for Range {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Rows {}-{} of {}", self.start, self.end, self.total)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ResultSet {
    pub select: Select,
    pub range: Range,
    pub table: Table,
    pub columns: Vec<Column>,
    pub rows: Vec<Row>,
}

impl std::fmt::Display for ResultSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut tw = TabWriter::new(vec![]);
        tw.write(format!("{}\n", self.range).as_bytes())
            .unwrap_or_default();
        let header = &self
            .columns
            .iter()
            .map(|c| c.name.clone())
            .collect::<Vec<String>>();
        tw.write(format!("{}\n", header.join("\t")).as_bytes())
            .unwrap_or_default();
        for row in &self.rows {
            tw.write(format!("{}\n", row.to_strings().join("\t")).as_bytes())
                .unwrap_or_default();
        }
        tw.flush().expect("TabWriter to flush");
        let written = String::from_utf8(tw.into_inner().unwrap()).unwrap();
        write!(f, "{written}")
    }
}

// Selects and Filters

pub type QueryParams = IndexMap<String, String>;

pub enum Format {
    Html,
    Json,
    PrettyJson,
    Default,
}

impl Display for Format {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        // TODO: This should be factored out.
        let result = match self {
            Format::Html => ".html",
            Format::Json => ".json",
            Format::PrettyJson => ".pretty.json",
            Format::Default => "",
        };
        write!(f, "{result}")
    }
}

impl TryFrom<&String> for Format {
    fn try_from(path: &String) -> Result<Self> {
        tracing::trace!("Format::try_from({path:?})");
        let path = path.to_lowercase();
        let format = if path.ends_with(".pretty.json") {
            Format::PrettyJson
        } else if path.ends_with(".json") {
            Format::Json
        } else if path.ends_with(".html") || path.ends_with(".htm") {
            Format::Html
        } else if path.contains(".") {
            return Err(
                RelatableError::FormatError(format!("Unknown format for path {path}")).into(),
            );
        } else {
            Format::Default
        };
        Ok(format)
    }

    type Error = anyhow::Error;
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum Filter {
    // TODO: Add a `table` field to all of these.
    Like { column: String, value: JsonValue },
    Equal { column: String, value: JsonValue },
    NotEqual { column: String, value: JsonValue },
    GreaterThan { column: String, value: JsonValue },
    GreaterThanOrEqual { column: String, value: JsonValue },
    LessThan { column: String, value: JsonValue },
    LessThanOrEqual { column: String, value: JsonValue },
    Is { column: String, value: JsonValue },
    IsNot { column: String, value: JsonValue },
    In { column: String, value: JsonValue },
    NotIn { column: String, value: JsonValue },
}

fn render_in_not_in<S: Into<String>>(
    lhs: S,
    options: &Vec<JsonValue>,
    positive: bool,
) -> Result<String> {
    tracing::trace!("render_in_not_in(lhs, {options:?}, {positive:?})");
    let negation;
    if !positive {
        negation = " NOT";
    } else {
        negation = "";
    }

    let mut values = vec![];
    let mut is_string_list = false;
    for (i, option) in options.iter().enumerate() {
        match option {
            JsonValue::String(s) => {
                if i == 0 {
                    is_string_list = true;
                } else if !is_string_list {
                    return Err(RelatableError::InputError(format!(
                        "{:?} contains both text and numeric types.",
                        options
                    ))
                    .into());
                }
                let value = unquote(s).unwrap_or(s.clone());
                values.push(format!("'{value}'"))
            }
            JsonValue::Number(n) => {
                if i == 0 {
                    is_string_list = false;
                } else if is_string_list {
                    return Err(RelatableError::InputError(format!(
                        "{:?} contains both text and numeric types.",
                        options
                    ))
                    .into());
                }
                values.push(format!("{n}"))
            }
            _ => {
                return Err(RelatableError::InputError(format!(
                    "{:?} is not an array of strings or numbers.",
                    options
                ))
                .into())
            }
        };
    }
    let value_list = format!("({})", values.join(", "));
    let filter_sql = format!("{}{} IN {}", lhs.into(), negation, value_list);
    Ok(filter_sql)
}

impl Filter {
    pub fn parts(&self) -> (String, String, JsonValue) {
        tracing::trace!("Filter::parts()");
        let (column, operator, value) = match self {
            Filter::Like { column, value } => (column, "like", value),
            Filter::Equal { column, value } => (column, "eq", value),
            Filter::NotEqual { column, value } => (column, "not_eq", value),
            Filter::GreaterThan { column, value } => (column, "gt", value),
            Filter::GreaterThanOrEqual { column, value } => (column, "gte", value),
            Filter::LessThan { column, value } => (column, "lt", value),
            Filter::LessThanOrEqual { column, value } => (column, "lte", value),
            Filter::Is { column, value } => (column, "is", value),
            Filter::IsNot { column, value } => (column, "is_not", value),
            Filter::In { column, value } => (column, "in", value),
            Filter::NotIn { column, value } => (column, "not_in", value),
        };
        (column.to_string(), operator.to_string(), json!(value))
    }

    pub fn to_url(&self) -> Result<String> {
        tracing::trace!("Filter::to_url()");
        fn handle_string_value(token: &str) -> String {
            let reserved = vec![':', ',', '.', '(', ')'];
            if token.chars().all(char::is_numeric) || reserved.iter().any(|&c| token.contains(c)) {
                format!("\"{}\"", token)
            } else {
                token.to_string()
            }
        }

        let (_, operator, value) = self.parts();

        let rhs = match &value {
            JsonValue::String(s) => handle_string_value(&s),
            JsonValue::Number(n) => format!("{}", n),
            JsonValue::Array(v) => {
                let mut list = vec![];
                for item in v {
                    match item {
                        JsonValue::String(s) => {
                            list.push(handle_string_value(&s));
                        }
                        JsonValue::Number(n) => list.push(n.to_string()),
                        _ => {
                            return Err(RelatableError::DataError(format!(
                                "Not all list items in {:?} are strings or numbers.",
                                v
                            ))
                            .into());
                        }
                    };
                }
                format!("({})", list.join(","))
            }
            _ => {
                return Err(RelatableError::DataError(format!(
                    "RHS of Filter: {:?} is not a string, number, or list",
                    self
                ))
                .into());
            }
        };

        Ok(format!("{operator}.{rhs}"))
    }

    pub fn to_sql(&self, kind: &sql::DbKind) -> Result<String> {
        tracing::trace!("Filter::to_sqlite()");
        let as_string = |value: &JsonValue| -> String {
            match value {
                JsonValue::Null => "NULL".to_string(),
                JsonValue::Bool(value) => value.to_string(),
                JsonValue::Number(value) => value.to_string(),
                JsonValue::String(value) => format!("'{value}'"),
                JsonValue::Array(value) => format!("'{value:?}'"),
                JsonValue::Object(value) => format!("'{value:?}'"),
            }
        };
        match self {
            Filter::Like { column, value } => {
                let value = as_string(&value);
                let value = value.replace("*", "%");
                Ok(format!(r#""{column}" LIKE {value}"#))
            }
            Filter::Equal { column, value } => {
                let value = as_string(&value);
                Ok(format!(r#""{column}" = {value}"#))
            }
            Filter::NotEqual { column, value } => {
                let value = as_string(&value);
                Ok(format!(r#""{column}" <> {value}"#))
            }
            Filter::GreaterThan { column, value } => {
                let value = as_string(&value);
                Ok(format!(r#""{column}" > {value}"#))
            }
            Filter::GreaterThanOrEqual { column, value } => {
                let value = as_string(&value);
                Ok(format!(r#""{column}" >= {value}"#))
            }
            Filter::LessThan { column, value } => {
                let value = as_string(&value);
                Ok(format!(r#""{column}" < {value}"#))
            }
            Filter::LessThanOrEqual { column, value } => {
                let value = as_string(&value);
                Ok(format!(r#""{column}" <= {value}"#))
            }
            Filter::Is { column, value } => {
                // Note that we are presupposing SQLite syntax which is not universal for IS:
                let value = as_string(&value);
                Ok(format!(
                    r#""{column}" {is} {value}"#,
                    is = sql::is_clause(kind)
                ))
            }
            Filter::IsNot { column, value } => {
                // Note that we are presupposing SQLite syntax which is not universal for IS:
                let value = as_string(&value);
                Ok(format!(
                    r#""{column}" {is_not} {value}"#,
                    is_not = sql::is_not_clause(kind)
                ))
            }
            Filter::In { column, value } => {
                if let JsonValue::Array(values) = value {
                    let filter_str = match render_in_not_in(column, values, true) {
                        Err(e) => {
                            return Err(RelatableError::DataError(format!(
                                "Error rendering 'in' filter: {e}"
                            ))
                            .into());
                        }
                        Ok(filter_str) => filter_str,
                    };
                    Ok(format!("{filter_str}"))
                } else {
                    Err(RelatableError::DataError(format!("Invalid 'in' value: {value}")).into())
                }
            }
            Filter::NotIn { column, value } => {
                if let JsonValue::Array(values) = value {
                    let filter_str = match render_in_not_in(column, values, false) {
                        Err(e) => {
                            return Err(RelatableError::DataError(format!(
                                "Error rendering 'not in' filter: {e}"
                            ))
                            .into());
                        }
                        Ok(filter_str) => filter_str,
                    };
                    Ok(format!("{filter_str}"))
                } else {
                    Err(
                        RelatableError::DataError(format!("Invalid 'not in' value: {value}"))
                            .into(),
                    )
                }
            }
        }
    }
}

/// Represents a SELECT statement.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Select {
    pub table_name: String,
    pub view_name: String,
    pub limit: usize,
    pub offset: usize,
    pub filters: Vec<Filter>,
    pub order_by: Vec<(String, Order)>,
}

impl Default for Select {
    fn default() -> Self {
        let table_name = "";
        Self {
            // By default, the view name and table name are the same.
            table_name: table_name.to_string(),
            view_name: table_name.to_string(),
            limit: usize::default(),
            offset: usize::default(),
            filters: Vec::default(),
            order_by: Vec::default(),
        }
    }
}

/// Represents an ORDER BY clause in a SELECT statement.
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub enum Order {
    #[default]
    ASC,
    DESC,
}

impl Select {
    /// Construct a [Select] for the given [relatable](crate) instance from the given path and
    /// query parameters.
    pub fn from_path_and_query(rltbl: &Relatable, path: &str, query_params: &QueryParams) -> Self {
        tracing::trace!("Select::from_path_and_query({rltbl:?}, {path:?}, {query_params:?})");
        let table_name = path.split(".").next().unwrap_or_default();
        let mut query_params = query_params.clone();
        let mut filters = Vec::new();
        let mut order_by = Vec::new();

        let limit: usize = query_params
            .get("limit")
            .and_then(|x| x.parse::<usize>().ok())
            .unwrap_or(rltbl.default_limit)
            .min(rltbl.max_limit);
        let offset: usize = query_params
            .get("offset")
            .and_then(|x| x.parse::<usize>().ok())
            .unwrap_or_default();
        if let Some(order) = query_params.get("order") {
            for item in order.split(",") {
                if item.ends_with(".asc") {
                    let column = item.replace(".asc", "");
                    order_by.push((column, Order::ASC));
                } else if item.ends_with(".desc") {
                    let column = item.replace(".desc", "");
                    order_by.push((column, Order::DESC));
                } else {
                    order_by.push((item.to_string(), Order::ASC));
                }
            }
        }

        query_params.shift_remove("limit");
        query_params.shift_remove("offset");
        query_params.shift_remove("order");

        for (column, pattern) in query_params {
            if pattern.starts_with("like.") {
                let column = column.to_string();
                let value = &pattern.replace("like.", "");
                match serde_json::from_str(value) {
                    Ok(value) => filters.push(Filter::Like { column, value }),
                    Err(_) => filters.push(Filter::Like {
                        column,
                        value: JsonValue::String(value.to_string()),
                    }),
                }
            } else if pattern.starts_with("eq.") {
                let column = column.to_string();
                let value = &pattern.replace("eq.", "");
                match serde_json::from_str(value) {
                    Ok(value) => filters.push(Filter::Equal { column, value }),
                    Err(_) => filters.push(Filter::Equal {
                        column,
                        value: JsonValue::String(value.to_string()),
                    }),
                }
            } else if pattern.starts_with("not_eq.") {
                let column = column.to_string();
                let value = &pattern.replace("not_eq.", "");
                match serde_json::from_str(value) {
                    Ok(value) => filters.push(Filter::NotEqual { column, value }),
                    Err(_) => filters.push(Filter::NotEqual {
                        column,
                        value: JsonValue::String(value.to_string()),
                    }),
                }
            } else if pattern.starts_with("gt.") {
                let column = column.to_string();
                let value = &pattern.replace("gt.", "");
                match serde_json::from_str(value) {
                    Ok(value) => filters.push(Filter::GreaterThan { column, value }),
                    Err(_) => filters.push(Filter::GreaterThan {
                        column,
                        value: JsonValue::String(value.to_string()),
                    }),
                }
            } else if pattern.starts_with("gte.") {
                let column = column.to_string();
                let value = &pattern.replace("gte.", "");
                match serde_json::from_str(value) {
                    Ok(value) => filters.push(Filter::GreaterThanOrEqual { column, value }),
                    Err(_) => filters.push(Filter::GreaterThanOrEqual {
                        column,
                        value: JsonValue::String(value.to_string()),
                    }),
                }
            } else if pattern.starts_with("lt.") {
                let column = column.to_string();
                let value = &pattern.replace("lt.", "");
                match serde_json::from_str(value) {
                    Ok(value) => filters.push(Filter::LessThan { column, value }),
                    Err(_) => filters.push(Filter::LessThan {
                        column,
                        value: JsonValue::String(value.to_string()),
                    }),
                }
            } else if pattern.starts_with("lte.") {
                let column = column.to_string();
                let value = &pattern.replace("lte.", "");
                match serde_json::from_str(value) {
                    Ok(value) => filters.push(Filter::LessThanOrEqual { column, value }),
                    Err(_) => filters.push(Filter::LessThanOrEqual {
                        column,
                        value: JsonValue::String(value.to_string()),
                    }),
                }
            } else if pattern.starts_with("is.") {
                let column = column.to_string();
                let value = pattern.replace("is.", "");
                match value.to_lowercase().as_str() {
                    "null" => filters.push(Filter::Is {
                        column,
                        value: JsonValue::Null,
                    }),
                    _ => match serde_json::from_str(&value) {
                        Ok(value) => filters.push(Filter::Is { column, value }),
                        Err(_) => tracing::warn!("invalid 'is' filter value {pattern}"),
                    },
                };
            } else if pattern.starts_with("is_not.") {
                let column = column.to_string();
                let value = pattern.replace("is_not.", "");
                match value.to_lowercase().as_str() {
                    "null" => filters.push(Filter::IsNot {
                        column,
                        value: JsonValue::Null,
                    }),
                    _ => match serde_json::from_str(&value) {
                        Ok(value) => filters.push(Filter::IsNot { column, value }),
                        Err(_) => tracing::warn!("invalid 'is_not' filter value {pattern}"),
                    },
                };
            } else if pattern.starts_with("in.") {
                let column = column.to_string();
                let separator = Regex::new(r"\s*,\s*").unwrap();
                let values = pattern.replace("in.", "");
                let values = match values.strip_prefix("(").and_then(|s| s.strip_suffix(")")) {
                    None => {
                        tracing::warn!("invalid 'in' filter value {pattern}");
                        ""
                    }
                    Some(s) => s,
                };
                let values = separator
                    .split(values)
                    .map(|v| serde_json::from_str::<JsonValue>(v).unwrap_or(json!(v.to_string())))
                    .collect::<Vec<_>>();
                filters.push(Filter::In {
                    column,
                    value: json!(values),
                })
            } else if pattern.starts_with("not_in.") {
                let column = column.to_string();
                let separator = Regex::new(r"\s*,\s*").unwrap();
                let values = pattern.replace("not_in.", "");
                let values = match values.strip_prefix("(").and_then(|s| s.strip_suffix(")")) {
                    None => {
                        tracing::warn!("invalid 'not_in' filter value {pattern}");
                        ""
                    }
                    Some(s) => s,
                };
                let values = separator
                    .split(values)
                    .map(|v| serde_json::from_str::<JsonValue>(v).unwrap_or(json!(v.to_string())))
                    .collect::<Vec<_>>();
                filters.push(Filter::NotIn {
                    column,
                    value: json!(values),
                })
            }
        }
        Self {
            table_name: table_name.to_string(),
            view_name: format!("{table_name}_default_view"),
            limit,
            offset,
            order_by,
            filters,
            ..Default::default()
        }
    }

    /// Order (ascending) this select by the given column
    pub fn order_by(mut self, column: &str) -> Self {
        tracing::trace!("Select::order_by({column:?})");
        self.order_by = vec![(column.to_string(), Order::ASC)];
        self
    }

    /// Limit the results by a given amount
    pub fn limit(mut self, limit: &usize) -> Self {
        tracing::trace!("Select::limit({limit})");
        self.limit = *limit;
        self
    }

    /// Offset the results by a given amount
    pub fn offset(mut self, offset: &usize) -> Self {
        tracing::trace!("Select::offset({offset})");
        self.offset = *offset;
        self
    }

    /// Add the given filters to the select.
    pub fn filters(mut self, filters: &Vec<String>) -> Result<Self> {
        tracing::trace!("Select::filters({filters:?})");
        let basic = r"[\w\-]";
        let wildcarded = r"[\w\-%]";

        // Symbolic operators:
        let like = Regex::new(&format!(r#"^({basic}+)\s*~=\s*"?({wildcarded}+)"?$"#)).unwrap();
        let eq = Regex::new(&format!(r#"^({basic}+)\s*=\s*"?({basic}+)"?$"#)).unwrap();
        let not_eq = Regex::new(&format!(r#"^({basic}+)\s*!=\s*"?({basic}+)"?$"#)).unwrap();
        let gt = Regex::new(&format!(r"^({basic}+)\s*>\s*({basic}+)$")).unwrap();
        let gte = Regex::new(&format!(r"^({basic}+)\s*>=\s*({basic}+)$")).unwrap();
        let lt = Regex::new(&format!(r"^({basic}+)\s*<\s*({basic}+)$")).unwrap();
        let lte = Regex::new(&format!(r"^({basic}+)\s*<=\s*({basic}+)$")).unwrap();

        // Word-like operators:
        let is = Regex::new(&format!(r#"^({basic}+)\s+(IS|is)\s+"?({basic}+)"?$"#)).unwrap();
        let is_not = Regex::new(&format!(
            r#"^({basic}+)\s+(IS NOT|is not)\s+"?({basic}+)"?$"#
        ))
        .unwrap();
        let is_in = Regex::new(&format!(
            r#"^({basic}+)\s+(IN|in)\s+\(({basic}+(,\s*{basic}+)*)\)$"#
        ))
        .unwrap();
        let is_not_in = Regex::new(&format!(
            r#"^({basic}+)\s+(NOT IN|not in)\s+\(({basic}+(,\s*{basic}+)*)\)$"#
        ))
        .unwrap();

        // Closure used for text types:
        let maybe_quote_value = |value: &str| -> Result<JsonValue> {
            if value.starts_with("\"") {
                let value = serde_json::from_str(&value)?;
                Ok(value)
            } else {
                let value = serde_json::from_str(&format!(r#""{value}""#))?;
                Ok(value)
            }
        };
        for filter in filters {
            tracing::trace!("Applying filter: {filter}");
            if like.is_match(&filter) {
                let captures = like.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = maybe_quote_value(&value)?;
                self.filters.push(Filter::Like { column, value });
            } else if eq.is_match(&filter) {
                let captures = eq.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = maybe_quote_value(&value)?;
                self.filters.push(Filter::Equal { column, value });
            } else if not_eq.is_match(&filter) {
                let captures = not_eq.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = maybe_quote_value(&value)?;
                self.filters.push(Filter::NotEqual { column, value });
            } else if gt.is_match(&filter) {
                let captures = gt.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = maybe_quote_value(&value)?;
                self.filters.push(Filter::GreaterThan { column, value });
            } else if gte.is_match(&filter) {
                let captures = gte.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = maybe_quote_value(value)?;
                self.filters
                    .push(Filter::GreaterThanOrEqual { column, value });
            } else if lt.is_match(&filter) {
                let captures = lt.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = maybe_quote_value(&value)?;
                self.filters.push(Filter::LessThan { column, value });
            } else if lte.is_match(&filter) {
                let captures = lte.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = maybe_quote_value(&value)?;
                self.filters.push(Filter::LessThanOrEqual { column, value });
            } else if is.is_match(&filter) {
                let captures = is.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(3).unwrap().as_str();
                let value = match value.to_lowercase().as_str() {
                    "null" => JsonValue::Null,
                    _ => maybe_quote_value(&value)?,
                };
                self.filters.push(Filter::Is { column, value });
            } else if is_not.is_match(&filter) {
                let captures = is_not.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(3).unwrap().as_str();
                let value = match value.to_lowercase().as_str() {
                    "null" => JsonValue::Null,
                    _ => maybe_quote_value(&value)?,
                };
                self.filters.push(Filter::IsNot { column, value });
            } else if is_in.is_match(&filter) {
                let captures = is_in.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let values = &captures.get(3).unwrap().as_str();
                let separator = Regex::new(r"\s*,\s*").unwrap();
                let values = separator
                    .split(values)
                    .map(|v| serde_json::from_str::<JsonValue>(v).unwrap_or(json!(v.to_string())))
                    .collect::<Vec<_>>();
                self.filters.push(Filter::In {
                    column,
                    value: json!(values),
                });
            } else if is_not_in.is_match(&filter) {
                let captures = is_not_in.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let values = &captures.get(3).unwrap().as_str();
                let separator = Regex::new(r"\s*,\s*").unwrap();
                let values = separator
                    .split(values)
                    .map(|v| serde_json::from_str::<JsonValue>(v).unwrap_or(json!(v.to_string())))
                    .collect::<Vec<_>>();
                self.filters.push(Filter::NotIn {
                    column,
                    value: json!(values),
                });
            } else {
                return Err(RelatableError::ConfigError(format!("invalid filter {filter}")).into());
            }
        }
        Ok(self)
    }

    /// Add a like filter for the given column on the given value, which may include '%' wildcards
    pub fn like<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        tracing::trace!("Select::like({column:?}, value)");
        self.filters.push(Filter::Like {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    /// Add an equals filter on the given column and value.
    pub fn eq<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        tracing::trace!("Select::eq({column:?}, value)");
        self.filters.push(Filter::Equal {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    /// Add a not-equals filter on the given column and value.
    pub fn not_eq<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        tracing::trace!("Select::not_eq({column:?}, value)");
        self.filters.push(Filter::NotEqual {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    /// Add an greater-than filter on the given column and value.
    pub fn gt<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        tracing::trace!("Select::gt({column:?}, value)");
        self.filters.push(Filter::GreaterThan {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    /// Add an greater-than-or-equals filter on the given column and value.
    pub fn gte<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        tracing::trace!("Select::gte({column:?}, value)");
        self.filters.push(Filter::GreaterThanOrEqual {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    /// Add an less-than filter on the given column and value.
    pub fn lt<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        tracing::trace!("Select::lt({column:?}, value)");
        self.filters.push(Filter::LessThan {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    /// Add an less-than-or-equals filter on the given column and value.
    pub fn lte<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        tracing::trace!("Select::lte({column:?}, value)");
        self.filters.push(Filter::LessThanOrEqual {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    /// Add an is filter on the given column and value.
    pub fn is<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        tracing::trace!("Select::is({column:?}, value)");
        self.filters.push(Filter::Is {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    /// Add an is not filter on the given column and value.
    pub fn is_not<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        tracing::trace!("Select::is_not({column:?}, value)");
        self.filters.push(Filter::IsNot {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    /// Add an in filter on the given column and value.
    pub fn is_in<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        tracing::trace!("Select::is_in({column:?}, value)");
        self.filters.push(Filter::In {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    /// Add a not in filter on the given column and value.
    pub fn is_not_in<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        tracing::trace!("Select::is_not_in({column:?}, value)");
        self.filters.push(Filter::NotIn {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    /// Convert the filter to a tuple consisting of an SQL string supported by the given database
    /// kind, and a vector of parameters that must be bound to the string before executing it.
    pub fn to_sql(&self, kind: &sql::DbKind) -> Result<(String, Vec<JsonValue>)> {
        tracing::trace!("Select::to_sql({self:?})");
        let mut lines = Vec::new();
        let mut params = Vec::new();
        lines.push("SELECT *,".to_string());
        // WARN: The _total count should probably be optional.
        lines.push("  COUNT(1) OVER() AS _total, ".to_string());
        lines.push(format!(
            r#"(SELECT MAX(change_id) FROM history
                  WHERE "table" = {sql_param}
                    AND "row" = _id
               ) AS _change_id"#,
            sql_param = sql::SqlParam::new(kind).next()
        ));
        params.push(json!(self.table_name)); // the real table name
        lines.push(format!(r#"FROM "{}""#, self.view_name)); // the view name, which may differ
        for (i, filter) in self.filters.iter().enumerate() {
            let keyword = if i == 0 { "WHERE" } else { "  AND" };
            lines.push(format!("{keyword} {filter}", filter = filter.to_sql(kind)?));
        }
        if self.order_by.len() == 0 {
            lines.push(format!("ORDER BY _order ASC"));
        }
        for (column, order) in &self.order_by {
            lines.push(format!(r#"ORDER BY "{column}" {order:?}"#));
        }
        if self.limit > 0 {
            lines.push(format!("LIMIT {}", self.limit));
        }
        if self.offset > 0 {
            lines.push(format!("OFFSET {}", self.offset));
        }
        Ok((lines.join("\n"), params))
    }

    /// Converts this select's filters to a map from column names to URL representations of their
    /// associated filters represented as [JsonValue]s
    pub fn to_params(&self) -> Result<JsonMap<String, JsonValue>> {
        tracing::trace!("Select::to_params()");
        if self.table_name.is_empty() {
            return Err(RelatableError::InputError(
                "Missing required field: `table` in to_sql()".to_string(),
            )
            .into());
        }

        let mut params = JsonMap::new();
        if self.filters.len() > 0 {
            for filter in &self.filters {
                let column = match &filter {
                    Filter::Like { column, value: _ }
                    | Filter::Equal { column, value: _ }
                    | Filter::NotEqual { column, value: _ }
                    | Filter::GreaterThan { column, value: _ }
                    | Filter::GreaterThanOrEqual { column, value: _ }
                    | Filter::LessThan { column, value: _ }
                    | Filter::LessThanOrEqual { column, value: _ }
                    | Filter::Is { column, value: _ }
                    | Filter::IsNot { column, value: _ }
                    | Filter::In { column, value: _ }
                    | Filter::NotIn { column, value: _ } => column,
                };

                let column = unquote(&column).unwrap_or(column.to_string());
                if let Err(e) = sql::is_simple(&column) {
                    return Err(RelatableError::InputError(format!(
                        "While reading filters, got error: {}",
                        e
                    ))
                    .into());
                }
                params.insert(column, format!("{}", filter.to_url()?).into());
            }
        }
        if self.limit > 0 {
            params.insert("limit".into(), self.limit.into());
        }
        if self.offset > 0 {
            params.insert("offset".into(), self.offset.into());
        }
        Ok(params)
    }

    /// Convert the select to a URL
    pub fn to_url(&self, base: &str, format: &Format) -> Result<String> {
        tracing::trace!("Select::to_url({base:?}, format)");
        let table_name = unquote(&self.table_name).unwrap_or(self.table_name.to_string());
        if let Err(e) = sql::is_simple(&table_name) {
            return Err(RelatableError::InputError(format!(
                "While reading table name, got error: {}",
                e
            ))
            .into());
        }
        let table_name = format!("{base}/{table_name}{format}");

        let params = &self.to_params()?.clone();
        if params.len() > 0 {
            let mut parts = vec![];
            for (column, value) in params.iter() {
                let s = match value {
                    serde_json::Value::String(s) => s.as_str().into(),
                    _ => format!("{}", value),
                };
                parts.push(format!("{column}={s}"));
            }
            Ok(format!("{}?{}", table_name, parts.join("&")))
        } else {
            Ok(table_name.to_string())
        }
    }
}

// Web Site Stuff

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Site {
    title: String,
    root: String,
    editable: bool,
    user: Account,
    users: IndexMap<String, UserCursor>,
    tables: IndexMap<String, Table>,
}

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct Account {
    name: String,
    color: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Cursor {
    table: String,
    row: usize,
    column: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct UserCursor {
    name: String,
    color: String,
    cursor: Cursor,
    datetime: String,
}
