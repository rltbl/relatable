//! # rltbl/relatable
//!
//! This is relatable (rltbl::core).

use crate as rltbl;
use rltbl::{
    git,
    sql::{
        is_simple, json_to_string, DbActiveConnection, DbConnection, DbTransaction, JsonRow,
        VecInto,
    },
};

use anyhow::Result;
use csv::{QuoteStyle, ReaderBuilder, WriterBuilder};
use enquote::unquote;
use indexmap::IndexMap;
use minijinja::{path_loader, Environment};
use regex::Regex;
use serde::{Deserialize, Serialize};
use serde_json::{from_str, json, to_value, Map as JsonMap, Value as JsonValue};
use std::{env, fmt::Display, fs::File, io::Write, path::Path as FilePath, str::FromStr};
use tabwriter::TabWriter;

pub static RLTBL_DEFAULT_DB: &str = ".relatable/relatable.db";

#[derive(Debug)]
pub enum RelatableError {
    /// An error in the configuration of a ChangeSet:
    ChangeError(String),
    /// An error in the Relatable configuration:
    ConfigError(String),
    /// An error that occurred while reading or writing to a CSV/TSV:
    // CsvError(csv::Error),
    /// An error involving the data:
    DataError(String),
    /// An error generated by the underlying database:
    // DatabaseError(sqlx::Error),

    /// An error that occurred while interacting with git
    GitError(String),
    /// An error generated when the database is missing
    InitError(String),
    /// An error from an unsupported format
    FormatError(String),
    /// An error in the inputs to a function:
    InputError(String),
    /// An error that occurred while reading/writing to stdio:
    IOError(std::io::Error),
    /// An error when a record cannot be found.
    MissingError(String),
    /// An error that occurred while serialising or deserialising to/from JSON:
    SerdeJsonError(serde_json::Error),
    /// An error that occurred while parsing a regex:
    RegexError(regex::Error),
    /// An error when a table cannot be found.
    TableError(String),
    /// An error that occurred because of a user's action
    UserError(String),
}

impl std::fmt::Display for RelatableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

static MOVE_INTERVAL: usize = 1000;

impl std::error::Error for RelatableError {}

#[derive(Debug)]
pub struct Relatable {
    pub root: String,
    pub readonly: bool,
    pub connection: DbConnection,
    // pub minijinja: Environment<'static>,
    pub default_limit: usize,
    pub max_limit: usize,
}

impl Relatable {
    pub async fn connect(path: Option<&str>) -> Result<Self> {
        let root = std::env::var("RLTBL_ROOT").unwrap_or_default();
        // Set up database connection.
        let readonly = match std::env::var("RLTBL_READONLY") {
            Ok(value) if value.to_lowercase() != "false" => true,
            _ => false,
        };
        let path = match path {
            None => RLTBL_DEFAULT_DB,
            Some(path) => path,
        };
        let file = FilePath::new(path);
        if !file.exists() {
            return Err(RelatableError::InitError(
                "First create a database with `rltbl init`".into(),
            )
            .into());
        }
        let (connection, _) = DbConnection::connect(path).await?;
        Ok(Self {
            root,
            readonly,
            connection,
            // minijinja: env,
            default_limit: 100,
            max_limit: 1000,
        })
    }

    pub async fn init(force: &bool, path: Option<&str>) -> Result<Self> {
        let path = match path {
            None => RLTBL_DEFAULT_DB,
            Some(path) => path,
        };
        let dir = FilePath::new(path)
            .parent()
            .expect("parent should be defined");
        if !dir.exists() {
            std::fs::create_dir_all(&dir).unwrap();
            tracing::info!("Created '{dir:?}' directory");
        }
        let file = FilePath::new(path);
        if file.exists() {
            if *force {
                std::fs::remove_file(&file).unwrap();
                tracing::info!("Removed '{file:?}' file");
            } else {
                return Err(RelatableError::InitError(format!(
                    "File {file:?} already exists. Use --force to overwrite"
                ))
                .into());
            }
        }
        File::create(path)?;

        let rltbl = Relatable::connect(None).await?;

        // Create and populate the table table
        let sql = r#"CREATE TABLE "table" (
          _id INTEGER PRIMARY KEY,
          _order INTEGER UNIQUE,
          "table" TEXT UNIQUE,
          "path" TEXT
        )"#;
        rltbl.connection.query(sql, None).await.unwrap();

        let sql = format!(
            r#"CREATE TRIGGER "table_order"
                 AFTER INSERT ON "table"
                 WHEN NEW._order IS NULL
                 BEGIN
                   UPDATE "table" SET _order = ({MOVE_INTERVAL} * NEW._id)
                   WHERE _id = NEW._id;
                 END"#
        );
        rltbl.connection.query(&sql, None).await.unwrap();

        // TODO: Decide whether to include the 'table' table by default.
        // let sql = "INSERT INTO 'table' ('table') VALUES ('table')";
        // query(&rltbl.connection, sql, None).await.unwrap();

        // Create the change and history tables
        let sql = r#"CREATE TABLE "user" (
          "name" TEXT PRIMARY KEY,
          "color" TEXT,
          "cursor" TEXT,
          "datetime" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )"#;
        rltbl.connection.query(sql, None).await.unwrap();

        // Create the change and history tables
        let sql = r#"CREATE TABLE "change" (
          change_id INTEGER PRIMARY KEY,
          "datetime" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          "user" TEXT NOT NULL,
          "action" TEXT NOT NULL,
          "table" TEXT NOT NULL,
          "description" TEXT,
          "content" TEXT,
          FOREIGN KEY ("user") REFERENCES user("name")
        )"#;
        rltbl.connection.query(sql, None).await.unwrap();

        let sql = r#"CREATE TABLE "history" (
          history_id INTEGER PRIMARY KEY,
          change_id INTEGER NOT NULL,
          "table" TEXT NOT NULL,
          "row" INTEGER NOT NULL,
          "before" TEXT,
          "after" TEXT,
          FOREIGN KEY ("change_id") REFERENCES change("change_id"),
          FOREIGN KEY ("table") REFERENCES "table"("table")
        )"#;
        rltbl.connection.query(sql, None).await.unwrap();

        Ok(rltbl)
    }

    pub fn render<T: Serialize>(&self, template: &str, context: T) -> Result<String> {
        // TODO: Optionally we should set up the environment once and store it,
        // but during development it's very convenient to rebuild every time.
        let mut env = Environment::new();

        // Load default template strings at compile time.
        let templates = IndexMap::from([
            ("page.html", include_str!("templates/page.html")),
            ("table.html", include_str!("templates/table.html")),
            ("row_menu.html", include_str!("templates/row_menu.html")),
            (
                "column_menu.html",
                include_str!("templates/column_menu.html"),
            ),
            ("cell_menu.html", include_str!("templates/cell_menu.html")),
        ]);

        // Load templates dynamically if src/templates/ exists,
        // otherwise use strings from compile time.
        // TODO: This should be a configuration option.
        let dir = "src/templates/";
        if FilePath::new(dir).is_dir() {
            env.set_loader(path_loader(dir));
        };
        for (name, content) in templates {
            match env.get_template(name) {
                Ok(_) => (),
                Err(_) => env.add_template(name, content).unwrap(),
            }
        }

        env.get_template(template)?
            .render(context)
            .map_err(|e| e.into())
    }

    pub fn from(&self, table_name: &str) -> Select {
        Select {
            table_name: table_name.to_string(),
            view_name: table_name.to_string(),
            limit: self.default_limit,
            ..Default::default()
        }
    }

    pub async fn fetch_columns(&self, table_name: &str) -> Result<Vec<Column>> {
        // WARN: SQLite only!
        let statement =
            format!(r#"SELECT "name" FROM pragma_table_info("{table_name}") ORDER BY "cid""#);
        let columns = {
            let columns = self.connection.query(&statement, None).await?;
            if columns.is_empty() {
                return Err(RelatableError::DataError(format!(
                    "No defined columns for: {table_name}"
                ))
                .into());
            }
            columns
                .iter()
                .map(|c| c.get_string("name").expect("No 'name' found"))
                .filter(|c| !c.starts_with("_"))
                .map(|c| Column {
                    name: c.to_string(),
                })
                .collect()
        };
        Ok(columns)
    }

    pub async fn fetch(&self, select: &Select) -> Result<ResultSet> {
        let table = self.get_table(select.table_name.as_str()).await?;
        let mut select = select.clone();
        select.view_name = table.view.clone();
        let columns = self.fetch_columns(&table.view).await?;
        let (statement, params) = select.to_sqlite()?;
        tracing::debug!("SQL {statement}");
        let params = json!(params);
        let json_rows = self.connection.query(&statement, Some(&params)).await?;

        let count = json_rows.len();
        let total = match json_rows.get(0) {
            Some(row) => row
                .content
                .get("_total")
                .and_then(|x| x.as_u64())
                .unwrap_or(0) as usize,
            None => 0,
        };

        let rows: Vec<Row> = json_rows.vec_into();
        Ok(ResultSet {
            range: Range {
                count,
                total,
                start: select.offset + 1,
                end: select.offset + count,
            },
            select: select.clone(),
            table,
            columns,
            rows,
        })
    }

    pub async fn fetch_json_rows(&self, select: &Select) -> Result<Vec<JsonRow>> {
        let (statement, params) = select.to_sqlite()?;
        let params = json!(params);
        self.connection.query(&statement, Some(&params)).await
    }

    pub async fn load_table(&self, table: &str, path: &str) -> Result<()> {
        // Read the records from the given path:
        let mut rdr = ReaderBuilder::new()
            .has_headers(false)
            .delimiter(b'\t')
            .from_reader(File::open(path).map_err(|err| {
                RelatableError::InputError(format!("Unable to open '{path}': {err}"))
            })?);
        let mut records = rdr.records();

        // Extract the headers from the first line of the file, which we will need for the create
        // table statement:
        let headers = {
            let headers = match records.next() {
                None => {
                    return Err(RelatableError::InputError(format!("'{path}' is empty")).into());
                }
                Some(record) => match record {
                    Err(err) => {
                        return Err(RelatableError::InputError(format!(
                            "Error reading from '{path}': {err}"
                        ))
                        .into());
                    }
                    Ok(headers) => headers.iter().map(|s| s.to_string()).collect::<Vec<_>>(),
                },
            };
            for header in &headers {
                if header.trim().is_empty() {
                    return Err(RelatableError::InputError(format!(
                        "One or more of the header fields is empty for table '{table}'"
                    ))
                    .into());
                }
            }
            headers
        };

        // Create the table and its associated _order trigger:
        let sql = r#"INSERT INTO "table" ("table", "path") VALUES (?, ?)"#;
        let params = json!([table, path]);
        self.connection.query(&sql, Some(&params)).await?;

        let sql = format!(
            r#"CREATE TABLE IF NOT EXISTS "{table}" (
                 _id INTEGER PRIMARY KEY, _order INTEGER UNIQUE, {other_column_defs}
            )"#,
            other_column_defs = headers
                .iter()
                .map(|header| format!(r#""{header}" TEXT"#))
                .collect::<Vec<_>>()
                .join(", ")
        );
        self.connection.query(&sql, None).await?;

        let sql = format!(
            r#"CREATE TRIGGER IF NOT EXISTS "{table}_order"
                 AFTER INSERT ON "{table}"
                 WHEN NEW._order IS NULL
                 BEGIN
                   UPDATE "{table}" SET _order = ({MOVE_INTERVAL} * NEW._id)
                   WHERE _id = NEW._id;
                 END"#
        );
        self.connection.query(&sql, None).await?;

        // Insert the data into the table:
        let columns = headers
            .iter()
            .map(|k| format!(r#""{k}""#))
            .collect::<Vec<_>>();
        let placeholders = columns.iter().map(|_| "?").collect::<Vec<_>>();
        let columns = columns.join(", ");
        let placeholders = placeholders.join(", ");
        while let Some(row) = records.next() {
            let row = row.expect("Error processing row");
            let sql = format!(r#"INSERT INTO "{table}" ({columns}) VALUES ({placeholders})"#,);
            let values = row.iter().collect::<Vec<_>>();
            let params = json!(values);
            self.connection.query(&sql, Some(&params)).await?;
        }

        self.commit_to_git().await?;
        Ok(())
    }

    pub async fn save_all(&self) -> Result<()> {
        let sql = r#"SELECT "table", "path" FROM "table" WHERE "path" IS NOT NULL"#;
        let table_rows = self.connection.query(&sql, None).await?;
        for table_row in table_rows {
            let table = table_row.get_string("table")?;
            let path = table_row.get_string("path")?;
            let mut writer = WriterBuilder::new()
                .delimiter(b'\t')
                .quote_style(QuoteStyle::Never)
                .from_path(path)?;

            let header_row = self
                .fetch_columns(&table)
                .await?
                .iter()
                .map(|c| c.name.to_string())
                .collect::<Vec<_>>();
            writer.write_record(header_row.clone())?;

            let sql = format!(
                r#"SELECT {columns} FROM "{table}" ORDER BY "_order""#,
                columns = header_row
                    .iter()
                    .map(|c| format!(r#""{c}""#))
                    .collect::<Vec<_>>()
                    .join(", ")
            );
            let data_rows = self.connection.query(&sql, None).await?;
            for data_row in data_rows {
                let values = {
                    let json_values = data_row.content.values();
                    let mut str_values = vec![];
                    for value in json_values {
                        match value.as_str() {
                            None => {
                                return Err(
                                    RelatableError::DataError("Not a string".to_string()).into()
                                );
                            }
                            Some(s) => str_values.push(s),
                        }
                    }
                    str_values
                };
                writer.write_record(values)?;
            }
        }

        Ok(())
    }

    pub async fn commit_to_git(&self) -> Result<()> {
        let author = match env::var("RLTBL_GIT_AUTHOR") {
            Err(err) => match err {
                env::VarError::NotPresent => {
                    tracing::info!("Not committing to git because RLTBL_GIT_AUTHOR not defined");
                    return Ok(());
                }
                _ => {
                    return Err(RelatableError::InputError(format!(
                        "Could not read from the environment: {err}"
                    ))
                    .into())
                }
            },
            Ok(author) => author,
        };
        tracing::info!("Committing to git on behalf of RLTBL_GIT_AUTHOR: '{author}'");

        // Save all the tables:
        self.save_all().await?;

        // Get the git status:
        let status = git::get_status()?;
        if status.behind != 0 {
            return Err(RelatableError::GitError(
                "Refusing to commit to a local repository that is behind the remote".to_string(),
            )
            .into());
        }

        // Possibly only amend the last commit, if it is by the same author and performed
        // on the same day:
        let (last_commit_author, days_ago) = git::get_last_commit_info()?;
        let is_amendment = (last_commit_author == author) && (days_ago < 1);

        // Stage any modified table files that have a path in the table table:
        let sql = r#"SELECT "path" FROM "table" WHERE "path" IS NOT NULL"#;
        let paths = self
            .connection
            .query(&sql, None)
            .await?
            .iter()
            .map(|row| row.get_string("path").expect("No 'path' found"))
            .collect::<Vec<_>>();
        git::add(&paths)?;

        // Finally, commit to git:
        git::commit("commit by rltbl", &author, is_amendment)?;
        Ok(())
    }

    fn _get_last_action_for_user(
        &self,
        tx: &mut DbTransaction<'_>,
        user: &str,
        action: &ChangeAction,
    ) -> Result<Option<(usize, ChangeSet)>> {
        let sql = r#"SELECT "change_id", "user", "table", "description", "content"
                     FROM "change"
                     WHERE "user" = ? AND "action" = ?
                     ORDER BY "change_id" DESC LIMIT 1"#;
        let params = json!([user, format!("{action}")]);
        let records = tx.query(&sql, Some(&params))?;
        match records.len() {
            0 => Ok(None),
            _ => {
                let change_id = records[0].get_unsigned("change_id")?;
                let user = records[0].get_string("user")?;
                let table = records[0].get_string("table")?;
                let description = records[0].get_string("description")?;
                let content = records[0].get_string("content")?;
                let changes = Change::many_from_str(&content)?;
                Ok(Some((
                    change_id,
                    ChangeSet {
                        action: *action,
                        table: table,
                        user: user,
                        description: description,
                        changes: changes,
                    },
                )))
            }
        }
    }

    pub fn record_changes(&self, changeset: &ChangeSet, tx: &mut DbTransaction<'_>) -> Result<()> {
        let user = changeset.user.clone();
        let action = changeset.action.to_string();
        let table = changeset.table.clone();
        let description = changeset.description.clone();

        // Begin by getting the current last change_id for this user, which we may need to look
        // up previous values of the row's columns in the history table later:
        let old_change_id = match &changeset.action {
            ChangeAction::Undo => {
                let (change_id, _) = self
                    ._get_last_action_for_user(tx, &changeset.user, &ChangeAction::Do)?
                    .ok_or(RelatableError::DataError(
                        "No action for user found".to_string(),
                    ))?;
                Some(change_id)
            }
            ChangeAction::Redo => {
                let (change_id, _) = self
                    ._get_last_action_for_user(tx, &changeset.user, &ChangeAction::Undo)?
                    .ok_or(RelatableError::DataError(
                        "No undo for user found".to_string(),
                    ))?;
                Some(change_id)
            }
            ChangeAction::Do => None,
        };

        // Now write the current change, which will generate a new last change_id:
        let statement = r#"INSERT INTO change("user", "action", "table", "description", "content")
                           VALUES (?, ?, ?, ?, ?)
                           RETURNING change_id"#;
        let content = to_value(&changeset.changes).unwrap_or_default();
        let params = json!([user, action, table, description, content]);
        let change_id = tx.query_value(&statement, Some(&params))?;
        let change_id = change_id
            .ok_or(RelatableError::DataError(
                "Expected a change_id".to_string(),
            ))?
            .as_u64()
            .ok_or(RelatableError::DataError("Expected an integer".to_string()))?;

        for change in &changeset.changes {
            match change {
                Change::Update {
                    row,
                    column,
                    before,
                    after,
                } => {
                    let sql = r#"INSERT INTO "history"
                                 ("change_id", "table", "row", "before", "after")
                                 VALUES (?, ?, ?, ?, ?)
                                 RETURNING "history_id""#;
                    let before = json!({column: before}).to_string();
                    let after = json!({column: after}).to_string();
                    let params = json!([change_id, table, row, before, after]);
                    tx.query_value(&sql, Some(&params))?;
                }
                Change::Add { row, after: _ } => {
                    // If the row has just been newly added, it will be found in the table,
                    // otherwise we will use the old_change_id to look for it in the history
                    // table:
                    let json_row = match self._get_row(&table, *row, tx)? {
                        Some(json_row) => json_row,
                        None => match old_change_id {
                            Some(change_id) => {
                                let sql = r#"SELECT "before" FROM "history" WHERE "change_id" = ?"#;
                                let params = json!([change_id]);
                                let before = tx
                                    .query_one(&sql, Some(&params))?
                                    .ok_or(RelatableError::DataError(format!(
                                        "No history row found with change_id {change_id}"
                                    )))?
                                    .get_string("before")?;
                                let before = match serde_json::from_str::<JsonValue>(&before) {
                                    Err(err) => return Err(err.into()),
                                    Ok(JsonValue::Object(o)) => o,
                                    Ok(_) => {
                                        return Err(RelatableError::InputError(
                                            "The content parameter is not an object".to_string(),
                                        )
                                        .into());
                                    }
                                };
                                JsonRow { content: before }
                            }
                            None => {
                                return Err(RelatableError::DataError(format!(
                                    "Row {row} not found"
                                ))
                                .into())
                            }
                        },
                    };
                    let sql = format!(
                        r#"INSERT INTO "history"
                           ("change_id", "table", "row", "after")
                           VALUES (?, ?, ?, ?)
                           RETURNING "history_id""#
                    );
                    let json_row_str = json!(json_row.content).to_string();
                    let params = json!([change_id, table, row, json_row_str]);
                    tx.query_value(&sql, Some(&params))?;
                }
                Change::Move {
                    row,
                    from_after: _,
                    to_after: _,
                } => {
                    let sql = r#"INSERT INTO "history"
                                 ("change_id", "table", "row")
                                 VALUES (?, ?, ?)
                                 RETURNING "history_id""#;
                    let params = json!([change_id, table, row]);
                    tx.query_value(&sql, Some(&params))?;
                }
                Change::Delete { row, after: _ } => {
                    let json_row = match self._get_row(&table, *row, tx)? {
                        Some(json_row) => json_row,
                        None => {
                            // It must be there since we supposedly just added it, so if it is
                            // not found return an error.
                            return Err(
                                RelatableError::DataError(format!("Row {row} not found")).into()
                            );
                        }
                    };
                    let sql = format!(
                        r#"INSERT INTO "history"
                           ("change_id", "table", "row", "before")
                           VALUES (?, ?, ?, ?)
                           RETURNING "history_id""#
                    );
                    let json_row_str = json!(json_row.content).to_string();
                    let params = json!([change_id, table, row, json_row_str]);
                    tx.query_value(&sql, Some(&params))?;
                }
            };
        }
        Ok(())
    }

    pub async fn get_user(&self, username: &str) -> Account {
        let statement = format!(
            r#"SELECT "name", "color", "cursor", "datetime"
               FROM user WHERE name = '{username}' LIMIT 1"#
        );
        let user = self.connection.query_one(&statement, None).await;
        if let Ok(user) = user {
            if let Some(user) = user {
                return Account {
                    name: username.to_string(),
                    color: user.get_string("color").expect("No 'color' found"),
                };
            }
        }
        Account {
            ..Default::default()
        }
    }

    pub async fn get_users(&self) -> Result<IndexMap<String, UserCursor>> {
        let mut users = IndexMap::new();
        // let statement = format!(
        //     r#"SELECT "name", color", "cursor", "datetime" FROM user WHERE cursor IS NOT NULL
        //        AND "datetime" >= DATETIME('now', '-10 minutes')"#
        // );
        let statement = format!(
            r#"SELECT "name", "color", "cursor", "datetime" FROM user WHERE cursor IS NOT NULL"#
        );
        let rows = self.connection.query(&statement, None).await?;
        for row in rows {
            let name = row.get_string("name")?;
            if name.trim() == "" {
                continue;
            }
            users.insert(
                name.clone(),
                UserCursor {
                    name: name.clone(),
                    color: row.get_string("color")?,
                    cursor: from_str(&row.get_string("cursor")?)?,
                    datetime: row.get_string("datetime")?,
                },
            );
        }
        Ok(users)
    }

    pub async fn get_table(&self, table_name: &str) -> Result<Table> {
        let statement = r#"SELECT "table" FROM 'table' WHERE "table" = ?"#;
        let params = json!([table_name]);
        match self
            .connection
            .query_value(&statement, Some(&params))
            .await?
        {
            Some(_) => (),
            None => {
                return Err(RelatableError::TableError(format!(
                    "Table '{table_name}' is not in the 'table' table"
                ))
                .into())
            }
        }

        let statement = r#"SELECT name FROM sqlite_master WHERE type = 'view' AND name = ?"#;
        let mut view = format!("{table_name}_default_view");
        let params = json!([view]);
        let result = self
            .connection
            .query_value(&statement, Some(&params))
            .await?;
        if result.is_none() {
            view = String::from(table_name);
        }
        // tracing::warn!("FIND THE VIEW {view}");

        let statement = r#"SELECT max(change_id) FROM history WHERE "table" = ?"#;
        let params = json!([table_name]);
        let change_id = match self
            .connection
            .query_value(&statement, Some(&params))
            .await?
        {
            Some(value) => value.as_u64().unwrap_or_default() as usize,
            None => 0,
        };
        let name = table_name.to_string();
        Ok(Table {
            name,
            view,
            change_id,
            ..Default::default()
        })
    }

    fn _get_table(&self, table_name: &str, tx: &mut DbTransaction<'_>) -> Result<Table> {
        let statement = r#"SELECT max(change_id) FROM history WHERE "table" = ?"#;
        let params = json!([table_name]);
        let change_id = match tx.query_value(&statement, Some(&params))? {
            Some(value) => value.as_u64().unwrap_or_default() as usize,
            None => 0,
        };
        Ok(Table {
            name: table_name.to_string(),
            change_id,
            ..Default::default()
        })
    }

    pub async fn get_tables(&self) -> Result<IndexMap<String, Table>> {
        let mut tables = IndexMap::new();
        let statement = format!(
            r#"SELECT "_id", "_order", "table", "path",
                 (SELECT max(change_id)
                  FROM history
                  WHERE history."table" = "table"."table"
                 ) AS _change_id
               FROM 'table'"#
        );

        let rows = self.connection.query(&statement, None).await?;
        for row in rows {
            let name = row.get_string("table")?;
            tables.insert(
                name.clone(),
                Table {
                    name: name.clone(),
                    change_id: row
                        .content
                        .get("_change_id")
                        .and_then(|i| i.as_u64())
                        .unwrap_or_default() as usize,
                    ..Default::default()
                },
            );
        }
        Ok(tables)
    }

    fn _get_row_order(&self, table: &str, row: usize, tx: &mut DbTransaction<'_>) -> Result<usize> {
        let sql = format!(r#"SELECT "_order" FROM "{table}" WHERE "_id" = ?"#,);
        let params = json!([row]);
        let rows = tx.query(&sql, Some(&params))?;
        if rows.len() == 0 {
            return Err(
                RelatableError::InputError(format!("No row {row} in table '{table}'")).into(),
            );
        }
        Ok(rows[0].get_unsigned("_order")?)
    }

    fn _get_previous_row_id(
        &self,
        table: &str,
        row: usize,
        tx: &mut DbTransaction<'_>,
    ) -> Result<usize> {
        let curr_row_order = self._get_row_order(table, row, tx)?;
        let sql = format!(
            r#"SELECT "_id" FROM "{table}" WHERE "_order" < ?
               ORDER BY "_order" DESC LIMIT 1"#,
        );
        let params = json!([curr_row_order]);
        let rows = tx.query(&sql, Some(&params))?;
        if rows.len() == 0 {
            Ok(0)
        } else {
            rows[0].get_unsigned("_id")
        }
    }

    fn _get_row(
        &self,
        table: &str,
        row: usize,
        tx: &mut DbTransaction<'_>,
    ) -> Result<Option<JsonRow>> {
        let sql = format!(r#"SELECT * FROM "{table}" WHERE "_id" = ?"#);
        let params = json!([row]);
        tx.query_one(&sql, Some(&params))
    }

    pub async fn get_site(&self, username: &str) -> Site {
        let mut users = self.get_users().await.unwrap_or_default();
        users.shift_remove(username);
        Site {
            title: "RLTBL".to_string(),
            root: self.root.clone(),
            editable: !self.readonly,
            user: self.get_user(username).await,
            users,
            tables: self.get_tables().await.unwrap_or_default(),
        }
    }

    pub fn prepare_user_cursor(
        &self,
        changeset: &ChangeSet,
        tx: &mut DbTransaction<'_>,
    ) -> Result<()> {
        // Make sure the user is present in the user table
        let user = changeset.user.clone();
        let color = random_color::RandomColor::new().to_hex();
        let statement = r#"INSERT OR IGNORE INTO user("name", "color") VALUES (?, ?)"#;
        let params = json!([user, color]);
        tx.query(&statement, Some(&params))?;

        // Update the user's cursor position.
        let mut cursor = changeset.to_cursor()?;
        match changeset.action {
            ChangeAction::Undo | ChangeAction::Redo => match changeset.changes.first() {
                Some(Change::Delete { row, after: _ }) => {
                    cursor.row = self._get_previous_row_id(&changeset.table, *row, tx)?;
                }
                _ => (),
            },
            ChangeAction::Do => (),
        };

        let statement =
            r#"UPDATE user SET "cursor" = ?, "datetime" = CURRENT_TIMESTAMP WHERE "name" = ?"#;
        let params = json!([to_value(cursor).unwrap_or_default(), user]);
        tx.query_value(&statement, Some(&params))?;

        Ok(())
    }

    pub async fn get_last_undo_for_user(&self, user: &str) -> Result<Option<(usize, ChangeSet)>> {
        // TODO: This is not very efficient. Yet strictly speaking it isn't possible to know
        // in advance how far back to go to get the last do. In principle the user could
        // have done something any number of times before calling this function. That is
        // why we pass None to get_user_history() here:
        let (_, redoable_changes) = self.get_user_history(user, None).await?;
        match redoable_changes.first() {
            None => Ok(None),
            Some(change) => {
                let change_id = change.get_unsigned("change_id")?;
                let content = change.get_string("content")?;
                let changes = Change::many_from_str(&content)?;
                Ok(Some((
                    change_id,
                    ChangeSet {
                        action: ChangeAction::from_str(&change.get_string("action")?)?,
                        table: change.get_string("table")?,
                        user: change.get_string("user")?,
                        description: change.get_string("user")?,
                        changes: changes,
                    },
                )))
            }
        }
    }

    pub async fn get_last_do_for_user(&self, user: &str) -> Result<Option<(usize, ChangeSet)>> {
        // TODO: This is not very efficient. Yet strictly speaking it isn't possible to know
        // in advance how far back to go to get the last do. In principle the user could
        // have undone something any number of times before calling this function. That is
        // why we pass None to get_user_history() here:
        let (undoable_changes, _) = self.get_user_history(user, None).await?;
        match undoable_changes.first() {
            None => Ok(None),
            Some(change) => {
                let change_id = change.get_unsigned("change_id")?;
                let content = change.get_string("content")?;
                let changes = Change::many_from_str(&content)?;
                Ok(Some((
                    change_id,
                    ChangeSet {
                        action: ChangeAction::from_str(&change.get_string("action")?)?,
                        table: change.get_string("table")?,
                        user: change.get_string("user")?,
                        description: change.get_string("user")?,
                        changes: changes,
                    },
                )))
            }
        }
    }

    pub async fn get_user_history(
        &self,
        user: &str,
        context: Option<usize>,
    ) -> Result<(Vec<JsonRow>, Vec<JsonRow>)> {
        let (limit, limit_clause) = match context {
            None => (0, ""),
            Some(limit) => (limit, " LIMIT ?"),
        };
        // Get the N last actions for this user where N = `context`:
        let sql = format!(
            r#"SELECT "change_id", "user", "table", "description", "action", "content"
                 FROM "change"
                WHERE "user" = ?
                ORDER BY "change_id" DESC{limit_clause}"#
        );
        let params = if limit_clause.is_empty() {
            json!([user])
        } else {
            json!([user, limit])
        };
        let history = self.connection.query(&sql, Some(&params)).await?;

        // Initialize the histories to be returned:
        let mut undoable_changes = vec![];
        let mut redoable_changes = vec![];

        // Push the first user action to the appropriate history:
        let (first_change, first_action) = match history.first() {
            None => return Ok((vec![], vec![])), // Nothing else to do in this case
            Some(first_change) => {
                let first_action = ChangeAction::from_str(&first_change.get_string("action")?)?;
                (first_change, first_action)
            }
        };
        match first_action {
            ChangeAction::Do | ChangeAction::Redo => {
                undoable_changes.push(first_change.clone());
            }
            ChangeAction::Undo => redoable_changes.push(first_change.clone()),
        };

        // Do the same for the remaining actions:
        let mut last_action = first_action;
        let mut skip: isize = -1;
        for change in &history[1..] {
            let action = ChangeAction::from_str(&change.get_string("action")?)?;
            match last_action {
                ChangeAction::Do | ChangeAction::Redo => match action {
                    ChangeAction::Do | ChangeAction::Redo => undoable_changes.push(change.clone()),
                    ChangeAction::Undo => {
                        //println!(
                        //    "SKIPPING {action} {change_id} {description} ...",
                        //    action = action.to_string().to_uppercase(),
                        //    change_id = change.get_unsigned("change_id").unwrap(),
                        //    description = change.get_string("description").unwrap()
                        //);

                        if skip == -1 {
                            skip = undoable_changes.len() as isize;
                        }

                        if skip > 0 {
                            // print!("Skip value decremented from {skip} ");
                            last_action = ChangeAction::Redo;
                            skip -= 1;
                            // println!("to {skip}");
                        } else if skip == 0 {
                            redoable_changes.push(change.clone());
                            last_action = action;
                        }
                        continue;
                    }
                },
                ChangeAction::Undo => match action {
                    ChangeAction::Undo => {
                        // I think this is unreachable unless skip is already -1 so this may be
                        // redundant:
                        skip = -1;
                        redoable_changes.push(change.clone());
                    }
                    ChangeAction::Redo => break,
                    ChangeAction::Do => {
                        //println!(
                        //    "SKIPPING {action} {change_id} {description} ...",
                        //    action = action.to_string().to_uppercase(),
                        //    change_id = change.get_unsigned("change_id").unwrap(),
                        //    description = change.get_string("description").unwrap()
                        //);

                        if skip == -1 {
                            skip = redoable_changes.len() as isize;
                        }

                        if skip > 0 {
                            // print!("Skip value decremented from {skip} ");
                            last_action = ChangeAction::Undo;
                            skip -= 1;
                            // println!("to {skip}");
                        } else if skip == 0 {
                            undoable_changes.push(change.clone());
                            last_action = action;
                        }
                        continue;
                    }
                },
            };
        }

        //println!("Undo history {undoable_changes:#?}");
        //println!("Redo history {redoable_changes:#?}");
        //println!("");

        Ok((undoable_changes, redoable_changes))
    }

    async fn _undo_or_redo(
        &self,
        change_id: usize,
        changeset: &ChangeSet,
    ) -> Result<Option<ChangeSet>> {
        match changeset.changes.first() {
            None => Ok(None),
            Some(change) => {
                if let Change::Update { .. } = change {
                    let conn = self.connection.reconnect()?;
                    let actual_changes = self._set_values(conn, &changeset).await?;
                    Ok(Some(actual_changes))
                } else {
                    let mut actual_changes = vec![];
                    for change in changeset.changes.iter() {
                        let conn = self.connection.reconnect()?;
                        match change {
                            Change::Update { .. } => (), // Change::Update already handled above.
                            Change::Add { row, after: _ } => {
                                let num_deleted = self
                                    ._delete_row(
                                        conn,
                                        &changeset.action,
                                        &changeset.table,
                                        &changeset.user,
                                        *row,
                                    )
                                    .await?;
                                if num_deleted > 0 {
                                    actual_changes.push(change.clone());
                                }
                            }
                            Change::Move {
                                row,
                                from_after,
                                to_after: _,
                            } => {
                                let new_order = self
                                    ._move_and_record_row(
                                        conn,
                                        &changeset.action,
                                        &changeset.table,
                                        &changeset.user,
                                        *row,
                                        *from_after,
                                    )
                                    .await?;
                                if new_order > 0 {
                                    actual_changes.push(change.clone());
                                }
                            }
                            Change::Delete { row, after } => {
                                // Get the row, as it was before it was deleted, from the history
                                // table:
                                let sql = r#"SELECT "before" FROM "history" WHERE "change_id" = ?"#;
                                let params = json!([change_id]);
                                let before = self
                                    .connection
                                    .query_one(&sql, Some(&params))
                                    .await?
                                    .ok_or(RelatableError::DataError(format!(
                                        "No history row found with change_id {change_id}"
                                    )))?
                                    .get_string("before")?;
                                let before = match serde_json::from_str::<JsonValue>(&before) {
                                    Err(err) => return Err(err.into()),
                                    Ok(JsonValue::Object(o)) => o,
                                    Ok(_) => {
                                        return Err(RelatableError::InputError(
                                            "The content parameter is not an object".to_string(),
                                        )
                                        .into());
                                    }
                                };
                                let before = JsonRow { content: before };
                                // Re-add it to the data table:
                                self._add_row(
                                    conn,
                                    &changeset.action,
                                    &changeset.table,
                                    &changeset.user,
                                    Some(*row),
                                    Some(*after),
                                    &before,
                                )
                                .await?;
                                actual_changes.push(change.clone());
                            }
                        };
                    }
                    Ok(Some(ChangeSet {
                        action: changeset.action,
                        table: changeset.table.clone(),
                        user: changeset.user.clone(),
                        description: changeset.description.clone(),
                        changes: actual_changes,
                    }))
                }
            }
        }
    }

    pub async fn undo(&self, user: &str) -> Result<Option<ChangeSet>> {
        let (change_id, mut changeset) = match self.get_last_do_for_user(user).await? {
            None => {
                tracing::warn!("Nothing to undo for '{user}'");
                return Ok(None);
            }
            Some(changeset) => changeset,
        };
        changeset.action = ChangeAction::Undo;
        let changeset = self._undo_or_redo(change_id, &changeset).await?;
        if let Some(_) = changeset {
            self.commit_to_git().await?;
        }
        Ok(changeset)
    }

    pub async fn redo(&self, user: &str) -> Result<Option<ChangeSet>> {
        let (change_id, mut changeset) = match self.get_last_undo_for_user(user).await? {
            None => {
                tracing::warn!("Nothing to redo for '{user}'");
                return Ok(None);
            }
            Some(changeset) => changeset,
        };
        changeset.action = ChangeAction::Redo;
        let changeset = self._undo_or_redo(change_id, &changeset).await?;
        if let Some(_) = changeset {
            self.commit_to_git().await?;
        }
        Ok(changeset)
    }

    async fn _set_values(
        &self,
        mut conn: Option<DbActiveConnection>,
        changeset: &ChangeSet,
    ) -> Result<ChangeSet> {
        // Begin a transaction:
        let mut tx = self.connection.begin(&mut conn).await?;

        // Update the user cursor
        self.prepare_user_cursor(changeset, &mut tx)?;

        // Actually make the changes:
        let table = changeset.table.clone();
        let mut actual_changes = vec![];
        for change in &changeset.changes {
            match change {
                Change::Update {
                    row,
                    column,
                    before,
                    after,
                } => {
                    // WARN: This just sets text!
                    let sql = format!(
                        r#"UPDATE "{table}"
                              SET "{column}" = ?
                            WHERE _id = ?
                           RETURNING 1 AS "updated""#,
                    );

                    // Depending on whether this is an undo/redo or an original action, the
                    // new value will be taken from either `before` or `after`.
                    let value = match &changeset.action {
                        ChangeAction::Undo | ChangeAction::Redo => before,
                        ChangeAction::Do => after,
                    };
                    // TODO: Render JSON to SQL properly.
                    let params = json!([json_to_string(&value), row]);
                    if tx.query(&sql, Some(&params))?.len() < 1 {
                        tracing::warn!("No row with _id {row} found to update");
                    } else {
                        actual_changes.push(Change::Update {
                            row: *row,
                            column: column.clone(),
                            before: match &changeset.action {
                                ChangeAction::Undo | ChangeAction::Redo => after.clone(),
                                ChangeAction::Do => before.clone(),
                            },
                            after: match &changeset.action {
                                ChangeAction::Undo | ChangeAction::Redo => before.clone(),
                                ChangeAction::Do => after.clone(),
                            },
                        });
                    }
                }
                _ => {
                    return Err(RelatableError::InputError(format!(
                        "Invalid change in changeset argument to set_values(): {change:?}"
                    ))
                    .into());
                }
            };
        }

        let num_changes = actual_changes.len();
        let actual_changeset = ChangeSet {
            action: changeset.action,
            table: changeset.table.clone(),
            user: changeset.user.clone(),
            description: changeset.description.clone(),
            changes: actual_changes,
        };
        if num_changes > 0 {
            // Record the changes to the change and history tables:
            self.record_changes(&actual_changeset, &mut tx)?;
        }

        // Commit the transaction:
        tx.commit()?;

        Ok(actual_changeset)
    }

    pub async fn set_values(&self, changeset: &ChangeSet) -> Result<ChangeSet> {
        let conn = self.connection.reconnect()?;
        let changeset = self._set_values(conn, changeset).await?;
        if changeset.changes.len() > 0 {
            self.commit_to_git().await?;
        }
        Ok(changeset)
    }

    async fn _add_row(
        &self,
        mut conn: Option<DbActiveConnection>,
        action: &ChangeAction,
        table_name: &str,
        user: &str,
        new_row_id: Option<usize>,
        after_id: Option<usize>,
        row: &JsonRow,
    ) -> Result<Row> {
        // Begin a transaction:
        let mut tx = self.connection.begin(&mut conn).await?;

        // Get the current database information for the table:
        let table = self._get_table(table_name, &mut tx)?;
        if !table.editable {
            return Err(
                RelatableError::InputError(format!("{} is not editable.", table_name,)).into(),
            );
        }

        // Prepare a new row to be inserted:
        let mut new_row = Row::prepare_new(&table, Some(row), &mut tx)?;
        // A new_row_id will have been passed if the row is being added as part of an undo/redo.
        // In that case an after_id must have been passed as well but we assign the default
        // row order for now:
        if let Some(new_row_id) = new_row_id {
            new_row.id = new_row_id;
            new_row.order = new_row.id * MOVE_INTERVAL;
        }

        // Add the row to the table:
        let (sql, params) = new_row.as_insert(&table.name);
        tracing::info!("_add_row {sql} {params:?}");
        tx.query(&sql, Some(&params))?;

        let after_id = match after_id {
            None => self._get_previous_row_id(table_name, new_row.id, &mut tx)?,
            Some(after_id) => {
                // Move the row to its assigned spot within the table:
                let new_order = self._move_row(&mut tx, &table, new_row.id, after_id)?;
                new_row.order = new_order;
                after_id
            }
        };

        // Prepare a changeset to be recorded, consisting of a single change record indicating
        // the addition of one new row with the new_row's id and position in the table:
        let changeset = ChangeSet {
            action: *action,
            table: table_name.to_string(),
            user: user.to_string(),
            description: "Add one row".to_string(),
            changes: vec![Change::Add {
                row: new_row.id,
                after: after_id,
            }],
        };

        // Use the changeset to prepare the user cursor:
        self.prepare_user_cursor(&changeset, &mut tx)?;

        // Record the changes to the history table:
        self.record_changes(&changeset, &mut tx)?;

        // Commit the transaction:
        tx.commit()?;

        Ok(new_row)
    }

    pub async fn add_row(
        &self,
        table_name: &str,
        user: &str,
        after_id: Option<usize>,
        row: &JsonRow,
    ) -> Result<Row> {
        let conn = self.connection.reconnect()?;
        let new_row = self
            ._add_row(
                conn,
                &ChangeAction::Do,
                table_name,
                user,
                None,
                after_id,
                row,
            )
            .await?;
        self.commit_to_git().await?;
        Ok(new_row)
    }

    async fn _delete_row(
        &self,
        mut conn: Option<DbActiveConnection>,
        action: &ChangeAction,
        table_name: &str,
        user: &str,
        row: usize,
    ) -> Result<usize> {
        // Begin a transaction:
        let mut tx = self.connection.begin(&mut conn).await?;

        // Get the current database information for the table:
        let table = self._get_table(table_name, &mut tx)?;
        if !table.editable {
            return Err(
                RelatableError::InputError(format!("{} is not editable.", table_name,)).into(),
            );
        }

        // Prepare a changeset to be recorded, consisting of a single change record indicating
        // that a row with the given row number at the given table position has been deleted:
        let changeset = ChangeSet {
            action: *action,
            table: table_name.to_string(),
            user: user.to_string(),
            description: "Delete one row".to_string(),
            changes: vec![Change::Delete {
                row: row,
                after: self._get_previous_row_id(table_name, row, &mut tx)?,
            }],
        };

        // Use the changeset to prepare the user cursor:
        self.prepare_user_cursor(&changeset, &mut tx)?;

        // Delete the row:
        let sql = format!(
            r#"DELETE FROM "{}" WHERE "_id" = ? RETURNING 1 AS "deleted""#,
            table.name
        );
        let params = json!([row]);

        // Record the change to the history table:
        self.record_changes(&changeset, &mut tx)?;

        let num_deleted = tx.query(&sql, Some(&params))?.len();
        if num_deleted < 1 {
            tracing::warn!("No row found with _id {row} to delete");
            // Roll back the changes to the history and change table. The reason we made these
            // prior to the actual delete was so that we could record the row's position in the
            // table before it was deleted.
            tx.rollback()?;
        } else {
            // Commit the transaction:
            tx.commit()?;
        }

        Ok(num_deleted)
    }

    pub async fn delete_row(&self, table_name: &str, user: &str, row: usize) -> Result<usize> {
        let conn = self.connection.reconnect()?;
        let num_deleted = self
            ._delete_row(conn, &ChangeAction::Do, table_name, user, row)
            .await?;
        if num_deleted > 0 {
            self.commit_to_git().await?;
        }
        Ok(num_deleted)
    }

    async fn _move_and_record_row(
        &self,
        mut conn: Option<DbActiveConnection>,
        action: &ChangeAction,
        table_name: &str,
        user: &str,
        id: usize,
        after_id: usize,
    ) -> Result<usize> {
        // Begin a transaction:
        let mut tx = self.connection.begin(&mut conn).await?;

        // Get the current database information for the table:
        let table = self._get_table(table_name, &mut tx)?;
        if !table.editable {
            return Err(
                RelatableError::InputError(format!("{} is not editable.", table_name,)).into(),
            );
        }

        // Prepare a changeset to be recorded, consisting of a single change record indicating
        // that a row has been displaced from somewhere to somewhere else.
        let changeset = ChangeSet {
            action: *action,
            table: table_name.to_string(),
            user: user.to_string(),
            description: "Move one row".to_string(),
            changes: vec![Change::Move {
                row: id,
                from_after: self._get_previous_row_id(table_name, id, &mut tx)?,
                to_after: after_id,
            }],
        };

        // Use the changeset to prepare the user cursor:
        self.prepare_user_cursor(&changeset, &mut tx)?;

        // Move the row within the table:
        let new_order = self._move_row(&mut tx, &table, id, after_id)?;

        if new_order != 0 {
            // Record the change to the history table:
            self.record_changes(&changeset, &mut tx)?;
        }

        // Commit the transaction:
        tx.commit()?;

        Ok(new_order)
    }

    fn _move_row(
        &self,
        tx: &mut DbTransaction<'_>,
        table: &Table,
        id: usize,
        after_id: usize,
    ) -> Result<usize> {
        fn get_row_order(
            tx: &mut DbTransaction<'_>,
            table: &Table,
            row_id: usize,
        ) -> Result<usize> {
            let sql = format!(r#"SELECT "_order" FROM "{}" WHERE "_id" = ?"#, table.name);
            let params = json!([row_id]);
            let rows = tx.query(&sql, Some(&params))?;
            if rows.is_empty() {
                return Err(RelatableError::DataError(format!(
                    "Unable to fetch _order for row {row_id} of table '{table}'",
                    table = table.name
                ))
                .into());
            }
            match rows[0].content.get("_order").and_then(|o| o.as_u64()) {
                Some(order) => Ok(order as usize),
                None => {
                    return Err(
                        RelatableError::DataError("No integer '_order' in row".to_string()).into(),
                    )
                }
            }
        }

        // Get the order, (A), of `after_id`:
        let order_prev = {
            if after_id > 0 {
                get_row_order(tx, table, after_id)?
            } else {
                // It is not possible for a row to be assigned a order of zero. We allow it as a
                // possible value of `after_id`, however, which is used as a special value that we
                // should move the row identified by `id` to the beginning of the table.
                0
            }
        };

        // Run a query to get the minimum order, (B), that is greater than (A).
        let order_next = {
            let sql = format!(
                r#"SELECT MIN("_order") AS "_order" FROM "{}" WHERE "_order" > ?"#,
                table.name
            );
            let params = json!([order_prev]);
            let rows = tx.query(&sql, Some(&params))?;
            if rows.is_empty() {
                return Err(RelatableError::DataError(format!(
                    "Could not determine the minimum row order greater than {order_prev}"
                ))
                .into());
            }

            match rows[0].content.get("_order") {
                Some(value) => match value {
                    JsonValue::Null => {
                        // The row_order will be null if we ask Relatable to move a row to
                        // a position after the last row in the table.
                        order_prev + MOVE_INTERVAL
                    }
                    _ => match value.as_u64() {
                        Some(order) => order as usize,
                        None => {
                            return Err(RelatableError::DataError(
                                "Field '_order' in row is not an integer".to_string(),
                            )
                            .into());
                        }
                    },
                },
                None => {
                    return Err(RelatableError::DataError("No '_order' in row".to_string()).into());
                }
            }
        };

        let mut new_order = {
            if order_prev + 1 < order_next {
                // If the next order is not occupied just use it:
                order_prev + 1
            } else {
                // Otherwise, get all the orders that need to be moved. We sort the results in
                // descending order so that when we later update each value, no duplicate key
                // violations will ensue:
                let upper_bound = (order_next as f32 / MOVE_INTERVAL as f32).ceil() as usize
                    * MOVE_INTERVAL as usize;
                let sql = format!(
                    r#"SELECT "_order"
                         FROM "{}"
                        WHERE "_order" >= ? AND "_order" < ?
                     ORDER BY "_order" DESC"#,
                    table.name,
                );
                let params = json!([order_next, upper_bound]);
                let rows = tx.query(&sql, Some(&params))?;
                if rows.is_empty() {
                    return Err(RelatableError::DataError(
                        "Could not determine the highest row order".to_string(),
                    )
                    .into());
                }
                let highest_order = match rows[0].content.get("_order").and_then(|o| o.as_u64()) {
                    Some(order) => order as usize,
                    None => {
                        return Err(RelatableError::DataError(
                            "No field '_order' in row or it is not an integer".to_string(),
                        )
                        .into())
                    }
                };
                if highest_order + 1 >= upper_bound {
                    // Return an error
                    return Err(RelatableError::DataError(format!(
                        "Impossible to move row {} after row {}: No more room",
                        id, after_id
                    ))
                    .into());
                }

                for row in rows {
                    let current_order = match row.content.get("_order").and_then(|o| o.as_u64()) {
                        Some(order) => order as usize,
                        None => {
                            return Err(RelatableError::DataError(
                                "No field '_order' in row or it is not an integer".to_string(),
                            )
                            .into())
                        }
                    };
                    let sql = format!(
                        r#"UPDATE "{}"
                              SET "_order" = "_order" + 1
                            WHERE "_order" = ?"#,
                        table.name
                    );
                    let params = json!([current_order]);
                    tx.query(&sql, Some(&params))?;
                }
                // Now that we have made some room, we can use order_prev + 1,
                // which should no longer be occupied:
                order_prev + 1
            }
        };

        let sql = format!(
            r#"UPDATE "{}" SET "_order" = ? WHERE "_id" = ? RETURNING 1 AS "moved""#,
            table.name
        );
        let params = json!([new_order, id]);
        if tx.query(&sql, Some(&params))?.len() < 1 {
            tracing::warn!("Now row with _id {id} found to move");
            // It is not possible for a row to have an order of zero. It is used here to
            // represent the case where no row was actually moved to the caller.
            new_order = 0;
        }
        Ok(new_order)
    }

    fn _change_row_id(
        &self,
        tx: &mut DbTransaction<'_>,
        table: &Table,
        id: usize,
        new_id: usize,
    ) -> Result<()> {
        let sql = format!(
            r#"UPDATE "{table}"
                  SET "_id" = ?, "_order" = ?
                WHERE "_id" = ?
            RETURNING "_id" AS "_id""#,
            table = table.name,
        );
        let params = json!([new_id, id, id * MOVE_INTERVAL]);
        tx.query_one(&sql, Some(&params))?
            .ok_or(RelatableError::DataError(format!("No row with _id = {id}")))?
            .get_unsigned("_id")?;
        Ok(())
    }

    pub async fn move_row(
        &self,
        table_name: &str,
        user: &str,
        id: usize,
        after_id: usize,
    ) -> Result<usize> {
        let conn = self.connection.reconnect()?;
        let new_order = self
            ._move_and_record_row(conn, &ChangeAction::Do, table_name, user, id, after_id)
            .await?;
        if new_order != 0 {
            self.commit_to_git().await?;
        }
        Ok(new_order)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ChangeSet {
    pub action: ChangeAction,
    pub table: String,
    pub user: String,
    pub description: String,
    pub changes: Vec<Change>,
}

impl ChangeSet {
    fn to_cursor(&self) -> Result<Cursor> {
        let table = self.table.clone();
        match self.changes.first() {
            Some(change) => match change {
                Change::Update {
                    row,
                    column,
                    before: _,
                    after: _,
                } => Ok(Cursor {
                    table,
                    row: *row,
                    column: column.to_string(),
                }),
                Change::Add { row, after: _ } => Ok(Cursor {
                    table,
                    row: *row,
                    column: "".to_string(),
                }),
                Change::Move {
                    row,
                    from_after: _,
                    to_after: _,
                } => Ok(Cursor {
                    table,
                    row: *row,
                    column: "".to_string(),
                }),
                Change::Delete { row, after: _ } => Ok(Cursor {
                    table,
                    row: *row,
                    column: "".to_string(),
                }),
            },
            None => Err(RelatableError::ChangeError("No changes in set".into()).into()),
        }
    }
}

#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
pub enum ChangeAction {
    Do,
    Undo,
    Redo,
}

impl FromStr for ChangeAction {
    type Err = anyhow::Error;

    fn from_str(action: &str) -> Result<Self> {
        match action.to_lowercase().as_str() {
            "do" => Ok(Self::Do),
            "undo" => Ok(Self::Undo),
            "redo" => Ok(Self::Redo),
            _ => {
                return Err(
                    RelatableError::InputError(format!("Unrecognized action: {action}")).into(),
                );
            }
        }
    }
}

impl Display for ChangeAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ChangeAction::Do => write!(f, "do"),
            ChangeAction::Undo => write!(f, "undo"),
            ChangeAction::Redo => write!(f, "redo"),
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum Change {
    Update {
        row: usize,
        column: String,
        before: JsonValue,
        after: JsonValue,
    },
    Add {
        row: usize,
        after: usize,
    },
    Move {
        row: usize,
        from_after: usize,
        to_after: usize,
    },
    Delete {
        row: usize,
        after: usize,
    },
}

impl Change {
    fn many_from_str(content: &str) -> Result<Vec<Self>> {
        let json_content = match serde_json::from_str::<JsonValue>(content) {
            Err(err) => return Err(err.into()),
            Ok(JsonValue::Array(v)) => v,
            Ok(_) => {
                return Err(RelatableError::InputError(
                    "The content parameter is not an array".to_string(),
                )
                .into());
            }
        };

        let mut changes = vec![];
        for change_json in json_content.iter() {
            let change_json = match change_json.as_object() {
                Some(change_object) => JsonRow {
                    content: change_object.clone(),
                },
                None => {
                    return Err(RelatableError::InputError(format!(
                        "Not an object: {change_json}"
                    ))
                    .into());
                }
            };

            let change_type = change_json.get_string("type")?;
            let row = change_json.get_unsigned("row")?;
            match change_type.as_str() {
                "Update" => changes.push(Change::Update {
                    row: row,
                    column: change_json.get_string("column")?,
                    before: change_json.get_value("before")?,
                    after: change_json.get_value("after")?,
                }),
                "Add" => changes.push(Change::Add {
                    row: row,
                    after: change_json.get_unsigned("after")?,
                }),
                "Delete" => changes.push(Change::Delete {
                    row: row,
                    after: change_json.get_unsigned("after")?,
                }),
                "Move" => changes.push(Change::Move {
                    row: row,
                    from_after: change_json.get_unsigned("from_after")?,
                    to_after: change_json.get_unsigned("to_after")?,
                }),
                _ => {
                    return Err(RelatableError::InputError(format!(
                        "Unrecognized change type for change: {change_json}"
                    ))
                    .into());
                }
            };
        }
        Ok(changes)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Cell {
    value: JsonValue,
    text: String,
}

impl From<&JsonValue> for Cell {
    fn from(value: &JsonValue) -> Self {
        Self {
            value: value.clone(),
            text: match value {
                JsonValue::String(value) => value.to_string(),
                value => format!("{value}"),
            },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Row {
    pub id: usize,
    pub order: usize,
    pub change_id: usize,
    pub cells: IndexMap<String, Cell>,
}

impl Row {
    fn get_next_id(table: &str, tx: &mut DbTransaction<'_>) -> Result<usize> {
        let sql = format!(r#"SELECT MAX("_id") FROM "{}""#, table);
        let current_row_id = match tx.query_value(&sql, None)? {
            Some(value) => value.as_u64().unwrap_or_default() as usize,
            None => 0,
        };
        Ok(current_row_id + 1)
    }

    fn prepare_new(
        table: &Table,
        json_row: Option<&JsonRow>,
        tx: &mut DbTransaction<'_>,
    ) -> Result<Self> {
        let json_row = match json_row {
            None => {
                // WARN: SQLite only!
                let statement = format!(
                    r#"SELECT "name" FROM pragma_table_info("{table}") ORDER BY "cid""#,
                    table = table.name
                );
                let columns = {
                    let columns = tx.query(&statement, None)?;
                    if columns.is_empty() {
                        return Err(RelatableError::DataError(format!(
                            "No defined columns for: {table}",
                            table = table.name
                        ))
                        .into());
                    }
                    columns
                        .iter()
                        .map(|c| c.get_string("name").expect("No 'name' found"))
                        .filter(|n| !n.starts_with("_"))
                        .collect::<Vec<_>>()
                };
                let columns = columns.iter().map(|c| c.as_str()).collect::<Vec<_>>();
                JsonRow::from_strings(&columns)
            }
            Some(json_row) => json_row.clone(),
        };
        let mut row = Row::from(json_row);
        row.id = Self::get_next_id(table.name.as_str(), tx)?;
        row.order = MOVE_INTERVAL * row.id;
        row.change_id = table.change_id;
        Ok(row)
    }

    fn to_strings(&self) -> Vec<String> {
        self.cells.values().map(|cell| cell.text.clone()).collect()
    }

    fn as_insert(&self, table: &str) -> (String, JsonValue) {
        let id = self.id;
        let order = self.order;
        let columns = self
            .cells
            .keys()
            .map(|k| format!(r#""{k}""#))
            .collect::<Vec<_>>();
        let column_placeholders = columns.iter().map(|_| "?").collect::<Vec<_>>();

        let params = {
            let mut params = vec![json!(id), json!(order)];
            params.append(
                &mut self
                    .to_strings()
                    .iter()
                    .map(|s| json!(s))
                    .collect::<Vec<_>>(),
            );
            params
        };

        let sql = if columns.len() == 0 {
            format!(
                r#"INSERT INTO "{table}"
                   ("_id", "_order")
                   VALUES (?, ?)"#
            )
        } else {
            format!(
                r#"INSERT INTO "{table}"
                   ("_id", "_order", {column_names})
                   VALUES (?, ?, {column_values})"#,
                column_names = columns.join(", "),
                column_values = column_placeholders.join(", "),
            )
        };
        (sql, json!(params))
    }
}

impl From<Row> for Vec<String> {
    fn from(row: Row) -> Self {
        row.to_strings()
    }
}

impl From<JsonRow> for Row {
    fn from(row: JsonRow) -> Self {
        Self {
            id: row
                .content
                .get("_id")
                .and_then(|i| i.as_u64())
                .unwrap_or_default() as usize,
            order: row
                .content
                .get("_order")
                .and_then(|i| i.as_u64())
                .unwrap_or_default() as usize,
            change_id: row
                .content
                .get("_change_id")
                .and_then(|i| i.as_u64())
                .unwrap_or_default() as usize,
            cells: row
                .content
                .iter()
                // Ignore columns that start with "_"
                .filter(|(k, _)| !k.starts_with("_"))
                .map(|(k, v)| (k.clone(), v.into()))
                .collect(),
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Column {
    pub name: String,
    // sqltype: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Table {
    pub name: String,
    // A view to use when displaying this table, or empty if none.
    pub view: String,
    // The history_id of the most recent update to this table.
    pub change_id: usize,
    pub editable: bool,
}

impl Default for Table {
    fn default() -> Self {
        Self {
            name: String::default(),
            view: String::default(),
            change_id: usize::default(),
            editable: true,
        }
    }
}

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct Range {
    count: usize,
    total: usize,
    start: usize,
    end: usize,
}

impl std::fmt::Display for Range {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Rows {}-{} of {}", self.start, self.end, self.total)
    }
}

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct ResultSet {
    select: Select,
    range: Range,
    table: Table,
    columns: Vec<Column>,
    rows: Vec<Row>,
}

impl std::fmt::Display for ResultSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut tw = TabWriter::new(vec![]);
        tw.write(format!("{}\n", self.range).as_bytes())
            .unwrap_or_default();
        let header = &self
            .columns
            .iter()
            .map(|c| c.name.clone())
            .collect::<Vec<String>>();
        tw.write(format!("{}\n", header.join("\t")).as_bytes())
            .unwrap_or_default();
        for row in &self.rows {
            tw.write(format!("{}\n", row.to_strings().join("\t")).as_bytes())
                .unwrap_or_default();
        }
        tw.flush().expect("TabWriter to flush");
        let written = String::from_utf8(tw.into_inner().unwrap()).unwrap();
        write!(f, "{written}")
    }
}

// Selects and Filters

pub type QueryParams = IndexMap<String, String>;

pub enum Format {
    Html,
    Json,
    PrettyJson,
    Default,
}

impl Display for Format {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        // TODO: This should be factored out.
        let result = match self {
            Format::Html => ".html",
            Format::Json => ".json",
            Format::PrettyJson => ".pretty.json",
            Format::Default => "",
        };
        write!(f, "{result}")
    }
}

impl TryFrom<&String> for Format {
    fn try_from(path: &String) -> Result<Self> {
        let path = path.to_lowercase();
        let format = if path.ends_with(".pretty.json") {
            Format::PrettyJson
        } else if path.ends_with(".json") {
            Format::Json
        } else if path.ends_with(".html") || path.ends_with(".htm") {
            Format::Html
        } else if path.contains(".") {
            return Err(
                RelatableError::FormatError(format!("Unknown format for path {path}")).into(),
            );
        } else {
            Format::Default
        };
        Ok(format)
    }

    type Error = anyhow::Error;
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum Filter {
    Like { column: String, value: JsonValue },
    Equal { column: String, value: JsonValue },
    NotEqual { column: String, value: JsonValue },
    GreaterThan { column: String, value: JsonValue },
    GreaterThanOrEqual { column: String, value: JsonValue },
    LessThan { column: String, value: JsonValue },
    LessThanOrEqual { column: String, value: JsonValue },
    Is { column: String, value: JsonValue },
    IsNot { column: String, value: JsonValue },
    In { column: String, value: JsonValue },
    NotIn { column: String, value: JsonValue },
}

fn render_in_not_in<S: Into<String>>(
    lhs: S,
    options: &Vec<JsonValue>,
    positive: bool,
) -> Result<String> {
    let negation;
    if !positive {
        negation = " NOT";
    } else {
        negation = "";
    }

    let mut values = vec![];
    let mut is_string_list = false;
    for (i, option) in options.iter().enumerate() {
        match option {
            JsonValue::String(s) => {
                if i == 0 {
                    is_string_list = true;
                } else if !is_string_list {
                    return Err(RelatableError::InputError(format!(
                        "{:?} contains both text and numeric types.",
                        options
                    ))
                    .into());
                }
                let value = unquote(s).unwrap_or(s.clone());
                values.push(format!("'{value}'"))
            }
            JsonValue::Number(n) => {
                if i == 0 {
                    is_string_list = false;
                } else if is_string_list {
                    return Err(RelatableError::InputError(format!(
                        "{:?} contains both text and numeric types.",
                        options
                    ))
                    .into());
                }
                values.push(format!("{n}"))
            }
            _ => {
                return Err(RelatableError::InputError(format!(
                    "{:?} is not an array of strings or numbers.",
                    options
                ))
                .into())
            }
        };
    }
    let value_list = format!("({})", values.join(", "));
    let filter_sql = format!("{}{} IN {}", lhs.into(), negation, value_list);
    Ok(filter_sql)
}

impl Filter {
    pub fn parts(&self) -> (String, String, JsonValue) {
        let (column, operator, value) = match self {
            Filter::Like { column, value } => (column, "like", value),
            Filter::Equal { column, value } => (column, "eq", value),
            Filter::NotEqual { column, value } => (column, "not_eq", value),
            Filter::GreaterThan { column, value } => (column, "gt", value),
            Filter::GreaterThanOrEqual { column, value } => (column, "gte", value),
            Filter::LessThan { column, value } => (column, "lt", value),
            Filter::LessThanOrEqual { column, value } => (column, "lte", value),
            Filter::Is { column, value } => (column, "is", value),
            Filter::IsNot { column, value } => (column, "is_not", value),
            Filter::In { column, value } => (column, "in", value),
            Filter::NotIn { column, value } => (column, "not_in", value),
        };
        (column.to_string(), operator.to_string(), json!(value))
    }

    pub fn to_url(&self) -> Result<String> {
        fn handle_string_value(token: &str) -> String {
            let reserved = vec![':', ',', '.', '(', ')'];
            if token.chars().all(char::is_numeric) || reserved.iter().any(|&c| token.contains(c)) {
                format!("\"{}\"", token)
            } else {
                token.to_string()
            }
        }

        let (_, operator, value) = self.parts();

        let rhs = match &value {
            JsonValue::String(s) => handle_string_value(&s),
            JsonValue::Number(n) => format!("{}", n),
            JsonValue::Array(v) => {
                let mut list = vec![];
                for item in v {
                    match item {
                        JsonValue::String(s) => {
                            list.push(handle_string_value(&s));
                        }
                        JsonValue::Number(n) => list.push(n.to_string()),
                        _ => {
                            return Err(RelatableError::DataError(format!(
                                "Not all list items in {:?} are strings or numbers.",
                                v
                            ))
                            .into());
                        }
                    };
                }
                format!("({})", list.join(","))
            }
            _ => {
                return Err(RelatableError::DataError(format!(
                    "RHS of Filter: {:?} is not a string, number, or list",
                    self
                ))
                .into());
            }
        };

        Ok(format!("{operator}.{rhs}"))
    }

    pub fn to_sqlite(&self) -> Result<String> {
        // TODO: This should be factored out.
        fn json_to_string(value: &JsonValue) -> String {
            match value {
                JsonValue::Null => "NULL".to_string(),
                JsonValue::Bool(value) => value.to_string(),
                JsonValue::Number(value) => value.to_string(),
                JsonValue::String(value) => format!("'{value}'"),
                JsonValue::Array(value) => format!("'{value:?}'"),
                JsonValue::Object(value) => format!("'{value:?}'"),
            }
        }
        match self {
            Filter::Like { column, value } => {
                let value = json_to_string(&value);
                let value = value.replace("*", "%");
                Ok(format!(r#""{column}" LIKE {value}"#))
            }
            Filter::Equal { column, value } => {
                let value = json_to_string(&value);
                Ok(format!(r#""{column}" = {value}"#))
            }
            Filter::NotEqual { column, value } => {
                let value = json_to_string(&value);
                Ok(format!(r#""{column}" <> {value}"#))
            }
            Filter::GreaterThan { column, value } => {
                let value = json_to_string(&value);
                Ok(format!(r#""{column}" > {value}"#))
            }
            Filter::GreaterThanOrEqual { column, value } => {
                let value = json_to_string(&value);
                Ok(format!(r#""{column}" >= {value}"#))
            }
            Filter::LessThan { column, value } => {
                let value = json_to_string(&value);
                Ok(format!(r#""{column}" < {value}"#))
            }
            Filter::LessThanOrEqual { column, value } => {
                let value = json_to_string(&value);
                Ok(format!(r#""{column}" <= {value}"#))
            }
            Filter::Is { column, value } => {
                // Note that we are presupposing SQLite syntax which is not universal for IS:
                let value = json_to_string(&value);
                Ok(format!(r#""{column}" IS {value}"#))
            }
            Filter::IsNot { column, value } => {
                // Note that we are presupposing SQLite syntax which is not universal for IS:
                let value = json_to_string(&value);
                Ok(format!(r#""{column}" IS NOT {value}"#))
            }
            Filter::In { column, value } => {
                if let JsonValue::Array(values) = value {
                    let filter_str = match render_in_not_in(column, values, true) {
                        Err(e) => {
                            return Err(RelatableError::DataError(format!(
                                "Error rendering 'in' filter: {e}"
                            ))
                            .into());
                        }
                        Ok(filter_str) => filter_str,
                    };
                    Ok(format!("{filter_str}"))
                } else {
                    Err(RelatableError::DataError(format!("Invalid 'in' value: {value}")).into())
                }
            }
            Filter::NotIn { column, value } => {
                if let JsonValue::Array(values) = value {
                    let filter_str = match render_in_not_in(column, values, false) {
                        Err(e) => {
                            return Err(RelatableError::DataError(format!(
                                "Error rendering 'not in' filter: {e}"
                            ))
                            .into());
                        }
                        Ok(filter_str) => filter_str,
                    };
                    Ok(format!("{filter_str}"))
                } else {
                    Err(
                        RelatableError::DataError(format!("Invalid 'not in' value: {value}"))
                            .into(),
                    )
                }
            }
        }
    }
}

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct Select {
    pub table_name: String,
    pub view_name: String,
    pub limit: usize,
    pub offset: usize,
    pub filters: Vec<Filter>,
    pub order_by: Vec<(String, Order)>,
}

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub enum Order {
    #[default]
    ASC,
    DESC,
}

impl Select {
    pub fn from_path_and_query(rltbl: &Relatable, path: &str, query_params: &QueryParams) -> Self {
        let table_name = path.split(".").next().unwrap_or_default().to_string();
        let mut query_params = query_params.clone();
        let mut filters = Vec::new();
        let mut order_by = Vec::new();

        let limit: usize = query_params
            .get("limit")
            .and_then(|x| x.parse::<usize>().ok())
            .unwrap_or(rltbl.default_limit)
            .min(rltbl.max_limit);
        let offset: usize = query_params
            .get("offset")
            .and_then(|x| x.parse::<usize>().ok())
            .unwrap_or_default();
        if let Some(order) = query_params.get("order") {
            for item in order.split(",") {
                if item.ends_with(".asc") {
                    let column = item.replace(".asc", "");
                    order_by.push((column, Order::ASC));
                } else if item.ends_with(".desc") {
                    let column = item.replace(".desc", "");
                    order_by.push((column, Order::DESC));
                } else {
                    order_by.push((item.to_string(), Order::ASC));
                }
            }
        }

        query_params.shift_remove("limit");
        query_params.shift_remove("offset");
        query_params.shift_remove("order");

        for (column, pattern) in query_params {
            if pattern.starts_with("like.") {
                let column = column.to_string();
                let value = &pattern.replace("like.", "");
                match serde_json::from_str(value) {
                    Ok(value) => filters.push(Filter::Like { column, value }),
                    Err(_) => filters.push(Filter::Like {
                        column,
                        value: JsonValue::String(value.to_string()),
                    }),
                }
            } else if pattern.starts_with("eq.") {
                let column = column.to_string();
                let value = &pattern.replace("eq.", "");
                match serde_json::from_str(value) {
                    Ok(value) => filters.push(Filter::Equal { column, value }),
                    Err(_) => filters.push(Filter::Equal {
                        column,
                        value: JsonValue::String(value.to_string()),
                    }),
                }
            } else if pattern.starts_with("not_eq.") {
                let column = column.to_string();
                let value = &pattern.replace("not_eq.", "");
                match serde_json::from_str(value) {
                    Ok(value) => filters.push(Filter::NotEqual { column, value }),
                    Err(_) => filters.push(Filter::NotEqual {
                        column,
                        value: JsonValue::String(value.to_string()),
                    }),
                }
            } else if pattern.starts_with("gt.") {
                let column = column.to_string();
                let value = &pattern.replace("gt.", "");
                match serde_json::from_str(value) {
                    Ok(value) => filters.push(Filter::GreaterThan { column, value }),
                    Err(_) => filters.push(Filter::GreaterThan {
                        column,
                        value: JsonValue::String(value.to_string()),
                    }),
                }
            } else if pattern.starts_with("gte.") {
                let column = column.to_string();
                let value = &pattern.replace("gte.", "");
                match serde_json::from_str(value) {
                    Ok(value) => filters.push(Filter::GreaterThanOrEqual { column, value }),
                    Err(_) => filters.push(Filter::GreaterThanOrEqual {
                        column,
                        value: JsonValue::String(value.to_string()),
                    }),
                }
            } else if pattern.starts_with("lt.") {
                let column = column.to_string();
                let value = &pattern.replace("lt.", "");
                match serde_json::from_str(value) {
                    Ok(value) => filters.push(Filter::LessThan { column, value }),
                    Err(_) => filters.push(Filter::LessThan {
                        column,
                        value: JsonValue::String(value.to_string()),
                    }),
                }
            } else if pattern.starts_with("lte.") {
                let column = column.to_string();
                let value = &pattern.replace("lte.", "");
                match serde_json::from_str(value) {
                    Ok(value) => filters.push(Filter::LessThanOrEqual { column, value }),
                    Err(_) => filters.push(Filter::LessThanOrEqual {
                        column,
                        value: JsonValue::String(value.to_string()),
                    }),
                }
            } else if pattern.starts_with("is.") {
                let column = column.to_string();
                let value = pattern.replace("is.", "");
                match value.to_lowercase().as_str() {
                    "null" => filters.push(Filter::Is {
                        column,
                        value: JsonValue::Null,
                    }),
                    _ => match serde_json::from_str(&value) {
                        Ok(value) => filters.push(Filter::Is { column, value }),
                        Err(_) => tracing::warn!("invalid 'is' filter value {pattern}"),
                    },
                };
            } else if pattern.starts_with("is_not.") {
                let column = column.to_string();
                let value = pattern.replace("is_not.", "");
                match value.to_lowercase().as_str() {
                    "null" => filters.push(Filter::IsNot {
                        column,
                        value: JsonValue::Null,
                    }),
                    _ => match serde_json::from_str(&value) {
                        Ok(value) => filters.push(Filter::IsNot { column, value }),
                        Err(_) => tracing::warn!("invalid 'is_not' filter value {pattern}"),
                    },
                };
            } else if pattern.starts_with("in.") {
                let column = column.to_string();
                let separator = Regex::new(r"\s*,\s*").unwrap();
                let values = pattern.replace("in.", "");
                let values = match values.strip_prefix("(").and_then(|s| s.strip_suffix(")")) {
                    None => {
                        tracing::warn!("invalid 'in' filter value {pattern}");
                        ""
                    }
                    Some(s) => s,
                };
                let values = separator
                    .split(values)
                    .map(|v| serde_json::from_str::<JsonValue>(v).unwrap_or(json!(v.to_string())))
                    .collect::<Vec<_>>();
                filters.push(Filter::In {
                    column,
                    value: json!(values),
                })
            } else if pattern.starts_with("not_in.") {
                let column = column.to_string();
                let separator = Regex::new(r"\s*,\s*").unwrap();
                let values = pattern.replace("not_in.", "");
                let values = match values.strip_prefix("(").and_then(|s| s.strip_suffix(")")) {
                    None => {
                        tracing::warn!("invalid 'not_in' filter value {pattern}");
                        ""
                    }
                    Some(s) => s,
                };
                let values = separator
                    .split(values)
                    .map(|v| serde_json::from_str::<JsonValue>(v).unwrap_or(json!(v.to_string())))
                    .collect::<Vec<_>>();
                filters.push(Filter::NotIn {
                    column,
                    value: json!(values),
                })
            }
        }
        Self {
            table_name,
            limit,
            offset,
            order_by,
            filters,
            ..Default::default()
        }
    }

    pub fn order_by(mut self, column: &str) -> Self {
        self.order_by = vec![(column.to_string(), Order::ASC)];
        self
    }

    pub fn limit(mut self, limit: &usize) -> Self {
        self.limit = *limit;
        self
    }

    pub fn offset(mut self, offset: &usize) -> Self {
        self.offset = *offset;
        self
    }

    pub fn filters(mut self, filters: &Vec<String>) -> Result<Self> {
        let like = Regex::new(r#"^(\w+)\s*~=\s*"?(\w+)"?$"#).unwrap();
        let eq = Regex::new(r#"^(\w+)\s*=\s*"?(\w+)"?$"#).unwrap();
        let not_eq = Regex::new(r#"^(\w+)\s*!=\s*"?(\w+)"?$"#).unwrap();
        let gt = Regex::new(r"^(\w+)\s*>\s*(\w+)$").unwrap();
        let gte = Regex::new(r"^(\w+)\s*>=\s*(\w+)$").unwrap();
        let lt = Regex::new(r"^(\w+)\s*<\s*(\w+)$").unwrap();
        let lte = Regex::new(r"^(\w+)\s*<=\s*(\w+)$").unwrap();
        let is = Regex::new(r#"^(\w+)\s+(IS|is)\s+"?(\w+)"?$"#).unwrap();
        let is_not = Regex::new(r#"^(\w+)\s+(IS NOT|is not)\s+"?(\w+)"?$"#).unwrap();
        let is_in = Regex::new(r#"^(\w+)\s+(IN|in)\s+\((\w+(,\s*\w+)*)\)$"#).unwrap();
        let is_not_in = Regex::new(r#"^(\w+)\s+(NOT IN|not in)\s+\((\w+(,\s*\w+)*)\)$"#).unwrap();
        // Used for text types:
        let maybe_quote_value = |value: &str| -> Result<JsonValue> {
            if value.starts_with("\"") {
                let value = serde_json::from_str(&value)?;
                Ok(value)
            } else {
                let value = serde_json::from_str(&format!(r#""{value}""#))?;
                Ok(value)
            }
        };
        for filter in filters {
            if like.is_match(&filter) {
                let captures = eq.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = maybe_quote_value(&value)?;
                self.filters.push(Filter::Like { column, value });
            } else if eq.is_match(&filter) {
                let captures = eq.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = maybe_quote_value(&value)?;
                self.filters.push(Filter::Equal { column, value });
            } else if not_eq.is_match(&filter) {
                let captures = not_eq.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = maybe_quote_value(&value)?;
                self.filters.push(Filter::NotEqual { column, value });
            } else if gt.is_match(&filter) {
                let captures = gt.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = serde_json::from_str(&value)?;
                self.filters.push(Filter::GreaterThan { column, value });
            } else if gte.is_match(&filter) {
                let captures = gte.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = serde_json::from_str(&value)?;
                self.filters
                    .push(Filter::GreaterThanOrEqual { column, value });
            } else if lt.is_match(&filter) {
                let captures = lt.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = serde_json::from_str(&value)?;
                self.filters.push(Filter::LessThan { column, value });
            } else if lte.is_match(&filter) {
                let captures = lte.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = serde_json::from_str(&value)?;
                self.filters.push(Filter::LessThanOrEqual { column, value });
            } else if is.is_match(&filter) {
                let captures = is.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(3).unwrap().as_str();
                let value = match value.to_lowercase().as_str() {
                    "null" => JsonValue::Null,
                    _ => maybe_quote_value(&value)?,
                };
                self.filters.push(Filter::Is { column, value });
            } else if is_not.is_match(&filter) {
                let captures = is_not.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(3).unwrap().as_str();
                let value = match value.to_lowercase().as_str() {
                    "null" => JsonValue::Null,
                    _ => maybe_quote_value(&value)?,
                };
                self.filters.push(Filter::IsNot { column, value });
            } else if is_in.is_match(&filter) {
                let captures = is_in.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let values = &captures.get(3).unwrap().as_str();
                let separator = Regex::new(r"\s*,\s*").unwrap();
                let values = separator
                    .split(values)
                    .map(|v| serde_json::from_str::<JsonValue>(v).unwrap_or(json!(v.to_string())))
                    .collect::<Vec<_>>();
                self.filters.push(Filter::In {
                    column,
                    value: json!(values),
                });
            } else if is_not_in.is_match(&filter) {
                let captures = is_not_in.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let values = &captures.get(3).unwrap().as_str();
                let separator = Regex::new(r"\s*,\s*").unwrap();
                let values = separator
                    .split(values)
                    .map(|v| serde_json::from_str::<JsonValue>(v).unwrap_or(json!(v.to_string())))
                    .collect::<Vec<_>>();
                self.filters.push(Filter::NotIn {
                    column,
                    value: json!(values),
                });
            } else {
                return Err(RelatableError::ConfigError(format!("invalid filter {filter}")).into());
            }
        }
        Ok(self)
    }

    pub fn like<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::Like {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn eq<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::Equal {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn not_eq<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::NotEqual {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn gt<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::GreaterThan {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn gte<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::GreaterThanOrEqual {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn lt<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::LessThan {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn lte<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::LessThanOrEqual {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn is<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::Is {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn is_not<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::IsNot {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn is_in<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::In {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn is_not_in<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::NotIn {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn to_sqlite(&self) -> Result<(String, Vec<JsonValue>)> {
        tracing::debug!("to_sqlite: {self:?}");
        let table = &self.view_name;
        let mut lines = Vec::new();
        lines.push("SELECT *,".to_string());
        // WARN: The _total count should probably be optional.
        lines.push("  COUNT(1) OVER() AS _total,".to_string());
        lines.push(format!(
            r#"  (SELECT MAX(change_id) FROM history
                   WHERE "table" = ?
                     AND "row" = _id
                 ) AS _change_id"#
        ));
        lines.push(format!(r#"FROM "{}""#, table));
        for (i, filter) in self.filters.iter().enumerate() {
            let keyword = if i == 0 { "WHERE" } else { "  AND" };
            lines.push(format!("{keyword} {filter}", filter = filter.to_sqlite()?));
        }
        if self.order_by.len() == 0 {
            lines.push(format!("ORDER BY _order ASC"));
        }
        for (column, order) in &self.order_by {
            lines.push(format!(r#"ORDER BY "{column}" {order:?}"#));
        }
        if self.limit > 0 {
            lines.push(format!("LIMIT {}", self.limit));
        }
        if self.offset > 0 {
            lines.push(format!("OFFSET {}", self.offset));
        }
        Ok((lines.join("\n"), vec![json!(table)]))
    }

    pub fn to_params(&self) -> Result<JsonMap<String, JsonValue>> {
        if self.table_name.is_empty() {
            return Err(RelatableError::InputError(
                "Missing required field: `table` in to_sql()".to_string(),
            )
            .into());
        }

        let mut params = JsonMap::new();
        if self.filters.len() > 0 {
            for filter in &self.filters {
                let column = match &filter {
                    Filter::Like { column, value: _ }
                    | Filter::Equal { column, value: _ }
                    | Filter::NotEqual { column, value: _ }
                    | Filter::GreaterThan { column, value: _ }
                    | Filter::GreaterThanOrEqual { column, value: _ }
                    | Filter::LessThan { column, value: _ }
                    | Filter::LessThanOrEqual { column, value: _ }
                    | Filter::Is { column, value: _ }
                    | Filter::IsNot { column, value: _ }
                    | Filter::In { column, value: _ }
                    | Filter::NotIn { column, value: _ } => column,
                };

                let column = unquote(&column).unwrap_or(column.to_string());
                if let Err(e) = is_simple(&column) {
                    return Err(RelatableError::InputError(format!(
                        "While reading filters, got error: {}",
                        e
                    ))
                    .into());
                }
                params.insert(column, format!("{}", filter.to_url()?).into());
            }
        }
        if self.limit > 0 {
            params.insert("limit".into(), self.limit.into());
        }
        if self.offset > 0 {
            params.insert("offset".into(), self.offset.into());
        }
        Ok(params)
    }

    pub fn to_url(&self, base: &str, format: &Format) -> Result<String> {
        let table_name = unquote(&self.table_name).unwrap_or(self.table_name.to_string());
        if let Err(e) = is_simple(&table_name) {
            return Err(RelatableError::InputError(format!(
                "While reading table name, got error: {}",
                e
            ))
            .into());
        }
        let table_name = format!("{base}/{table_name}{format}");

        let params = &self.to_params()?.clone();
        if params.len() > 0 {
            let mut parts = vec![];
            for (column, value) in params.iter() {
                let s = match value {
                    serde_json::Value::String(s) => s.as_str().into(),
                    _ => format!("{}", value),
                };
                parts.push(format!("{column}={s}"));
            }
            Ok(format!("{}?{}", table_name, parts.join("&")))
        } else {
            Ok(table_name.to_string())
        }
    }
}

// Web Site Stuff

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Site {
    title: String,
    root: String,
    editable: bool,
    user: Account,
    users: IndexMap<String, UserCursor>,
    tables: IndexMap<String, Table>,
}

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct Account {
    name: String,
    color: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Cursor {
    table: String,
    row: usize,
    column: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct UserCursor {
    name: String,
    color: String,
    cursor: Cursor,
    datetime: String,
}
