//! # rltbl/relatable
//!
//! This is relatable (rltbl::core).

use crate::{self as rltbl};
use rltbl::{
    git,
    sql::{
        is_simple, json_to_string, DbActiveConnection, DbConnection, DbKind, DbTransaction,
        JsonRow, VecInto, MAX_PARAMS,
    },
};

use anyhow::Result;
use csv::{QuoteStyle, ReaderBuilder, WriterBuilder};
use enquote::unquote;
use indexmap::IndexMap;
use minijinja::{path_loader, Environment};
use regex::Regex;
use serde::{Deserialize, Serialize};
use serde_json::{from_str, json, to_value, Map as JsonMap, Value as JsonValue};
use std::{
    collections::HashMap, env, fmt::Display, fs::File, io::Write, path::Path as FilePath,
    str::FromStr,
};
use tabwriter::TabWriter;

pub static RLTBL_DEFAULT_DB: &str = ".relatable/relatable.db";

#[derive(Debug)]
pub enum RelatableError {
    /// An error in the configuration of a ChangeSet:
    ChangeError(String),
    /// An error in the Relatable configuration:
    ConfigError(String),
    /// An error that occurred while reading or writing to a CSV/TSV:
    // CsvError(csv::Error),
    /// An error involving the data:
    DataError(String),
    /// An error generated by the underlying database:
    // DatabaseError(sqlx::Error),

    /// An error that occurred while interacting with git
    GitError(String),
    /// An error generated when the database is missing
    InitError(String),
    /// An error from an unsupported format
    FormatError(String),
    /// An error in the inputs to a function:
    InputError(String),
    /// An error that occurred while reading/writing to stdio:
    IOError(std::io::Error),
    /// An error when a record cannot be found.
    MissingError(String),
    /// An error that occurred while serialising or deserialising to/from JSON:
    SerdeJsonError(serde_json::Error),
    /// An error that occurred while parsing a regex:
    RegexError(regex::Error),
    /// An error when a table cannot be found.
    TableError(String),
    /// An error that occurred because of a user's action
    UserError(String),
}

impl std::fmt::Display for RelatableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

pub static MOVE_INTERVAL: usize = 1000;
pub static MAX_CONTEXT: usize = 1000;

impl std::error::Error for RelatableError {}

#[derive(Debug)]
pub struct Relatable {
    pub root: String,
    pub readonly: bool,
    pub connection: DbConnection,
    // pub minijinja: Environment<'static>,
    pub default_limit: usize,
    pub max_limit: usize,
}

impl Relatable {
    pub async fn connect(path: Option<&str>) -> Result<Self> {
        let root = std::env::var("RLTBL_ROOT").unwrap_or_default();
        // Set up database connection.
        let readonly = match std::env::var("RLTBL_READONLY") {
            Ok(value) if value.to_lowercase() != "false" => true,
            _ => false,
        };
        let path = match path {
            None => RLTBL_DEFAULT_DB,
            Some(path) => path,
        };
        let file = FilePath::new(path);
        if !file.exists() {
            return Err(RelatableError::InitError(
                "First create a database with `rltbl init`".into(),
            )
            .into());
        }
        let (connection, _) = DbConnection::connect(path).await?;
        Ok(Self {
            root,
            readonly,
            connection,
            // minijinja: env,
            default_limit: 100,
            max_limit: 1000,
        })
    }

    pub async fn init(force: &bool, path: Option<&str>) -> Result<Self> {
        let path = match path {
            None => RLTBL_DEFAULT_DB,
            Some(path) => path,
        };
        let dir = FilePath::new(path)
            .parent()
            .expect("parent should be defined");
        if !dir.exists() {
            std::fs::create_dir_all(&dir).unwrap();
            tracing::info!("Created '{dir:?}' directory");
        }
        let file = FilePath::new(path);
        if file.exists() {
            if *force {
                std::fs::remove_file(&file).unwrap();
                tracing::info!("Removed '{file:?}' file");
            } else {
                return Err(RelatableError::InitError(format!(
                    "File {file:?} already exists. Use --force to overwrite"
                ))
                .into());
            }
        }
        File::create(path)?;

        let rltbl = Relatable::connect(None).await?;

        // Create a simple key-value cache table.
        let sql = r#"CREATE TABLE "cache" (
          "key" TEXT PRIMARY KEY,
          "value" TEXT
        )"#;
        rltbl.connection.query(sql, None).await.unwrap();

        // Create the internal rltbl tables:
        let sql = r#"CREATE TABLE "table" (
          _id INTEGER PRIMARY KEY AUTOINCREMENT,
          _order INTEGER UNIQUE,
          "table" TEXT UNIQUE,
          "path" TEXT
        )"#;
        rltbl.connection.query(sql, None).await.unwrap();

        let sql = format!(
            r#"CREATE TRIGGER "table_order"
                 AFTER INSERT ON "table"
                 WHEN NEW._order IS NULL
                 BEGIN
                   UPDATE "table" SET _order = ({MOVE_INTERVAL} * NEW._id)
                   WHERE _id = NEW._id;
                 END"#
        );
        rltbl.connection.query(&sql, None).await.unwrap();

        let sql = r#"CREATE TABLE "user" (
          "name" TEXT PRIMARY KEY,
          "color" TEXT,
          "cursor" TEXT,
          "datetime" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )"#;
        rltbl.connection.query(sql, None).await.unwrap();

        let sql = r#"CREATE TABLE "change" (
          change_id INTEGER PRIMARY KEY AUTOINCREMENT,
          "datetime" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          "user" TEXT NOT NULL,
          "action" TEXT NOT NULL,
          "table" TEXT NOT NULL,
          "description" TEXT,
          "content" TEXT,
          FOREIGN KEY ("user") REFERENCES user("name")
        )"#;
        rltbl.connection.query(sql, None).await.unwrap();

        let sql = r#"CREATE TABLE "history" (
          history_id INTEGER PRIMARY KEY AUTOINCREMENT,
          change_id INTEGER NOT NULL,
          "table" TEXT NOT NULL,
          "row" INTEGER NOT NULL,
          "before" TEXT,
          "after" TEXT,
          FOREIGN KEY ("change_id") REFERENCES change("change_id"),
          FOREIGN KEY ("table") REFERENCES "table"("table")
        )"#;
        rltbl.connection.query(sql, None).await.unwrap();

        let sql = r#"CREATE TABLE "message" (
          "message_id" INTEGER PRIMARY KEY AUTOINCREMENT,
          "added_by" TEXT,
          "table" TEXT NOT NULL,
          "row" INTEGER NOT NULL,
          "column" TEXT NOT NULL,
          "value" TEXT,
          "level" TEXT,
          "rule" TEXT,
          "message" TEXT,
          FOREIGN KEY ("table") REFERENCES "table"("table")
        )"#;
        rltbl.connection.query(sql, None).await.unwrap();

        Ok(rltbl)
    }

    pub fn render<T: Serialize>(&self, template: &str, context: T) -> Result<String> {
        // TODO: Optionally we should set up the environment once and store it,
        // but during development it's very convenient to rebuild every time.
        let mut env = Environment::new();

        // Load default template strings at compile time.
        let templates = IndexMap::from([
            ("page.html", include_str!("templates/page.html")),
            ("table.html", include_str!("templates/table.html")),
            ("row_menu.html", include_str!("templates/row_menu.html")),
            (
                "column_menu.html",
                include_str!("templates/column_menu.html"),
            ),
            ("cell_menu.html", include_str!("templates/cell_menu.html")),
        ]);

        // Load templates dynamically if src/templates/ exists,
        // otherwise use strings from compile time.
        // TODO: This should be a configuration option.
        let dir = "src/rltbl-templates/";
        if FilePath::new(dir).is_dir() {
            env.set_loader(path_loader(dir));
        };
        for (name, content) in templates {
            match env.get_template(name) {
                Ok(_) => (),
                Err(_) => env.add_template(name, content).unwrap(),
            }
        }

        env.get_template(template)?
            .render(context)
            .map_err(|e| e.into())
    }

    pub fn from(&self, table_name: &str) -> Select {
        Select {
            table_name: table_name.to_string(),
            view_name: table_name.to_string(),
            limit: self.default_limit,
            ..Default::default()
        }
    }

    pub async fn fetch_all_columns(&self, table: &str) -> Result<(Vec<Column>, Vec<Column>)> {
        // Begin by converting the contents of the column table to a HashMap. In case the
        // (optional) column table does not exist in the db, return an empty map.
        let sql = match self.connection.kind() {
            DbKind::Postgres => r#"SELECT * FROM "column" WHERE "table" = $1"#,
            DbKind::Sqlite => r#"SELECT * FROM "column" WHERE "table" = ?"#,
        };
        let params = json!([table]);
        let mut columns_config = HashMap::new();
        for json_col in self
            .connection
            .query(&sql, Some(&params))
            .await
            .unwrap_or(vec![])
        {
            columns_config.insert(json_col.get_string("column")?, json_col);
        }

        // Declare a closure to retrieve a particular column attribute from `columns_config`:
        let get_column_attribute = |column: &str, attribute: &str| -> Option<String> {
            columns_config
                .get(column)
                .and_then(|col| match col.get_string(attribute).ok() {
                    None => None,
                    Some(attribute) if attribute == "" => None,
                    Some(attribute) => Some(attribute),
                })
        };

        // Fetch the columns corresponding to `table` from the database's metadata:
        let sql = match self.connection.kind() {
            DbKind::Postgres => format!(
                r#"SELECT column_name AS name FROM information_schema.columns WHERE table_schema = 'hcckb' AND table_name = '{table}' ORDER BY ordinal_position"#
            ),
            DbKind::Sqlite => {
                format!(r#"SELECT "name" FROM pragma_table_info("{table}") ORDER BY "cid""#)
            }
        };
        let mut columns = vec![];
        let mut meta_columns = vec![];
        for column in self.connection.query(&sql, None).await? {
            // Decorate the column using the information from the column table that we collected
            // above:
            match column.get_string("name")? {
                name if name.starts_with("_") => meta_columns.push(Column {
                    name,
                    table: table.to_string(),
                    label: None,
                    description: None,
                }),
                name => columns.push(Column {
                    label: get_column_attribute(&name.as_str(), "label"),
                    description: get_column_attribute(&name.as_str(), "description"),
                    name,
                    table: table.to_string(),
                }),
            };
        }
        if columns.is_empty() && meta_columns.is_empty() {
            return Err(
                RelatableError::DataError(format!("No db columns found for: {table}")).into(),
            );
        }
        tracing::debug!(
            "Returning (columns: {columns:?}, meta_columns: {meta_columns:?} from \
             fetch_all_columns()"
        );
        Ok((columns, meta_columns))
    }

    pub async fn fetch_columns(&self, table_name: &str) -> Result<Vec<Column>> {
        Ok(self.fetch_all_columns(table_name).await?.0)
    }

    pub async fn count(&self, select: &Select) -> Result<usize> {
        tracing::debug!("COUNT: {select:?}");
        let (statement, params) = select.to_sqlite_count()?;
        tracing::debug!("SQL {statement}");
        let params = json!(params);
        let json_rows = self.connection.cache(&statement, Some(&params)).await?;
        match json_rows.get(0) {
            Some(json_row) => json_row.get_unsigned("count"),
            None => Ok(0),
        }
    }

    pub async fn fetch(&self, select: &Select) -> Result<ResultSet> {
        tracing::debug!("SELECT: {select:?}");
        let table = self.get_table(select.table_name.as_str()).await?;
        // let mut columns = table.ensure_view_created(self).await?;
        let (mut columns, _meta_columns) = self.fetch_all_columns(&select.table_name).await?;
        let mut select = select.clone();
        select.view_name = table.view.clone();
        let (statement, params) = select.to_sqlite()?;
        tracing::debug!("SQL {statement}");
        let params = json!(params);
        let json_rows = self.connection.query(&statement, Some(&params)).await?;
        let count = json_rows.len();
        tracing::info!("Received {count} rows.");
        // if count > 4 {
        //     tracing::debug!("The first 4 are: {:#?}", json_rows[..4].to_vec());
        // } else if count > 0 {
        //     tracing::debug!("They are: {json_rows:#?}");
        // }

        if select.select.len() > 0 {
            columns = columns
                .iter()
                .filter(|c| select.select.contains(&c.name))
                .map(|c| c.clone())
                .collect();
        }
        let rows: Vec<Row> = json_rows.clone().vec_into();

        let total = self.count(&select).await?;

        Ok(ResultSet {
            range: Range {
                count,
                total,
                start: select.offset + 1,
                end: select.offset + count,
            },
            select: select.clone(),
            table,
            columns,
            rows,
        })
    }

    pub async fn fetch_json_rows(&self, select: &Select) -> Result<Vec<JsonRow>> {
        let (statement, params) = select.to_sqlite()?;
        let params = json!(params);
        self.connection.query(&statement, Some(&params)).await
    }

    pub async fn load_table(&self, table: &str, path: &str) -> Result<()> {
        // Read the records from the given TSV file:
        let mut rdr = ReaderBuilder::new()
            .has_headers(false)
            .delimiter(b'\t')
            .from_reader(File::open(path).map_err(|err| {
                RelatableError::InputError(format!("Unable to open '{path}': {err}"))
            })?);
        let mut records = rdr.records();

        // Extract the headers from the first line of the file, which we will need for the CREATE
        // TABLE statement:
        let headers = {
            let headers = match records.next() {
                None => {
                    return Err(RelatableError::InputError(format!("'{path}' is empty")).into());
                }
                Some(record) => match record {
                    Err(err) => {
                        return Err(RelatableError::InputError(format!(
                            "Error reading from '{path}': {err}"
                        ))
                        .into());
                    }
                    Ok(headers) => headers.iter().map(|s| s.to_string()).collect::<Vec<_>>(),
                },
            };
            for header in &headers {
                if header.trim().is_empty() {
                    return Err(RelatableError::InputError(format!(
                        "One or more of the header fields is empty for table '{table}'"
                    ))
                    .into());
                }
            }
            headers
        };

        // Add an entry corresponding to the table being loaded to the table table:
        let sql = r#"INSERT INTO "table" ("table", "path") VALUES (?, ?)"#;
        let params = json!([table, path]);
        self.connection.query(&sql, Some(&params)).await?;
        tracing::debug!("Table {table} (path: {path}) added to table table");

        // Drop the trigger on the _order column first as a (small) performance optimization:
        let sql = format!(r#"DROP TRIGGER IF EXISTS "{table}_order""#);
        self.connection.query(&sql, None).await?;
        tracing::debug!("Dropped trigger on column {table}._order");

        // If the table doesn't already exist, create it now:
        let sql = format!(
            r#"CREATE TABLE IF NOT EXISTS "{table}" (
                 _id INTEGER PRIMARY KEY AUTOINCREMENT,
                 _order INTEGER UNIQUE, {other_column_defs}
            )"#,
            other_column_defs = headers
                .iter()
                .map(|header| format!(r#""{header}" TEXT"#))
                .collect::<Vec<_>>()
                .join(", ")
        );
        self.connection.query(&sql, None).await?;
        tracing::debug!("Table {table} (re)created");

        // Insert the data into the table:
        let mut columns = vec!["_id".to_string(), "_order".to_string()];
        columns.append(
            &mut headers
                .iter()
                .map(|k| format!(r#""{k}""#))
                .collect::<Vec<_>>(),
        );
        let placeholders = columns.iter().map(|_| "?").collect::<Vec<_>>();
        let columns = columns.join(", ");
        let placeholders = placeholders.join(", ");
        let mut id = 1;
        let mut order = id * MOVE_INTERVAL;
        let sql_first_part = format!(r#"INSERT INTO "{table}" ({columns}) VALUES "#);
        let mut sql_value_parts = vec![];
        let mut params = vec![];
        while let Some(row) = records.next() {
            let row = row.expect("Error processing row");
            // We add 2 here because of _id and _order:
            if (params.len() + row.len() + 2) >= MAX_PARAMS {
                let sql = format!(
                    "{sql_first_part} {sql_value_part}",
                    sql_value_part = sql_value_parts.join(", ")
                );
                let params_so_far = json!(params);
                self.connection.query(&sql, Some(&params_so_far)).await?;
                tracing::info!("{num_rows} rows loaded to table {table}", num_rows = id - 1);
                params.clear();
                sql_value_parts.clear();
            }
            sql_value_parts.push(format!("({placeholders})"));
            params.push(json!(id));
            params.push(json!(order));
            for value in row.iter() {
                params.push(json!(value));
            }
            id += 1;
            order += MOVE_INTERVAL;
        }
        if params.len() > 0 {
            let sql = format!(
                "{sql_first_part} {sql_value_part}",
                sql_value_part = sql_value_parts.join(", ")
            );
            let params = json!(params);
            self.connection.query(&sql, Some(&params)).await?;
        }

        tracing::info!("{num_rows} rows loaded to table {table}", num_rows = id - 1);

        // (Re)create the trigger on the _oder column:
        let sql = format!(
            r#"CREATE TRIGGER "{table}_order"
                 AFTER INSERT ON "{table}"
                 WHEN NEW._order IS NULL
                 BEGIN
                   UPDATE "{table}" SET _order = ({MOVE_INTERVAL} * NEW._id)
                   WHERE _id = NEW._id;
                 END"#
        );
        self.connection.query(&sql, None).await?;
        tracing::debug!("Trigger (re)created on table {table}");

        self.commit_to_git().await?;
        Ok(())
    }

    pub async fn save_all(&self, save_dir: Option<&str>) -> Result<()> {
        let sql = r#"SELECT "table", "path" FROM "table" WHERE "path" IS NOT NULL"#;
        let table_rows = self.connection.query(&sql, None).await?;
        for table_row in table_rows {
            let table = table_row.get_string("table")?;
            let path = match save_dir {
                Some(save_dir) => format!("{save_dir}/{table}.tsv"),
                None => table_row.get_string("path")?,
            };
            let mut writer = WriterBuilder::new()
                .delimiter(b'\t')
                .quote_style(QuoteStyle::Never)
                .from_path(path)?;

            let header_row = self
                .fetch_columns(&table)
                .await?
                .iter()
                .map(|c| c.name.to_string())
                .collect::<Vec<_>>();
            writer.write_record(header_row.clone())?;

            let sql = format!(
                r#"SELECT {columns} FROM "{table}" ORDER BY "_order""#,
                columns = header_row
                    .iter()
                    .map(|c| format!(r#""{c}""#))
                    .collect::<Vec<_>>()
                    .join(", ")
            );
            let data_rows = self.connection.query(&sql, None).await?;
            for data_row in data_rows {
                let values = {
                    let json_values = data_row.content.values();
                    let mut str_values = vec![];
                    for value in json_values {
                        match value.as_str() {
                            None => {
                                return Err(
                                    RelatableError::DataError("Not a string".to_string()).into()
                                );
                            }
                            Some(s) => str_values.push(s),
                        }
                    }
                    str_values
                };
                writer.write_record(values)?;
            }
        }

        Ok(())
    }

    pub async fn commit_to_git(&self) -> Result<()> {
        let author = match env::var("RLTBL_GIT_AUTHOR") {
            Err(err) => match err {
                env::VarError::NotPresent => {
                    tracing::info!("Not committing to git because RLTBL_GIT_AUTHOR not defined");
                    return Ok(());
                }
                _ => {
                    return Err(RelatableError::InputError(format!(
                        "Could not read from the environment: {err}"
                    ))
                    .into())
                }
            },
            Ok(author) => author,
        };
        tracing::info!("Committing to git on behalf of RLTBL_GIT_AUTHOR: '{author}'");

        // Save all the tables:
        self.save_all(None).await?;

        // Get the git status:
        let status = git::get_status()?;
        if status.behind != 0 {
            return Err(RelatableError::GitError(
                "Refusing to commit to a local repository that is behind the remote".to_string(),
            )
            .into());
        }

        // Possibly only amend the last commit, if it is by the same author and performed
        // on the same day:
        let (last_commit_author, days_ago) = git::get_last_commit_info()?;
        let is_amendment = (last_commit_author == author) && (days_ago < 1);

        // Stage any modified table files that have a path in the table table:
        let sql = r#"SELECT "path" FROM "table" WHERE "path" IS NOT NULL"#;
        let paths = self
            .connection
            .query(&sql, None)
            .await?
            .iter()
            .map(|row| row.get_string("path").expect("No 'path' found"))
            .collect::<Vec<_>>();
        git::add(&paths)?;

        // Finally, commit to git:
        git::commit("commit by rltbl", &author, is_amendment)?;
        Ok(())
    }

    fn _get_last_action_for_user(
        &self,
        tx: &mut DbTransaction<'_>,
        user: &str,
        action: &ChangeAction,
    ) -> Result<Option<(usize, ChangeSet)>> {
        let sql = r#"SELECT "change_id", "user", "table", "description", "content"
                     FROM "change"
                     WHERE "user" = ? AND "action" = ?
                     ORDER BY "change_id" DESC LIMIT 1"#;
        let params = json!([user, format!("{action}")]);
        let records = tx.query(&sql, Some(&params))?;
        match records.len() {
            0 => Ok(None),
            _ => {
                let change_id = records[0].get_unsigned("change_id")?;
                let user = records[0].get_string("user")?;
                let table = records[0].get_string("table")?;
                let description = records[0].get_string("description")?;
                let content = records[0].get_string("content")?;
                let changes = Change::many_from_str(&content)?;
                Ok(Some((
                    change_id,
                    ChangeSet {
                        action: *action,
                        table,
                        user,
                        description,
                        changes,
                    },
                )))
            }
        }
    }

    pub fn record_changes(&self, changeset: &ChangeSet, tx: &mut DbTransaction<'_>) -> Result<()> {
        let user = changeset.user.clone();
        let action = changeset.action.to_string();
        let table = changeset.table.clone();
        let description = changeset.description.clone();

        // Begin by getting the current last change_id for this user, which we may need to look
        // up previous values of the row's columns in the history table later:
        let old_change_id = match &changeset.action {
            ChangeAction::Undo => {
                let (change_id, _) = self
                    ._get_last_action_for_user(tx, &changeset.user, &ChangeAction::Do)?
                    .ok_or(RelatableError::DataError(
                        "No action for user found".to_string(),
                    ))?;
                Some(change_id)
            }
            ChangeAction::Redo => {
                let (change_id, _) = self
                    ._get_last_action_for_user(tx, &changeset.user, &ChangeAction::Undo)?
                    .ok_or(RelatableError::DataError(
                        "No undo for user found".to_string(),
                    ))?;
                Some(change_id)
            }
            ChangeAction::Do => None,
        };

        // Now write the current change, which will generate a new last change_id:
        let statement = r#"INSERT INTO change("user", "action", "table", "description", "content")
                           VALUES (?, ?, ?, ?, ?)
                           RETURNING change_id"#;
        let content = to_value(&changeset.changes).unwrap_or_default();
        let params = json!([user, action, table, description, content]);
        let change_id = tx.query_value(&statement, Some(&params))?;
        let change_id = change_id
            .ok_or(RelatableError::DataError(
                "Expected a change_id".to_string(),
            ))?
            .as_u64()
            .ok_or(RelatableError::DataError("Expected an integer".to_string()))?;

        for change in &changeset.changes {
            match change {
                Change::Update {
                    row,
                    column,
                    before,
                    after,
                } => {
                    let sql = r#"INSERT INTO "history"
                                 ("change_id", "table", "row", "before", "after")
                                 VALUES (?, ?, ?, ?, ?)
                                 RETURNING "history_id""#;
                    let before = json!({column: before}).to_string();
                    let after = json!({column: after}).to_string();
                    let params = json!([change_id, table, row, before, after]);
                    tx.query_value(&sql, Some(&params))?;
                }
                Change::Add { row, after: _ } => {
                    // If the row has just been newly added, it will be found in the table,
                    // otherwise we will use the old_change_id to look for it in the history
                    // table:
                    let json_row = match self._get_row(&table, *row, tx)? {
                        Some(json_row) => json_row,
                        None => match old_change_id {
                            Some(change_id) => {
                                let sql = r#"SELECT "before" FROM "history" WHERE "change_id" = ?"#;
                                let params = json!([change_id]);
                                let before = tx
                                    .query_one(&sql, Some(&params))?
                                    .ok_or(RelatableError::DataError(format!(
                                        "No history row found with change_id {change_id}"
                                    )))?
                                    .get_string("before")?;
                                let before = match serde_json::from_str::<JsonValue>(&before) {
                                    Err(err) => return Err(err.into()),
                                    Ok(JsonValue::Object(o)) => o,
                                    Ok(_) => {
                                        return Err(RelatableError::InputError(
                                            "The content parameter is not an object".to_string(),
                                        )
                                        .into());
                                    }
                                };
                                JsonRow { content: before }
                            }
                            None => {
                                return Err(RelatableError::DataError(format!(
                                    "Row {row} not found"
                                ))
                                .into())
                            }
                        },
                    };
                    let sql = format!(
                        r#"INSERT INTO "history"
                           ("change_id", "table", "row", "after")
                           VALUES (?, ?, ?, ?)
                           RETURNING "history_id""#
                    );
                    let json_row_str = json!(json_row.content).to_string();
                    let params = json!([change_id, table, row, json_row_str]);
                    tx.query_value(&sql, Some(&params))?;
                }
                Change::Move {
                    row,
                    from_after: _,
                    to_after: _,
                } => {
                    let sql = r#"INSERT INTO "history"
                                 ("change_id", "table", "row")
                                 VALUES (?, ?, ?)
                                 RETURNING "history_id""#;
                    let params = json!([change_id, table, row]);
                    tx.query_value(&sql, Some(&params))?;
                }
                Change::Delete { row, after: _ } => {
                    let json_row = match self._get_row(&table, *row, tx)? {
                        Some(json_row) => json_row,
                        None => {
                            // It must be there since we supposedly just added it, so if it is
                            // not found return an error.
                            return Err(
                                RelatableError::DataError(format!("Row {row} not found")).into()
                            );
                        }
                    };
                    let sql = format!(
                        r#"INSERT INTO "history"
                           ("change_id", "table", "row", "before")
                           VALUES (?, ?, ?, ?)
                           RETURNING "history_id""#
                    );
                    let json_row_str = json!(json_row.content).to_string();
                    let params = json!([change_id, table, row, json_row_str]);
                    tx.query_value(&sql, Some(&params))?;
                }
            };
        }
        Ok(())
    }

    pub async fn get_user(&self, username: &str) -> Account {
        let statement = format!(
            r#"SELECT "name", "color", "cursor", "datetime"
               FROM user WHERE name = '{username}' LIMIT 1"#
        );
        let user = self.connection.query_one(&statement, None).await;
        if let Ok(user) = user {
            if let Some(user) = user {
                return Account {
                    name: username.to_string(),
                    color: user.get_string("color").expect("No 'color' found"),
                };
            }
        }
        Account {
            ..Default::default()
        }
    }

    pub async fn get_users(&self) -> Result<IndexMap<String, UserCursor>> {
        let mut users = IndexMap::new();
        // let statement = format!(
        //     r#"SELECT "name", color", "cursor", "datetime" FROM user WHERE cursor IS NOT NULL
        //        AND "datetime" >= DATETIME('now', '-10 minutes')"#
        // );
        let statement = format!(
            r#"SELECT "name", "color", "cursor", "datetime" FROM user WHERE cursor IS NOT NULL"#
        );
        let rows = self.connection.query(&statement, None).await?;
        for row in rows {
            let name = row.get_string("name")?;
            if name.trim() == "" {
                continue;
            }
            users.insert(
                name.clone(),
                UserCursor {
                    name: name.clone(),
                    color: row.get_string("color")?,
                    cursor: from_str(&row.get_string("cursor")?)?,
                    datetime: row.get_string("datetime")?,
                },
            );
        }
        Ok(users)
    }

    pub async fn get_table(&self, table_name: &str) -> Result<Table> {
        let statement = match self.connection.kind() {
            DbKind::Postgres => r#"SELECT "table" FROM "table" WHERE "table" = $1"#,
            DbKind::Sqlite => r#"SELECT "table" FROM "table" WHERE "table" = ?"#,
        };
        let params = json!([table_name]);
        match self
            .connection
            .query_value(&statement, Some(&params))
            .await?
        {
            Some(_) => (),
            None => {
                return Err(RelatableError::TableError(format!(
                    "Table '{table_name}' is not in the 'table' table"
                ))
                .into())
            }
        }

        let statement = match self.connection.kind() {
            // WARN: This hardcodes the table_schema!
            DbKind::Postgres => {
                r#"SELECT table_name FROM information_schema.views WHERE table_schema = 'hcckb' AND table_name = $1"#
            }
            DbKind::Sqlite => r#"SELECT name FROM sqlite_master WHERE type = 'view' AND name = ?"#,
        };
        let mut view = format!("{table_name}_default_view");
        let params = json!([view]);
        let result = self
            .connection
            .query_value(&statement, Some(&params))
            .await?;
        if result.is_none() {
            view = String::from(table_name);
        }
        // tracing::warn!("FIND THE VIEW {view}");

        let statement = match self.connection.kind() {
            DbKind::Postgres => r#"SELECT max(change_id) FROM history WHERE "table" = $1"#,
            DbKind::Sqlite => r#"SELECT max(change_id) FROM history WHERE "table" = ?"#,
        };
        let params = json!([table_name]);
        let change_id = match self.connection.query_value(&statement, Some(&params)).await {
            Ok(value) => match value {
                Some(value) => value.as_u64().unwrap_or_default() as usize,
                None => 0,
            },
            Err(_) => 0,
        };
        let name = table_name.to_string();
        Ok(Table {
            name,
            view,
            change_id,
            ..Default::default()
        })
    }

    fn _get_table(&self, table_name: &str, tx: &mut DbTransaction<'_>) -> Result<Table> {
        let statement = r#"SELECT max(change_id) FROM history WHERE "table" = ?"#;
        let params = json!([table_name]);
        let change_id = match tx.query_value(&statement, Some(&params))? {
            Some(value) => value.as_u64().unwrap_or_default() as usize,
            None => 0,
        };
        Ok(Table {
            name: table_name.to_string(),
            change_id,
            ..Default::default()
        })
    }

    pub async fn get_tables(&self) -> Result<IndexMap<String, Table>> {
        let mut tables = IndexMap::new();
        let statement = format!(
            r#"SELECT "_id", "_order", "table", "path",
                 (SELECT max(change_id)
                  FROM history
                  WHERE history."table" = "table"."table"
                 ) AS _change_id
               FROM "table""#
        );

        let rows = self.connection.query(&statement, None).await?;
        for row in rows {
            let name = row.get_string("table")?;
            tables.insert(
                name.clone(),
                Table {
                    name: name.clone(),
                    change_id: row
                        .content
                        .get("_change_id")
                        .and_then(|i| i.as_u64())
                        .unwrap_or_default() as usize,
                    ..Default::default()
                },
            );
        }
        Ok(tables)
    }

    fn _get_row_order(&self, table: &str, row: usize, tx: &mut DbTransaction<'_>) -> Result<usize> {
        let sql = format!(r#"SELECT "_order" FROM "{table}" WHERE "_id" = ?"#,);
        let params = json!([row]);
        let rows = tx.query(&sql, Some(&params))?;
        if rows.len() == 0 {
            return Err(
                RelatableError::InputError(format!("No row {row} in table '{table}'")).into(),
            );
        }
        Ok(rows[0].get_unsigned("_order")?)
    }

    fn _get_previous_row_id(
        &self,
        table: &str,
        row: usize,
        tx: &mut DbTransaction<'_>,
    ) -> Result<usize> {
        let curr_row_order = self._get_row_order(table, row, tx)?;
        let sql = format!(
            r#"SELECT "_id" FROM "{table}" WHERE "_order" < ?
               ORDER BY "_order" DESC LIMIT 1"#,
        );
        let params = json!([curr_row_order]);
        let rows = tx.query(&sql, Some(&params))?;
        if rows.len() == 0 {
            Ok(0)
        } else {
            rows[0].get_unsigned("_id")
        }
    }

    fn _get_row(
        &self,
        table: &str,
        row: usize,
        tx: &mut DbTransaction<'_>,
    ) -> Result<Option<JsonRow>> {
        let sql = format!(r#"SELECT * FROM "{table}" WHERE "_id" = ?"#);
        let params = json!([row]);
        tx.query_one(&sql, Some(&params))
    }

    pub async fn get_site(&self, username: &str) -> Site {
        let mut users = self.get_users().await.unwrap_or_default();
        users.shift_remove(username);
        Site {
            title: "RLTBL".to_string(),
            root: self.root.clone(),
            editable: !self.readonly,
            user: self.get_user(username).await,
            users,
            tables: self.get_tables().await.unwrap_or_default(),
        }
    }

    pub fn prepare_user_cursor(
        &self,
        changeset: &ChangeSet,
        tx: &mut DbTransaction<'_>,
    ) -> Result<()> {
        // Make sure the user is present in the user table
        let user = changeset.user.clone();
        let color = random_color::RandomColor::new().to_hex();
        let statement = r#"INSERT OR IGNORE INTO user("name", "color") VALUES (?, ?)"#;
        let params = json!([user, color]);
        tx.query(&statement, Some(&params))?;

        // Update the user's cursor position.
        let mut cursor = changeset.to_cursor()?;
        match changeset.action {
            ChangeAction::Undo | ChangeAction::Redo => match changeset.changes.first() {
                Some(Change::Delete { row, after: _ }) => {
                    cursor.row = self._get_previous_row_id(&changeset.table, *row, tx)?;
                }
                _ => (),
            },
            ChangeAction::Do => (),
        };

        let statement =
            r#"UPDATE user SET "cursor" = ?, "datetime" = CURRENT_TIMESTAMP WHERE "name" = ?"#;
        let params = json!([to_value(cursor).unwrap_or_default(), user]);
        tx.query_value(&statement, Some(&params))?;

        Ok(())
    }

    pub async fn get_last_redoable_action_for_user(
        &self,
        user: &str,
    ) -> Result<Option<(usize, ChangeSet)>> {
        let history = self.get_user_history(user, Some(1)).await?;
        match history.changes_undone_stack.first() {
            None => Ok(None),
            Some(change) => {
                let change_id = change.get_unsigned("change_id")?;
                let content = change.get_string("content")?;
                let changes = Change::many_from_str(&content)?;
                Ok(Some((
                    change_id,
                    ChangeSet {
                        action: ChangeAction::from_str(&change.get_string("action")?)?,
                        table: change.get_string("table")?,
                        user: change.get_string("user")?,
                        description: change.get_string("user")?,
                        changes,
                    },
                )))
            }
        }
    }

    pub async fn get_last_undoable_action_for_user(
        &self,
        user: &str,
    ) -> Result<Option<(usize, ChangeSet)>> {
        let history = self.get_user_history(user, Some(1)).await?;
        match history.changes_done_stack.first() {
            None => Ok(None),
            Some(change) => {
                let change_id = change.get_unsigned("change_id")?;
                let content = change.get_string("content")?;
                let changes = Change::many_from_str(&content)?;
                Ok(Some((
                    change_id,
                    ChangeSet {
                        action: ChangeAction::from_str(&change.get_string("action")?)?,
                        table: change.get_string("table")?,
                        user: change.get_string("user")?,
                        description: change.get_string("user")?,
                        changes,
                    },
                )))
            }
        }
    }

    pub async fn get_user_history(&self, user: &str, context: Option<usize>) -> Result<History> {
        fn content_to_json_row(content: &str) -> Result<JsonRow> {
            tracing::debug!("Entering content_to_json_row(content: {content})");
            match serde_json::from_str::<JsonValue>(content) {
                Ok(content) => match content
                    .as_array()
                    .and_then(|a| a.first())
                    .and_then(|o| o.as_object())
                {
                    Some(object) => Ok(JsonRow {
                        content: object.clone(),
                    }),
                    None => {
                        return Err(RelatableError::InputError(format!(
                            "Received invalid or empty content: {content}. Expected a non-empty \
                             object array."
                        ))
                        .into())
                    }
                },
                Err(err) => {
                    return Err(
                        RelatableError::InputError(format!("Error reading content: {err}")).into(),
                    )
                }
            }
        }

        fn on_the_same_target(change1: &JsonRow, change2: &JsonRow) -> Result<bool> {
            tracing::debug!(
                "Entering on_the_same_target(change1: {change1:?}, change2: {change2:?})"
            );
            let change1 = content_to_json_row(&change1.get_string("content")?)?;
            let change2 = content_to_json_row(&change2.get_string("content")?)?;
            let row1 = change1.get_unsigned("row")?;
            let row2 = change2.get_unsigned("row")?;
            if row1 != row2 {
                return Ok(false);
            }
            if let Ok(column1) = change1.get_string("column") {
                if let Ok(column2) = change2.get_string("column") {
                    return Ok(column1 == column2);
                }
            }
            Ok(true)
        }

        fn prune_stacks(
            changes_done_stack: &Vec<JsonRow>,
            changes_undone_stack: &Vec<JsonRow>,
        ) -> (Vec<JsonRow>, Vec<JsonRow>) {
            let mut pruned_dones = vec![];
            let mut pruned_undones = vec![];
            for change in changes_done_stack.iter() {
                if !pruned_dones.iter().any(|done: &JsonRow| {
                    on_the_same_target(&done, &change).expect("Error looking for a common target")
                }) {
                    pruned_dones.push(change.clone());
                }
            }
            for change in changes_undone_stack.iter() {
                if !pruned_undones.iter().any(|undone: &JsonRow| {
                    on_the_same_target(&undone, &change).expect("Error looking for a common target")
                }) {
                    pruned_undones.push(change.clone());
                }
            }
            (pruned_dones, pruned_undones)
        }

        // TODO: Think about paging when there are a lot of change records to go through.
        let sql = format!(
            r#"SELECT "change_id", "user", "table", "description", "action", "content"
                 FROM "change"
                WHERE "user" = ?
                ORDER BY "change_id" DESC"#
        );
        let params = json!([user]);
        let history = self.connection.query(&sql, Some(&params)).await?;

        // Initialize the stacks to be returned and counters:
        let mut changes_done_stack = vec![];
        let mut changes_undone_stack = vec![];
        let mut do_redo_count: usize;
        let mut undo_count: usize;

        // Begin with the last change that was made:
        let (final_change, final_action) = match history.first() {
            None => return Ok(History::default()),
            Some(final_change) => {
                let final_action = ChangeAction::from_str(&final_change.get_string("action")?)?;
                (final_change, final_action)
            }
        };
        match final_action {
            ChangeAction::Do | ChangeAction::Redo => {
                do_redo_count = 1;
                undo_count = 0;
            }
            ChangeAction::Undo => {
                do_redo_count = 0;
                undo_count = 1;
            }
        };
        let mut change_to_push = final_change;
        let mut action_to_push = final_action;
        tracing::debug!("Setting the change to push ({action_to_push}) to: {change_to_push:?}");
        tracing::debug!(
            "The do/redo count is now {do_redo_count}, and the undo count is \
             {undo_count}."
        );

        // For each action, find the point where it began, and then place it onto changes_done_stack
        // or changes_undone_stack, as appropriate:
        for prior_change in &history[1..] {
            let prior_action = ChangeAction::from_str(&prior_change.get_string("action")?)?;
            tracing::debug!("The change prior to it is a {prior_action}: {prior_change:?}.");
            match action_to_push {
                ChangeAction::Do => match prior_action {
                    ChangeAction::Do | ChangeAction::Redo => {
                        tracing::debug!(
                            "Pushing change {cid} to changes_done",
                            cid = change_to_push.get_string("change_id")?
                        );
                        changes_done_stack.push(change_to_push.clone());
                        change_to_push = prior_change;
                        action_to_push =
                            ChangeAction::from_str(&change_to_push.get_string("action")?)?;
                        do_redo_count = 1;
                        undo_count = 0;
                        tracing::debug!(
                            "The next change to push is a {action_to_push}: {change_to_push:?}"
                        );
                    }
                    ChangeAction::Undo => {
                        tracing::debug!(
                            "Pushing change {cid} to changes_done",
                            cid = change_to_push.get_string("change_id")?
                        );
                        changes_done_stack.push(change_to_push.clone());
                        change_to_push = prior_change;
                        action_to_push =
                            ChangeAction::from_str(&change_to_push.get_string("action")?)?;
                        do_redo_count = 0;
                        undo_count = 1;
                        tracing::debug!(
                            "The next change to push is a {action_to_push}: {change_to_push:?}"
                        );
                    }
                },
                ChangeAction::Undo => match prior_action {
                    ChangeAction::Undo => {
                        if do_redo_count == 0 {
                            tracing::debug!(
                                "Pushing change {cid} to changes_undone",
                                cid = change_to_push.get_string("change_id")?
                            );
                            changes_undone_stack.push(change_to_push.clone());
                            change_to_push = prior_change;
                            action_to_push =
                                ChangeAction::from_str(&change_to_push.get_string("action")?)?;
                            tracing::debug!(
                                "The next change to push is a {action_to_push}: {change_to_push:?}"
                            );
                            undo_count += 1;
                        } else {
                            do_redo_count -= 1;
                            undo_count += 1;
                        }
                    }
                    ChangeAction::Do | ChangeAction::Redo => {
                        if undo_count == 0 {
                            tracing::debug!(
                                "Pushing change {cid} to changes_undone",
                                cid = change_to_push.get_string("change_id")?
                            );
                            changes_undone_stack.push(change_to_push.clone());
                            change_to_push = prior_change;
                            action_to_push =
                                ChangeAction::from_str(&change_to_push.get_string("action")?)?;
                            do_redo_count = 1;
                            tracing::debug!(
                                "The next change to push is a {action_to_push}: {change_to_push:?}"
                            );
                        } else {
                            do_redo_count += 1;
                            undo_count -= 1;
                        }
                    }
                },
                ChangeAction::Redo => match prior_action {
                    ChangeAction::Redo => {
                        if undo_count == 0 {
                            tracing::debug!(
                                "Pushing change {cid} to changes_done",
                                cid = change_to_push.get_string("change_id")?
                            );
                            changes_done_stack.push(change_to_push.clone());
                            change_to_push = prior_change;
                            action_to_push =
                                ChangeAction::from_str(&change_to_push.get_string("action")?)?;
                            tracing::debug!(
                                "The next change to push is a {action_to_push}: {change_to_push:?}"
                            );
                            do_redo_count += 1;
                        } else {
                            do_redo_count += 1;
                            undo_count -= 1;
                        }
                    }
                    ChangeAction::Do => {
                        if undo_count == 0 {
                            tracing::debug!(
                                "Pushing change {cid} to changes_done",
                                cid = change_to_push.get_string("change_id")?
                            );
                            changes_done_stack.push(change_to_push.clone());
                            change_to_push = prior_change;
                            action_to_push =
                                ChangeAction::from_str(&change_to_push.get_string("action")?)?;
                            tracing::debug!(
                                "The next change to push is a {action_to_push}: {change_to_push:?}"
                            );
                            // Dos begin anew.
                            do_redo_count = 1;
                        } else {
                            do_redo_count += 1;
                            undo_count -= 1;
                        }
                    }
                    ChangeAction::Undo => {
                        if do_redo_count == 0 {
                            tracing::debug!(
                                "Pushing change {cid} to changes_done",
                                cid = change_to_push.get_string("change_id")?
                            );
                            changes_done_stack.push(change_to_push.clone());
                            change_to_push = prior_change;
                            action_to_push =
                                ChangeAction::from_str(&change_to_push.get_string("action")?)?;
                            tracing::debug!(
                                "The next change to push is a {action_to_push}: {change_to_push:?}"
                            );
                            undo_count = 1;
                        } else {
                            do_redo_count -= 1;
                            undo_count += 1;
                        }
                    }
                },
            };

            tracing::debug!(
                "Updated the do/redo count to {do_redo_count}, and the undo count to \
                 {undo_count}."
            );

            // Remove duplicate entries from the stacks. These can result when a row is repeatedly
            // undone and redone. These are harmless, logically speaking, but they may potentially
            // confuse the user if they are included in the output.
            (changes_done_stack, changes_undone_stack) =
                prune_stacks(&changes_done_stack, &changes_undone_stack);

            // Check if we have exceeded the (max) context, and if so, stop looking for more
            // actions:
            let mut done_len = changes_done_stack.len();
            let mut undone_len = changes_undone_stack.len();
            match action_to_push {
                ChangeAction::Do | ChangeAction::Redo => done_len += 1,
                ChangeAction::Undo => undone_len += 1,
            };
            if let Some(context) = context {
                if done_len >= context && undone_len >= context {
                    break;
                }
            } else if done_len >= MAX_CONTEXT || undone_len >= MAX_CONTEXT {
                break;
            }
        }

        // Once we have finished iterating, there will be one action left over to push, which we
        // do now:
        match action_to_push {
            ChangeAction::Do | ChangeAction::Redo => {
                tracing::debug!("Pushing the last change to changes_done: {change_to_push:?}");
                changes_done_stack.push(change_to_push.clone());
            }
            ChangeAction::Undo => {
                tracing::debug!("Pushing the last change to changes_undone: {change_to_push:?}");
                changes_undone_stack.push(change_to_push.clone());
            }
        };

        // Don't return the contents of changes_undone if the last change was a do. Dos can never be
        // redone. If the last change was an undo or a redo, the logic will take care of itself and
        // it should never be possible to undo or redo inappropriately.
        let mut changes_undone_stack = match final_action {
            ChangeAction::Do => vec![],
            _ => changes_undone_stack,
        };

        // Prune the stacks one last time, in case by adding the final action we created a situation
        // in which one of the stacks contains duplicates:
        (changes_done_stack, changes_undone_stack) =
            prune_stacks(&changes_done_stack, &changes_undone_stack);

        // Similarly, crop for context one last time if a context has been defined:
        let history = match context {
            None => History {
                changes_done_stack,
                changes_undone_stack,
            },
            Some(context) => {
                let mut done_len = changes_done_stack.len();
                if done_len > context {
                    done_len = context;
                }
                let changes_done_stack = changes_done_stack[..done_len].to_vec();

                let mut undone_len = changes_undone_stack.len();
                if undone_len > context {
                    undone_len = context;
                }
                let changes_undone_stack = changes_undone_stack[..undone_len].to_vec();
                History {
                    changes_done_stack,
                    changes_undone_stack,
                }
            }
        };
        tracing::debug!("Returning history: {history:#?}");
        Ok(history)
    }

    async fn _undo_or_redo(
        &self,
        change_id: usize,
        changeset: &ChangeSet,
    ) -> Result<Option<ChangeSet>> {
        match changeset.changes.first() {
            None => Ok(None),
            Some(change) => {
                if let Change::Update { .. } = change {
                    let conn = self.connection.reconnect()?;
                    let actual_changes = self._set_values(conn, &changeset).await?;
                    Ok(Some(actual_changes))
                } else {
                    let mut actual_changes = vec![];
                    for change in changeset.changes.iter() {
                        let conn = self.connection.reconnect()?;
                        match change {
                            Change::Update { .. } => (), // Change::Update already handled above.
                            Change::Add { row, after: _ } => {
                                let num_deleted = self
                                    ._delete_row(
                                        conn,
                                        &changeset.action,
                                        &changeset.table,
                                        &changeset.user,
                                        *row,
                                    )
                                    .await?;
                                if num_deleted > 0 {
                                    actual_changes.push(change.clone());
                                }
                            }
                            Change::Move {
                                row,
                                from_after,
                                to_after: _,
                            } => {
                                let new_order = self
                                    ._move_and_record_row(
                                        conn,
                                        &changeset.action,
                                        &changeset.table,
                                        &changeset.user,
                                        *row,
                                        *from_after,
                                    )
                                    .await?;
                                if new_order > 0 {
                                    actual_changes.push(change.clone());
                                }
                            }
                            Change::Delete { row, after } => {
                                // Get the row, as it was before it was deleted, from the history
                                // table:
                                let sql = r#"SELECT "before" FROM "history" WHERE "change_id" = ?"#;
                                let params = json!([change_id]);
                                let before = self
                                    .connection
                                    .query_one(&sql, Some(&params))
                                    .await?
                                    .ok_or(RelatableError::DataError(format!(
                                        "No history row found with change_id {change_id}"
                                    )))?
                                    .get_string("before")?;
                                let before = match serde_json::from_str::<JsonValue>(&before) {
                                    Err(err) => return Err(err.into()),
                                    Ok(JsonValue::Object(o)) => o,
                                    Ok(_) => {
                                        return Err(RelatableError::InputError(
                                            "The content parameter is not an object".to_string(),
                                        )
                                        .into());
                                    }
                                };
                                let before = JsonRow { content: before };
                                // Re-add it to the data table:
                                self._add_row(
                                    conn,
                                    &changeset.action,
                                    &changeset.table,
                                    &changeset.user,
                                    Some(*row),
                                    Some(*after),
                                    &before,
                                )
                                .await?;
                                actual_changes.push(change.clone());
                            }
                        };
                    }
                    Ok(Some(ChangeSet {
                        action: changeset.action,
                        table: changeset.table.clone(),
                        user: changeset.user.clone(),
                        description: changeset.description.clone(),
                        changes: actual_changes,
                    }))
                }
            }
        }
    }

    pub async fn undo(&self, user: &str) -> Result<Option<ChangeSet>> {
        let (change_id, mut changeset) = match self.get_last_undoable_action_for_user(user).await? {
            None => {
                tracing::warn!("Nothing to undo for '{user}'");
                return Ok(None);
            }
            Some(changeset) => changeset,
        };
        changeset.action = ChangeAction::Undo;
        let changeset = self._undo_or_redo(change_id, &changeset).await?;
        if let Some(_) = changeset {
            self.commit_to_git().await?;
        }
        Ok(changeset)
    }

    pub async fn redo(&self, user: &str) -> Result<Option<ChangeSet>> {
        let (change_id, mut changeset) = match self.get_last_redoable_action_for_user(user).await? {
            None => {
                tracing::warn!("Nothing to redo for '{user}'");
                return Ok(None);
            }
            Some(changeset) => changeset,
        };
        changeset.action = ChangeAction::Redo;
        let changeset = self._undo_or_redo(change_id, &changeset).await?;
        if let Some(_) = changeset {
            self.commit_to_git().await?;
        }
        Ok(changeset)
    }

    async fn _set_values(
        &self,
        mut conn: Option<DbActiveConnection>,
        changeset: &ChangeSet,
    ) -> Result<ChangeSet> {
        // Begin a transaction:
        let mut tx = self.connection.begin(&mut conn).await?;

        // Update the user cursor
        self.prepare_user_cursor(changeset, &mut tx)?;

        // Actually make the changes:
        let table = changeset.table.clone();
        let mut actual_changes = vec![];
        for change in &changeset.changes {
            match change {
                Change::Update {
                    row,
                    column,
                    before,
                    after,
                } => {
                    // WARN: This just sets text!
                    let sql = format!(
                        r#"UPDATE "{table}"
                              SET "{column}" = ?
                            WHERE _id = ?
                           RETURNING 1 AS "updated""#,
                    );

                    // Depending on whether this is an undo/redo or an original action, the
                    // new value will be taken from either `before` or `after`.
                    let value = match &changeset.action {
                        ChangeAction::Undo | ChangeAction::Redo => before,
                        ChangeAction::Do => after,
                    };
                    // TODO: Render JSON to SQL properly.
                    let params = json!([json_to_string(&value), row]);
                    if tx.query(&sql, Some(&params))?.len() < 1 {
                        tracing::warn!("No row with _id {row} found to update");
                    } else {
                        actual_changes.push(Change::Update {
                            row: *row,
                            column: column.clone(),
                            before: match &changeset.action {
                                ChangeAction::Undo | ChangeAction::Redo => after.clone(),
                                ChangeAction::Do => before.clone(),
                            },
                            after: match &changeset.action {
                                ChangeAction::Undo | ChangeAction::Redo => before.clone(),
                                ChangeAction::Do => after.clone(),
                            },
                        });
                    }
                }
                _ => {
                    return Err(RelatableError::InputError(format!(
                        "Invalid change in changeset argument to set_values(): {change:?}"
                    ))
                    .into());
                }
            };
        }

        let num_changes = actual_changes.len();
        let actual_changeset = ChangeSet {
            action: changeset.action,
            table: changeset.table.clone(),
            user: changeset.user.clone(),
            description: changeset.description.clone(),
            changes: actual_changes,
        };
        if num_changes > 0 {
            // Record the changes to the change and history tables:
            self.record_changes(&actual_changeset, &mut tx)?;
        }

        // Commit the transaction:
        tx.commit()?;

        Ok(actual_changeset)
    }

    pub async fn set_values(&self, changeset: &ChangeSet) -> Result<ChangeSet> {
        let conn = self.connection.reconnect()?;
        let changeset = self._set_values(conn, changeset).await?;
        if changeset.changes.len() > 0 {
            self.commit_to_git().await?;
        }
        Ok(changeset)
    }

    pub async fn add_message(
        &self,
        user: &str,
        table_name: &str,
        row: usize,
        column: &str,
        level: &str,
        rule: &str,
        message: &str,
    ) -> Result<(usize, Message)> {
        let sql = format!(r#"SELECT "{column}" FROM "{table_name}" WHERE _id = ?"#);
        let params = json!([row]);
        let value = match self.connection.query_value(&sql, Some(&params)).await? {
            Some(JsonValue::String(s)) => s.as_str().to_string(),
            Some(JsonValue::Null) | None => "".to_string(),
            Some(value) => value.to_string(),
        };

        let sql = r#"INSERT INTO "message"
                     ("added_by", "table", "row", "column", "value", "level", "rule", "message")
                     VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                     RETURNING "message_id""#;
        let params = json!([user, table_name, row, column, value, level, rule, message]);
        let message_id = self
            .connection
            .query_one(&sql, Some(&params))
            .await?
            .ok_or(RelatableError::DataError(
                "Error inserting message".to_string(),
            ))?
            .get_unsigned("message_id")?;

        Ok((
            message_id,
            Message {
                level: level.to_string(),
                rule: rule.to_string(),
                message: message.to_string(),
            },
        ))
    }

    async fn _add_row(
        &self,
        mut conn: Option<DbActiveConnection>,
        action: &ChangeAction,
        table_name: &str,
        user: &str,
        new_row_id: Option<usize>,
        after_id: Option<usize>,
        row: &JsonRow,
    ) -> Result<Row> {
        // Begin a transaction:
        let mut tx = self.connection.begin(&mut conn).await?;

        // Get the current database information for the table:
        let table = self._get_table(table_name, &mut tx)?;
        if !table.editable {
            return Err(
                RelatableError::InputError(format!("{} is not editable.", table_name,)).into(),
            );
        }

        // Prepare a new row to be inserted:
        let mut new_row = Row::prepare_new(&table, Some(row), &mut tx)?;

        // A new_row_id will have been passed if the row is being added as part of an undo/redo.
        // In that case an after_id must have been passed as well but we leave the row order as
        // is for now, since we are not assured that the old row order is actually still free in
        // the table (recall that there is a unique constraint on _order). However the row_order
        // currently assigned is at the end of the table so there should not be any conflicts.
        if let Some(new_row_id) = new_row_id {
            new_row.id = new_row_id;
        }

        // Add the row to the table:
        let (sql, params) = new_row.as_insert(&table.name);
        tracing::info!("_add_row {sql} {params:?}");
        tx.query(&sql, Some(&params))?;

        let after_id = match after_id {
            None => self._get_previous_row_id(table_name, new_row.id, &mut tx)?,
            Some(after_id) => {
                // Move the row to its assigned spot within the table:
                let new_order = self._move_row(&mut tx, &table, new_row.id, after_id)?;
                new_row.order = new_order;
                after_id
            }
        };

        // Prepare a changeset to be recorded, consisting of a single change record indicating
        // the addition of one new row with the new_row's id and position in the table:
        let changeset = ChangeSet {
            action: *action,
            table: table_name.to_string(),
            user: user.to_string(),
            description: "Add one row".to_string(),
            changes: vec![Change::Add {
                row: new_row.id,
                after: after_id,
            }],
        };

        // Use the changeset to prepare the user cursor:
        self.prepare_user_cursor(&changeset, &mut tx)?;

        // Record the changes to the history table:
        self.record_changes(&changeset, &mut tx)?;

        // Commit the transaction:
        tx.commit()?;

        Ok(new_row)
    }

    pub async fn add_row(
        &self,
        table_name: &str,
        user: &str,
        after_id: Option<usize>,
        row: &JsonRow,
    ) -> Result<Row> {
        let conn = self.connection.reconnect()?;
        let new_row = self
            ._add_row(
                conn,
                &ChangeAction::Do,
                table_name,
                user,
                None,
                after_id,
                row,
            )
            .await?;
        self.commit_to_git().await?;
        Ok(new_row)
    }

    async fn _delete_row(
        &self,
        mut conn: Option<DbActiveConnection>,
        action: &ChangeAction,
        table_name: &str,
        user: &str,
        row: usize,
    ) -> Result<usize> {
        // Begin a transaction:
        let mut tx = self.connection.begin(&mut conn).await?;

        // Get the current database information for the table:
        let table = self._get_table(table_name, &mut tx)?;
        if !table.editable {
            return Err(
                RelatableError::InputError(format!("{} is not editable.", table_name,)).into(),
            );
        }

        // Prepare a changeset to be recorded, consisting of a single change record indicating
        // that a row with the given row number at the given table position has been deleted:
        let changeset = ChangeSet {
            action: *action,
            table: table_name.to_string(),
            user: user.to_string(),
            description: "Delete one row".to_string(),
            changes: vec![Change::Delete {
                row: row,
                after: self._get_previous_row_id(table_name, row, &mut tx)?,
            }],
        };

        // Use the changeset to prepare the user cursor:
        self.prepare_user_cursor(&changeset, &mut tx)?;

        // Delete the row:
        let sql = format!(
            r#"DELETE FROM "{}" WHERE "_id" = ? RETURNING 1 AS "deleted""#,
            table.name
        );
        let params = json!([row]);

        // Record the change to the history table:
        self.record_changes(&changeset, &mut tx)?;

        let num_deleted = tx.query(&sql, Some(&params))?.len();
        if num_deleted < 1 {
            tracing::warn!("No row found with _id {row} to delete");
            // Roll back the changes to the history and change table. The reason we made these
            // prior to the actual delete was so that we could record the row's position in the
            // table before it was deleted.
            tx.rollback()?;
        } else {
            // Commit the transaction:
            tx.commit()?;
        }

        Ok(num_deleted)
    }

    pub async fn delete_row(&self, table_name: &str, user: &str, row: usize) -> Result<usize> {
        let conn = self.connection.reconnect()?;
        let num_deleted = self
            ._delete_row(conn, &ChangeAction::Do, table_name, user, row)
            .await?;
        if num_deleted > 0 {
            self.commit_to_git().await?;
        }
        Ok(num_deleted)
    }

    pub async fn delete_message(
        &self,
        table: &str,
        row: Option<usize>,
        column: Option<&str>,
        target_rule: Option<&str>,
        target_user: Option<&str>,
    ) -> Result<usize> {
        let mut sql = r#"DELETE FROM "message" WHERE "table" = ?"#.to_string();
        let mut params = vec![json!(table)];

        if let Some(row) = row {
            sql.push_str(r#" AND "row" = ?"#);
            params.push(json!(row));
        }
        if let Some(column) = column {
            sql.push_str(r#" AND "column" = ?"#);
            params.push(json!(column));
        }
        if let Some(target_rule) = target_rule {
            sql.push_str(r#" AND "rule" LIKE ?"#);
            params.push(json!(target_rule));
        }
        if let Some(target_user) = target_user {
            sql.push_str(r#" AND "added_by" = ?"#);
            params.push(json!(target_user));
        }

        sql.push_str(r#" RETURNING 1 AS "deleted""#);
        let num_deleted = self
            .connection
            .query(&sql, Some(&json!(params)))
            .await?
            .len();
        Ok(num_deleted)
    }

    async fn _move_and_record_row(
        &self,
        mut conn: Option<DbActiveConnection>,
        action: &ChangeAction,
        table_name: &str,
        user: &str,
        id: usize,
        after_id: usize,
    ) -> Result<usize> {
        // Begin a transaction:
        let mut tx = self.connection.begin(&mut conn).await?;

        // Get the current database information for the table:
        let table = self._get_table(table_name, &mut tx)?;
        if !table.editable {
            return Err(
                RelatableError::InputError(format!("{} is not editable.", table_name,)).into(),
            );
        }

        // Prepare a changeset to be recorded, consisting of a single change record indicating
        // that a row has been displaced from somewhere to somewhere else.
        let changeset = ChangeSet {
            action: *action,
            table: table_name.to_string(),
            user: user.to_string(),
            description: "Move one row".to_string(),
            changes: vec![Change::Move {
                row: id,
                from_after: self._get_previous_row_id(table_name, id, &mut tx)?,
                to_after: after_id,
            }],
        };

        // Use the changeset to prepare the user cursor:
        self.prepare_user_cursor(&changeset, &mut tx)?;

        // Move the row within the table:
        let new_order = self._move_row(&mut tx, &table, id, after_id)?;

        if new_order != 0 {
            // Record the change to the history table:
            self.record_changes(&changeset, &mut tx)?;
        }

        // Commit the transaction:
        tx.commit()?;

        Ok(new_order)
    }

    fn _move_row(
        &self,
        tx: &mut DbTransaction<'_>,
        table: &Table,
        id: usize,
        after_id: usize,
    ) -> Result<usize> {
        fn get_row_order(
            tx: &mut DbTransaction<'_>,
            table: &Table,
            row_id: usize,
        ) -> Result<usize> {
            let sql = format!(r#"SELECT "_order" FROM "{}" WHERE "_id" = ?"#, table.name);
            let params = json!([row_id]);
            let rows = tx.query(&sql, Some(&params))?;
            if rows.is_empty() {
                return Err(RelatableError::DataError(format!(
                    "Unable to fetch _order for row {row_id} of table '{table}'",
                    table = table.name
                ))
                .into());
            }
            match rows[0].content.get("_order").and_then(|o| o.as_u64()) {
                Some(order) => Ok(order as usize),
                None => {
                    return Err(
                        RelatableError::DataError("No integer '_order' in row".to_string()).into(),
                    )
                }
            }
        }

        // Get the order, (A), of `after_id`:
        let order_prev = {
            if after_id > 0 {
                let mut id_to_try = after_id;
                let mut result = get_row_order(tx, table, id_to_try);
                // This handles the case in which the after row has been deleted for some reason
                // (this might happen if we are redoing).
                while let Err(_) = result {
                    if id_to_try == 0 {
                        break;
                    }
                    tracing::debug!("Could not obtain _order for row {id_to_try}");
                    id_to_try -= 1;
                    tracing::debug!("Trying to find the _order of row {id_to_try}");
                    result = get_row_order(tx, table, id_to_try);
                }
                result?
            } else {
                // It is not possible for a row to be assigned a order of zero. We allow it as a
                // possible value of `after_id`, however, which is used as a special value that we
                // should move the row identified by `id` to the beginning of the table.
                0
            }
        };

        // Run a query to get the minimum order, (B), that is greater than (A).
        let order_next = {
            let sql = format!(
                r#"SELECT MIN("_order") AS "_order" FROM "{}" WHERE "_order" > ?"#,
                table.name
            );
            let params = json!([order_prev]);
            let rows = tx.query(&sql, Some(&params))?;
            if rows.is_empty() {
                return Err(RelatableError::DataError(format!(
                    "Could not determine the minimum row order greater than {order_prev}"
                ))
                .into());
            }

            match rows[0].content.get("_order") {
                Some(value) => match value {
                    JsonValue::Null => {
                        // The row_order will be null if we ask Relatable to move a row to
                        // a position after the last row in the table.
                        order_prev + MOVE_INTERVAL
                    }
                    _ => match value.as_u64() {
                        Some(order) => order as usize,
                        None => {
                            return Err(RelatableError::DataError(
                                "Field '_order' in row is not an integer".to_string(),
                            )
                            .into());
                        }
                    },
                },
                None => {
                    return Err(RelatableError::DataError("No '_order' in row".to_string()).into());
                }
            }
        };

        let mut new_order = {
            if order_prev + 1 < order_next {
                // If the next order is not occupied just use it:
                order_prev + 1
            } else {
                // Otherwise, get all the orders that need to be moved. We sort the results in
                // descending order so that when we later update each value, no duplicate key
                // violations will ensue:
                let upper_bound = (order_next as f32 / MOVE_INTERVAL as f32).ceil() as usize
                    * MOVE_INTERVAL as usize;
                let sql = format!(
                    r#"SELECT "_order"
                         FROM "{}"
                        WHERE "_order" >= ? AND "_order" < ?
                     ORDER BY "_order" DESC"#,
                    table.name,
                );
                let params = json!([order_next, upper_bound]);
                let rows = tx.query(&sql, Some(&params))?;
                if rows.is_empty() {
                    return Err(RelatableError::DataError(
                        "Could not determine the highest row order".to_string(),
                    )
                    .into());
                }
                let highest_order = match rows[0].content.get("_order").and_then(|o| o.as_u64()) {
                    Some(order) => order as usize,
                    None => {
                        return Err(RelatableError::DataError(
                            "No field '_order' in row or it is not an integer".to_string(),
                        )
                        .into())
                    }
                };
                if highest_order + 1 >= upper_bound {
                    // Return an error
                    return Err(RelatableError::DataError(format!(
                        "Impossible to move row {} after row {}: No more room",
                        id, after_id
                    ))
                    .into());
                }

                for row in rows {
                    let current_order = match row.content.get("_order").and_then(|o| o.as_u64()) {
                        Some(order) => order as usize,
                        None => {
                            return Err(RelatableError::DataError(
                                "No field '_order' in row or it is not an integer".to_string(),
                            )
                            .into())
                        }
                    };
                    let sql = format!(
                        r#"UPDATE "{}"
                              SET "_order" = "_order" + 1
                            WHERE "_order" = ?"#,
                        table.name
                    );
                    let params = json!([current_order]);
                    tx.query(&sql, Some(&params))?;
                }
                // Now that we have made some room, we can use order_prev + 1,
                // which should no longer be occupied:
                order_prev + 1
            }
        };

        let sql = format!(
            r#"UPDATE "{}" SET "_order" = ? WHERE "_id" = ? RETURNING 1 AS "moved""#,
            table.name
        );
        let params = json!([new_order, id]);
        if tx.query(&sql, Some(&params))?.len() < 1 {
            tracing::warn!("Now row with _id {id} found to move");
            // It is not possible for a row to have an order of zero. It is used here to
            // represent the case where no row was actually moved to the caller.
            new_order = 0;
        }
        Ok(new_order)
    }

    fn _change_row_id(
        &self,
        tx: &mut DbTransaction<'_>,
        table: &Table,
        id: usize,
        new_id: usize,
    ) -> Result<()> {
        let sql = format!(
            r#"UPDATE "{table}"
                  SET "_id" = ?, "_order" = ?
                WHERE "_id" = ?
            RETURNING "_id" AS "_id""#,
            table = table.name,
        );
        let params = json!([new_id, id, id * MOVE_INTERVAL]);
        tx.query_one(&sql, Some(&params))?
            .ok_or(RelatableError::DataError(format!("No row with _id = {id}")))?
            .get_unsigned("_id")?;
        Ok(())
    }

    pub async fn move_row(
        &self,
        table_name: &str,
        user: &str,
        id: usize,
        after_id: usize,
    ) -> Result<usize> {
        let conn = self.connection.reconnect()?;
        let new_order = self
            ._move_and_record_row(conn, &ChangeAction::Do, table_name, user, id, after_id)
            .await?;
        if new_order != 0 {
            self.commit_to_git().await?;
        }
        Ok(new_order)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ChangeSet {
    pub action: ChangeAction,
    pub table: String,
    pub user: String,
    pub description: String,
    pub changes: Vec<Change>,
}

impl ChangeSet {
    fn to_cursor(&self) -> Result<Cursor> {
        let table = self.table.clone();
        match self.changes.first() {
            Some(change) => match change {
                Change::Update {
                    row,
                    column,
                    before: _,
                    after: _,
                } => Ok(Cursor {
                    table,
                    row: *row,
                    column: column.to_string(),
                }),
                Change::Add { row, after: _ } => Ok(Cursor {
                    table,
                    row: *row,
                    column: "".to_string(),
                }),
                Change::Move {
                    row,
                    from_after: _,
                    to_after: _,
                } => Ok(Cursor {
                    table,
                    row: *row,
                    column: "".to_string(),
                }),
                Change::Delete { row, after: _ } => Ok(Cursor {
                    table,
                    row: *row,
                    column: "".to_string(),
                }),
            },
            None => Err(RelatableError::ChangeError("No changes in set".into()).into()),
        }
    }
}

#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq)]
pub enum ChangeAction {
    Do,
    Undo,
    Redo,
}

impl FromStr for ChangeAction {
    type Err = anyhow::Error;

    fn from_str(action: &str) -> Result<Self> {
        match action.to_lowercase().as_str() {
            "do" => Ok(Self::Do),
            "undo" => Ok(Self::Undo),
            "redo" => Ok(Self::Redo),
            _ => {
                return Err(
                    RelatableError::InputError(format!("Unrecognized action: {action}")).into(),
                );
            }
        }
    }
}

impl Display for ChangeAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ChangeAction::Do => write!(f, "do"),
            ChangeAction::Undo => write!(f, "undo"),
            ChangeAction::Redo => write!(f, "redo"),
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum Change {
    Update {
        row: usize,
        column: String,
        before: JsonValue,
        after: JsonValue,
    },
    Add {
        row: usize,
        after: usize,
    },
    Move {
        row: usize,
        from_after: usize,
        to_after: usize,
    },
    Delete {
        row: usize,
        after: usize,
    },
}

impl Change {
    pub fn from_str(content: &str) -> Result<Self> {
        let changes = Self::many_from_str(content)?;
        let change = match changes.first() {
            None => {
                return Err(RelatableError::InputError("No change found".to_string()).into());
            }
            Some(change) => change.clone(),
        };
        if changes.len() > 1 {
            tracing::warn!("More than one change given. Returning the first.");
        }
        Ok(change)
    }

    pub fn many_from_str(content: &str) -> Result<Vec<Self>> {
        let json_content = match serde_json::from_str::<JsonValue>(content) {
            Err(err) => return Err(err.into()),
            Ok(JsonValue::Array(v)) => v,
            Ok(_) => {
                return Err(RelatableError::InputError(
                    "The content parameter is not an array".to_string(),
                )
                .into());
            }
        };

        let mut changes = vec![];
        for change_json in json_content.iter() {
            let change_json = match change_json.as_object() {
                Some(change_object) => JsonRow {
                    content: change_object.clone(),
                },
                None => {
                    return Err(RelatableError::InputError(format!(
                        "Not an object: {change_json}"
                    ))
                    .into());
                }
            };

            let change_type = change_json.get_string("type")?;
            let row = change_json.get_unsigned("row")?;
            match change_type.as_str() {
                "Update" => changes.push(Change::Update {
                    row,
                    column: change_json.get_string("column")?,
                    before: change_json.get_value("before")?,
                    after: change_json.get_value("after")?,
                }),
                "Add" => changes.push(Change::Add {
                    row,
                    after: change_json.get_unsigned("after")?,
                }),
                "Delete" => changes.push(Change::Delete {
                    row,
                    after: change_json.get_unsigned("after")?,
                }),
                "Move" => changes.push(Change::Move {
                    row,
                    from_after: change_json.get_unsigned("from_after")?,
                    to_after: change_json.get_unsigned("to_after")?,
                }),
                _ => {
                    return Err(RelatableError::InputError(format!(
                        "Unrecognized change type for change: {change_json:?}"
                    ))
                    .into());
                }
            };
        }
        Ok(changes)
    }

    pub fn from_json_row(json_row: &JsonRow) -> Result<Self> {
        match json_row.get_string("type")?.as_str() {
            "Update" => Ok(Self::Update {
                row: json_row.get_unsigned("row")?,
                column: json_row.get_string("column")?,
                before: json_row.get_value("before")?,
                after: json_row.get_value("after")?,
            }),
            "Add" => Ok(Self::Add {
                row: json_row.get_unsigned("row")?,
                after: json_row.get_unsigned("after")?,
            }),
            "Move" => Ok(Self::Move {
                row: json_row.get_unsigned("row")?,
                from_after: json_row.get_unsigned("from_after")?,
                to_after: json_row.get_unsigned("to_after")?,
            }),
            "Delete" => Ok(Self::Delete {
                row: json_row.get_unsigned("row")?,
                after: json_row.get_unsigned("after")?,
            }),
            _ => {
                return Err(RelatableError::InputError(format!(
                    "Unrecognized action type for change {json_row:?}"
                ))
                .into());
            }
        }
    }
}

#[derive(Default, Debug, Serialize, Deserialize)]
pub struct History {
    pub changes_done_stack: Vec<JsonRow>,
    pub changes_undone_stack: Vec<JsonRow>,
}

impl Display for Change {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Change::Update {
                row,
                column,
                before,
                after,
            } => {
                write!(
                    f,
                    "Update '{column}' in row {row} from {before} to {after}",
                    before = json_to_string(before),
                    after = json_to_string(after)
                )
            }
            Change::Add { row, after } => {
                write!(f, "Add row {row} after row {after}")
            }
            Change::Move {
                row,
                from_after,
                to_after,
            } => {
                write!(
                    f,
                    "Move row {row} from after row {from_after} to after row {to_after}"
                )
            }
            Change::Delete { row, after: _ } => write!(f, "Delete row {row}"),
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Message {
    /// The severity of the message.
    pub level: String,
    /// The rule violation that the message is about.
    pub rule: String,
    /// The contents of the message.
    pub message: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Cell {
    pub value: JsonValue,
    pub text: String,
    pub messages: Vec<Message>,
}

impl From<&JsonValue> for Cell {
    fn from(value: &JsonValue) -> Self {
        Self {
            value: value.clone(),
            text: match value {
                JsonValue::String(value) => value.to_string(),
                value => format!("{value}"),
            },
            messages: vec![],
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Row {
    pub id: usize,
    pub order: usize,
    pub change_id: usize,
    pub cells: IndexMap<String, Cell>,
}

impl Row {
    fn get_next_id(table: &str, tx: &mut DbTransaction<'_>) -> Result<usize> {
        let sql = r#"SELECT seq FROM sqlite_sequence WHERE name = ?"#;
        let params = json!([table]);
        let current_row_id = match tx.query_value(&sql, Some(&params))? {
            Some(value) => value.as_u64().unwrap_or_default() as usize,
            None => 0,
        };
        Ok(current_row_id + 1)
    }

    fn prepare_new(
        table: &Table,
        json_row: Option<&JsonRow>,
        tx: &mut DbTransaction<'_>,
    ) -> Result<Self> {
        let json_row = match json_row {
            None => {
                // WARN: SQLite only!
                let statement = format!(
                    r#"SELECT "name" FROM pragma_table_info("{table}") ORDER BY "cid""#,
                    table = table.name
                );
                let columns = {
                    let columns = tx.query(&statement, None)?;
                    if columns.is_empty() {
                        return Err(RelatableError::DataError(format!(
                            "No defined columns for: {table}",
                            table = table.name
                        ))
                        .into());
                    }
                    columns
                        .iter()
                        .map(|c| c.get_string("name").expect("No 'name' found"))
                        .filter(|n| !n.starts_with("_"))
                        .collect::<Vec<_>>()
                };
                let columns = columns.iter().map(|c| c.as_str()).collect::<Vec<_>>();
                JsonRow::from_strings(&columns)
            }
            Some(json_row) => json_row.clone(),
        };
        let mut row = Row::from(json_row);
        row.id = Self::get_next_id(table.name.as_str(), tx)?;
        row.order = MOVE_INTERVAL * row.id;
        row.change_id = table.change_id;
        Ok(row)
    }

    fn to_strings(&self) -> Vec<String> {
        self.cells.values().map(|cell| cell.text.clone()).collect()
    }

    fn as_insert(&self, table: &str) -> (String, JsonValue) {
        let id = self.id;
        let order = self.order;
        let columns = self
            .cells
            .keys()
            .map(|k| format!(r#""{k}""#))
            .collect::<Vec<_>>();
        let column_placeholders = columns.iter().map(|_| "?").collect::<Vec<_>>();

        let params = {
            let mut params = vec![json!(id), json!(order)];
            params.append(
                &mut self
                    .to_strings()
                    .iter()
                    .map(|s| json!(s))
                    .collect::<Vec<_>>(),
            );
            params
        };

        let sql = if columns.len() == 0 {
            format!(
                r#"INSERT INTO "{table}"
                   ("_id", "_order")
                   VALUES (?, ?)"#
            )
        } else {
            format!(
                r#"INSERT INTO "{table}"
                   ("_id", "_order", {column_names})
                   VALUES (?, ?, {column_values})"#,
                column_names = columns.join(", "),
                column_values = column_placeholders.join(", "),
            )
        };
        (sql, json!(params))
    }
}

impl From<Row> for Vec<String> {
    fn from(row: Row) -> Self {
        row.to_strings()
    }
}

impl From<JsonRow> for Row {
    fn from(row: JsonRow) -> Self {
        let id = row
            .content
            .get("_id")
            .and_then(|i| i.as_u64())
            .unwrap_or_default() as usize;
        let order = row
            .content
            .get("_order")
            .and_then(|i| i.as_u64())
            .unwrap_or_default() as usize;
        let change_id = row
            .content
            .get("_change_id")
            .and_then(|i| i.as_u64())
            .unwrap_or_default() as usize;
        let cells = row
            .content
            .iter()
            // Ignore columns that start with "_"
            .filter(|(k, _)| !k.starts_with("_"))
            .map(|(k, v)| (k.clone(), v.into()))
            .collect();

        Self {
            id,
            order,
            change_id,
            cells,
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Column {
    pub name: String,
    pub table: String,
    pub label: Option<String>,
    pub description: Option<String>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Table {
    pub name: String,
    // A view to use when displaying this table, or empty if none.
    pub view: String,
    // The history_id of the most recent update to this table.
    pub change_id: usize,
    pub editable: bool,
}

impl Default for Table {
    fn default() -> Self {
        Self {
            name: String::default(),
            view: String::default(),
            change_id: usize::default(),
            editable: true,
        }
    }
}

impl Table {
    async fn _ensure_view_created(&mut self, rltbl: &Relatable) -> Result<Vec<Column>> {
        tracing::debug!("Entering ensure_view_created({rltbl:?})");
        let (columns, meta_columns) = rltbl.fetch_all_columns(&self.name).await?;
        self.view = format!("{}_view", self.name);
        let id_col = match meta_columns.iter().any(|c| c.name == "_id") {
            false => match rltbl.connection.kind() {
                DbKind::Postgres => "ROW_NUMBER()",
                DbKind::Sqlite => r#"rowid"#, // This *must* be lowercase.
            },
            true => r#"_id"#,
        };
        let order_col = match meta_columns.iter().any(|c| c.name == "_order") {
            false => match rltbl.connection.kind() {
                DbKind::Postgres => "ROW_NUMBER()",
                DbKind::Sqlite => r#"rowid"#, // This *must* be lowercase.
            },
            true => r#"_order"#,
        };

        // Note that '?' parameters are not allowed in views so we must hard code them:
        let sql = match rltbl.connection.kind() {
            DbKind::Postgres => format!(
                r#"CREATE OR REPLACE VIEW "{view}" AS SELECT
                  {id_col} AS _id,
                  {order_col} AS _order,
                  NULL AS _history,
                  NULL AS _message,
                  {columns}
                  FROM "{table}""#,
                table = self.name,
                view = self.view,
                columns = columns
                    .iter()
                    .map(|c| format!(r#""{}""#, c.name))
                    .collect::<Vec<_>>()
                    .join(", "),
            ),
            DbKind::Sqlite => format!(
                r#"CREATE VIEW IF NOT EXISTS "{view}" AS SELECT
                   {id_col} AS _id,
                   {order_col} AS _order,
                   (SELECT '[' || GROUP_CONCAT("after") || ']'
                      FROM (
                        SELECT "after"
                        FROM "history"
                        WHERE "table" = '{table}'
                        AND "after" IS NOT NULL
                        AND "row" = {id_col}
                        ORDER BY "history_id"
                     )
                   ) AS "_history",
                   (SELECT NULLIF(
                      JSON_GROUP_ARRAY(
                        JSON_OBJECT(
                          'column', "column",
                          'value', "value",
                          'level', "level",
                          'rule', "rule",
                          'message', "message"
                        )
                      ),
                      '[]'
                    ) AS "_message"
                      FROM "message"
                      WHERE "table" = '{table}'
                      AND "row" = {id_col}
                      ORDER BY "column", "message_id"
                   ) AS "_message",
                   {columns}
                 FROM "{table}""#,
                table = self.name,
                view = self.view,
                columns = columns
                    .iter()
                    .map(|c| format!(r#""{}""#, c.name))
                    .collect::<Vec<_>>()
                    .join(", "),
            ),
        };
        rltbl.connection.query(&sql, None).await?;
        Ok(columns)
    }
}

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct Range {
    count: usize,
    total: usize,
    start: usize,
    end: usize,
}

impl std::fmt::Display for Range {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Rows {}-{} of {}", self.start, self.end, self.total)
    }
}

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct ResultSet {
    pub select: Select,
    pub range: Range,
    pub table: Table,
    pub columns: Vec<Column>,
    pub rows: Vec<Row>,
}

impl std::fmt::Display for ResultSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut tw = TabWriter::new(vec![]);
        tw.write(format!("{}\n", self.range).as_bytes())
            .unwrap_or_default();
        let header = &self
            .columns
            .iter()
            .map(|c| c.name.clone())
            .collect::<Vec<String>>();
        tw.write(format!("{}\n", header.join("\t")).as_bytes())
            .unwrap_or_default();
        for row in &self.rows {
            tw.write(format!("{}\n", row.to_strings().join("\t")).as_bytes())
                .unwrap_or_default();
        }
        tw.flush().expect("TabWriter to flush");
        let written = String::from_utf8(tw.into_inner().unwrap()).unwrap();
        write!(f, "{written}")
    }
}

// Selects and Filters

pub type QueryParams = IndexMap<String, String>;

pub enum Format {
    Html,
    Json,
    PrettyJson,
    ValueJson,
    Default,
}

impl Display for Format {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        // TODO: This should be factored out.
        let result = match self {
            Format::Html => ".html",
            Format::Json => ".json",
            Format::PrettyJson => ".pretty.json",
            Format::ValueJson => ".value.json",
            Format::Default => "",
        };
        write!(f, "{result}")
    }
}

impl TryFrom<&String> for Format {
    fn try_from(path: &String) -> Result<Self> {
        let path = path.to_lowercase();
        let format = if path.ends_with(".pretty.json") {
            Format::PrettyJson
        } else if path.ends_with(".value.json") {
            Format::ValueJson
        } else if path.ends_with(".json") {
            Format::Json
        } else if path.ends_with(".html") || path.ends_with(".htm") {
            Format::Html
        } else if path.contains(".") {
            return Err(
                RelatableError::FormatError(format!("Unknown format for path {path}")).into(),
            );
        } else {
            Format::Default
        };
        Ok(format)
    }

    type Error = anyhow::Error;
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum Filter {
    Like {
        table: String,
        column: String,
        value: JsonValue,
    },
    Equal {
        table: String,
        column: String,
        value: JsonValue,
    },
    NotEqual {
        table: String,
        column: String,
        value: JsonValue,
    },
    GreaterThan {
        table: String,
        column: String,
        value: JsonValue,
    },
    GreaterThanOrEqual {
        table: String,
        column: String,
        value: JsonValue,
    },
    LessThan {
        table: String,
        column: String,
        value: JsonValue,
    },
    LessThanOrEqual {
        table: String,
        column: String,
        value: JsonValue,
    },
    Is {
        table: String,
        column: String,
        value: JsonValue,
    },
    IsNot {
        table: String,
        column: String,
        value: JsonValue,
    },
    In {
        table: String,
        column: String,
        value: JsonValue,
    },
    NotIn {
        table: String,
        column: String,
        value: JsonValue,
    },
    InSubquery {
        table: String,
        column: String,
        subquery: Select,
    },
}

pub fn render_values(options: &Vec<JsonValue>) -> Result<String> {
    let mut values = vec![];
    let mut is_string_list = false;
    for (i, option) in options.iter().enumerate() {
        match option {
            JsonValue::String(s) => {
                if i == 0 {
                    is_string_list = true;
                } else if !is_string_list {
                    return Err(RelatableError::InputError(format!(
                        "{:?} contains both text and numeric types.",
                        options
                    ))
                    .into());
                }
                let value = unquote(s).unwrap_or(s.clone());
                values.push(format!("'{value}'"))
            }
            JsonValue::Number(n) => {
                if i == 0 {
                    is_string_list = false;
                } else if is_string_list {
                    return Err(RelatableError::InputError(format!(
                        "{:?} contains both text and numeric types.",
                        options
                    ))
                    .into());
                }
                values.push(format!("{n}"))
            }
            _ => {
                return Err(RelatableError::InputError(format!(
                    "{:?} is not an array of strings or numbers.",
                    options
                ))
                .into())
            }
        };
    }
    Ok(format!("({})", values.join(", ")))
}

fn render_in_not_in(lhs: String, options: &Vec<JsonValue>, positive: bool) -> Result<String> {
    let negation;
    if !positive {
        negation = " NOT";
    } else {
        negation = "";
    }

    let value_list = render_values(options)?;
    let filter_sql = format!("{}{} IN {}", lhs, negation, value_list);
    Ok(filter_sql)
}

impl Filter {
    pub fn parts(&self) -> (String, String, String, JsonValue) {
        let (table, column, operator, value) = match self {
            Filter::Like {
                table,
                column,
                value,
            } => (table, column, "like", value),
            Filter::Equal {
                table,
                column,
                value,
            } => (table, column, "eq", value),
            Filter::NotEqual {
                table,
                column,
                value,
            } => (table, column, "not_eq", value),
            Filter::GreaterThan {
                table,
                column,
                value,
            } => (table, column, "gt", value),
            Filter::GreaterThanOrEqual {
                table,
                column,
                value,
            } => (table, column, "gte", value),
            Filter::LessThan {
                table,
                column,
                value,
            } => (table, column, "lt", value),
            Filter::LessThanOrEqual {
                table,
                column,
                value,
            } => (table, column, "lte", value),
            Filter::Is {
                table,
                column,
                value,
            } => (table, column, "is", value),
            Filter::IsNot {
                table,
                column,
                value,
            } => (table, column, "is_not", value),
            Filter::In {
                table,
                column,
                value,
            } => (table, column, "in", value),
            Filter::NotIn {
                table,
                column,
                value,
            } => (table, column, "not_in", value),
            Filter::InSubquery {
                table,
                column,
                subquery,
            } => (table, column, "in", &json!(subquery)),
        };
        (
            table.to_string(),
            column.to_string(),
            operator.to_string(),
            json!(value),
        )
    }

    pub fn to_url(&self) -> Result<String> {
        fn handle_string_value(token: &str) -> String {
            let reserved = vec![':', ',', '.', '(', ')'];
            if token.chars().all(char::is_numeric) || reserved.iter().any(|&c| token.contains(c)) {
                format!("\"{}\"", token)
            } else {
                token.to_string()
            }
        }

        let (_, _, operator, value) = self.parts();

        let rhs = match &value {
            JsonValue::String(s) => handle_string_value(&s),
            JsonValue::Number(n) => format!("{}", n),
            JsonValue::Array(v) => {
                let mut list = vec![];
                for item in v {
                    match item {
                        JsonValue::String(s) => {
                            list.push(handle_string_value(&s));
                        }
                        JsonValue::Number(n) => list.push(n.to_string()),
                        _ => {
                            return Err(RelatableError::DataError(format!(
                                "Not all list items in {:?} are strings or numbers.",
                                v
                            ))
                            .into());
                        }
                    };
                }
                format!("({})", list.join(","))
            }
            _ => {
                return Err(RelatableError::DataError(format!(
                    "RHS of Filter: {:?} is not a string, number, or list",
                    self
                ))
                .into());
            }
        };

        Ok(format!("{operator}.{rhs}"))
    }

    pub fn to_sqlite(&self) -> Result<(String, Vec<JsonValue>)> {
        // TODO: This should be factored out.
        fn json_to_string(value: &JsonValue) -> String {
            match value {
                JsonValue::Null => "NULL".to_string(),
                JsonValue::Bool(value) => value.to_string(),
                JsonValue::Number(value) => value.to_string(),
                JsonValue::String(value) => format!("'{value}'"),
                JsonValue::Array(value) => format!("'{value:?}'"),
                JsonValue::Object(value) => format!("'{value:?}'"),
            }
        }
        match self {
            Filter::Like {
                table,
                column,
                value,
            } => {
                let value = json_to_string(&value);
                let value = value.replace("*", "%");
                if table == "" {
                    Ok((format!(r#""{column}" LIKE {value}"#), vec![]))
                } else {
                    Ok((format!(r#""{table}"."{column}" LIKE {value}"#), vec![]))
                }
            }
            Filter::Equal {
                table,
                column,
                value,
            } => {
                let value = json_to_string(&value);
                if table == "" {
                    Ok((format!(r#""{column}" = {value}"#), vec![]))
                } else {
                    Ok((format!(r#""{table}"."{column}" = {value}"#), vec![]))
                }
            }
            Filter::NotEqual {
                table,
                column,
                value,
            } => {
                let value = json_to_string(&value);
                if table == "" {
                    Ok((format!(r#""{column}" <> {value}"#), vec![]))
                } else {
                    Ok((format!(r#""{table}"."{column}" <> {value}"#), vec![]))
                }
            }
            Filter::GreaterThan {
                table,
                column,
                value,
            } => {
                let value = json_to_string(&value);
                if table == "" {
                    Ok((format!(r#""{column}" > {value}"#), vec![]))
                } else {
                    Ok((format!(r#""{table}"."{column}" > {value}"#), vec![]))
                }
            }
            Filter::GreaterThanOrEqual {
                table,
                column,
                value,
            } => {
                let value = json_to_string(&value);
                if table == "" {
                    Ok((format!(r#""{column}" >= {value}"#), vec![]))
                } else {
                    Ok((format!(r#""{table}"."{column}" >= {value}"#), vec![]))
                }
            }
            Filter::LessThan {
                table,
                column,
                value,
            } => {
                let value = json_to_string(&value);
                if table == "" {
                    Ok((format!(r#""{column}" < {value}"#), vec![]))
                } else {
                    Ok((format!(r#""{table}"."{column}" < {value}"#), vec![]))
                }
            }
            Filter::LessThanOrEqual {
                table,
                column,
                value,
            } => {
                let value = json_to_string(&value);
                if table == "" {
                    Ok((format!(r#""{column}" <= {value}"#), vec![]))
                } else {
                    Ok((format!(r#""{table}"."{column}" <= {value}"#), vec![]))
                }
            }
            Filter::Is {
                table,
                column,
                value,
            } => {
                // Note that we are presupposing SQLite syntax which is not universal for IS:
                let value = json_to_string(&value);
                if table == "" {
                    Ok((format!(r#""{column}" IS {value}"#), vec![]))
                } else {
                    Ok((format!(r#""{table}"."{column}" IS {value}"#), vec![]))
                }
            }
            Filter::IsNot {
                table,
                column,
                value,
            } => {
                // Note that we are presupposing SQLite syntax which is not universal for IS:
                let value = json_to_string(&value);
                if table == "" {
                    Ok((format!(r#""{column}" IS NOT {value}"#), vec![]))
                } else {
                    Ok((format!(r#""{table}"."{column}" IS NOT {value}"#), vec![]))
                }
            }
            Filter::In {
                table,
                column,
                value,
            } => {
                if let JsonValue::Array(values) = value {
                    let lhs = match table.as_str() {
                        "" => format!(r#""{column}""#),
                        _ => format!(r#""{table}"."{column}""#),
                    };
                    let filter_str = match render_in_not_in(lhs, values, true) {
                        Err(e) => {
                            return Err(RelatableError::DataError(format!(
                                "Error rendering 'in' filter: {e}"
                            ))
                            .into());
                        }
                        Ok(filter_str) => filter_str,
                    };
                    Ok((format!("{filter_str}"), vec![]))
                } else {
                    Err(RelatableError::DataError(format!("Invalid 'in' value: {value}")).into())
                }
            }
            Filter::NotIn {
                table,
                column,
                value,
            } => {
                if let JsonValue::Array(values) = value {
                    let lhs = match table.as_str() {
                        "" => format!(r#""{column}""#),
                        _ => format!(r#""{table}"."{column}""#),
                    };
                    let filter_str = match render_in_not_in(lhs, values, false) {
                        Err(e) => {
                            return Err(RelatableError::DataError(format!(
                                "Error rendering 'not in' filter: {e}"
                            ))
                            .into());
                        }
                        Ok(filter_str) => filter_str,
                    };
                    Ok((format!("{filter_str}"), vec![]))
                } else {
                    Err(
                        RelatableError::DataError(format!("Invalid 'not in' value: {value}"))
                            .into(),
                    )
                }
            }
            Filter::InSubquery {
                table,
                column,
                subquery,
            } => {
                let lhs = match table.as_str() {
                    "" => format!(r#""{column}""#),
                    _ => format!(r#""{table}"."{column}""#),
                };
                let (sql, params) = subquery.to_sqlite()?;
                let sql = sql.replace("\n", "\n  ");
                Ok((format!("{lhs} IN (\n  {sql}\n)"), params))
            }
        }
    }

    pub fn to_sqlite_count(&self) -> Result<(String, Vec<JsonValue>)> {
        match self {
            Filter::InSubquery {
                table,
                column,
                subquery,
            } => {
                let lhs = match table.as_str() {
                    "" => format!(r#""{column}""#),
                    _ => format!(r#""{table}"."{column}""#),
                };
                let (sql, params) = subquery.to_sqlite()?;
                let lines: Vec<&str> = sql
                    .split("\n")
                    .filter(|x| !x.starts_with("ORDER BY"))
                    .filter(|x| !x.starts_with("LIMIT"))
                    .filter(|x| !x.starts_with("OFFSET"))
                    .collect();
                let sql = lines.join("\n  ");
                Ok((format!("{lhs} IN (\n  {sql}\n)"), params))
            }
            _ => self.to_sqlite(),
        }
    }
}

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct Select {
    pub table_name: String,
    pub view_name: String,
    pub select: Vec<String>,
    pub joins: Vec<String>,
    pub limit: usize,
    pub offset: usize,
    pub filters: Vec<Filter>,
    pub order_by: Vec<(String, Order)>,
}

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub enum Order {
    #[default]
    ASC,
    DESC,
}

impl Select {
    pub fn from_path_and_query(rltbl: &Relatable, path: &str, query_params: &QueryParams) -> Self {
        let table_name = path.split(".").next().unwrap_or_default().to_string();
        let mut query_params = query_params.clone();
        let mut filters = Vec::new();
        let mut order_by = Vec::new();

        let mut select = vec![];
        if let Some(s) = query_params.get("select") {
            select.push(s.clone());
        }
        let limit: usize = query_params
            .get("limit")
            .and_then(|x| x.parse::<usize>().ok())
            .unwrap_or(rltbl.default_limit)
            .min(rltbl.max_limit);
        let offset: usize = query_params
            .get("offset")
            .and_then(|x| x.parse::<usize>().ok())
            .unwrap_or_default();
        if let Some(order) = query_params.get("order") {
            for item in order.split(",") {
                if item.ends_with(".asc") {
                    let column = item.replace(".asc", "");
                    order_by.push((column, Order::ASC));
                } else if item.ends_with(".desc") {
                    let column = item.replace(".desc", "");
                    order_by.push((column, Order::DESC));
                } else {
                    order_by.push((item.to_string(), Order::ASC));
                }
            }
        }

        query_params.shift_remove("limit");
        query_params.shift_remove("offset");
        query_params.shift_remove("order");

        for (lhs, pattern) in query_params {
            let (table, column) = match lhs.split_once(".") {
                Some((table, column)) => (table.to_string(), column.to_string()),
                None => (String::new(), lhs),
            };
            if pattern.starts_with("like.") {
                let value = &pattern.replace("like.", "");
                match serde_json::from_str(value) {
                    Ok(value) => filters.push(Filter::Like {
                        table,
                        column,
                        value,
                    }),
                    Err(_) => filters.push(Filter::Like {
                        table,
                        column,
                        value: JsonValue::String(value.to_string()),
                    }),
                }
            } else if pattern.starts_with("eq.") {
                let value = &pattern.replace("eq.", "");
                match serde_json::from_str(value) {
                    Ok(value) => filters.push(Filter::Equal {
                        table,
                        column,
                        value,
                    }),
                    Err(_) => filters.push(Filter::Equal {
                        table,
                        column,
                        value: JsonValue::String(value.to_string()),
                    }),
                }
            } else if pattern.starts_with("not_eq.") {
                let value = &pattern.replace("not_eq.", "");
                match serde_json::from_str(value) {
                    Ok(value) => filters.push(Filter::NotEqual {
                        table,
                        column,
                        value,
                    }),
                    Err(_) => filters.push(Filter::NotEqual {
                        table,
                        column,
                        value: JsonValue::String(value.to_string()),
                    }),
                }
            } else if pattern.starts_with("gt.") {
                let value = &pattern.replace("gt.", "");
                match serde_json::from_str(value) {
                    Ok(value) => filters.push(Filter::GreaterThan {
                        table,
                        column,
                        value,
                    }),
                    Err(_) => filters.push(Filter::GreaterThan {
                        table,
                        column,
                        value: JsonValue::String(value.to_string()),
                    }),
                }
            } else if pattern.starts_with("gte.") {
                let value = &pattern.replace("gte.", "");
                match serde_json::from_str(value) {
                    Ok(value) => filters.push(Filter::GreaterThanOrEqual {
                        table,
                        column,
                        value,
                    }),
                    Err(_) => filters.push(Filter::GreaterThanOrEqual {
                        table,
                        column,
                        value: JsonValue::String(value.to_string()),
                    }),
                }
            } else if pattern.starts_with("lt.") {
                let value = &pattern.replace("lt.", "");
                match serde_json::from_str(value) {
                    Ok(value) => filters.push(Filter::LessThan {
                        table,
                        column,
                        value,
                    }),
                    Err(_) => filters.push(Filter::LessThan {
                        table,
                        column,
                        value: JsonValue::String(value.to_string()),
                    }),
                }
            } else if pattern.starts_with("lte.") {
                let value = &pattern.replace("lte.", "");
                match serde_json::from_str(value) {
                    Ok(value) => filters.push(Filter::LessThanOrEqual {
                        table,
                        column,
                        value,
                    }),
                    Err(_) => filters.push(Filter::LessThanOrEqual {
                        table,
                        column,
                        value: JsonValue::String(value.to_string()),
                    }),
                }
            } else if pattern.starts_with("is.") {
                let value = pattern.replace("is.", "");
                match value.to_lowercase().as_str() {
                    "null" => filters.push(Filter::Is {
                        table,
                        column,
                        value: JsonValue::Null,
                    }),
                    _ => match serde_json::from_str(&value) {
                        Ok(value) => filters.push(Filter::Is {
                            table,
                            column,
                            value,
                        }),
                        Err(_) => tracing::warn!("invalid 'is' filter value {pattern}"),
                    },
                };
            } else if pattern.starts_with("is_not.") {
                let value = pattern.replace("is_not.", "");
                match value.to_lowercase().as_str() {
                    "null" => filters.push(Filter::IsNot {
                        table,
                        column,
                        value: JsonValue::Null,
                    }),
                    _ => match serde_json::from_str(&value) {
                        Ok(value) => filters.push(Filter::IsNot {
                            table,
                            column,
                            value,
                        }),
                        Err(_) => tracing::warn!("invalid 'is_not' filter value {pattern}"),
                    },
                };
            } else if pattern.starts_with("in.") {
                let separator = Regex::new(r"\s*,\s*").unwrap();
                let values = pattern.replace("in.", "");
                let values = match values.strip_prefix("(").and_then(|s| s.strip_suffix(")")) {
                    None => {
                        tracing::warn!("invalid 'in' filter value {pattern}");
                        ""
                    }
                    Some(s) => s,
                };
                let values = separator
                    .split(values)
                    .map(|v| serde_json::from_str::<JsonValue>(v).unwrap_or(json!(v.to_string())))
                    .collect::<Vec<_>>();
                filters.push(Filter::In {
                    table,
                    column,
                    value: json!(values),
                })
            } else if pattern.starts_with("not_in.") {
                let separator = Regex::new(r"\s*,\s*").unwrap();
                let values = pattern.replace("not_in.", "");
                let values = match values.strip_prefix("(").and_then(|s| s.strip_suffix(")")) {
                    None => {
                        tracing::warn!("invalid 'not_in' filter value {pattern}");
                        ""
                    }
                    Some(s) => s,
                };
                let values = separator
                    .split(values)
                    .map(|v| serde_json::from_str::<JsonValue>(v).unwrap_or(json!(v.to_string())))
                    .collect::<Vec<_>>();
                filters.push(Filter::NotIn {
                    table,
                    column,
                    value: json!(values),
                })
            }
        }
        Self {
            table_name,
            select,
            limit,
            offset,
            order_by,
            filters,
            ..Default::default()
        }
    }

    pub fn order_by(&mut self, column: &str) {
        self.order_by = vec![(column.to_string(), Order::ASC)];
    }

    pub fn limit(mut self, limit: &usize) -> Self {
        self.limit = *limit;
        self
    }

    pub fn offset(mut self, offset: &usize) -> Self {
        self.offset = *offset;
        self
    }

    pub fn filters(mut self, filters: &Vec<String>) -> Result<Self> {
        let basic = r"[\w\-]";
        let wildcarded = r"[\w\-%]";

        // Symbolic operators:
        let like = Regex::new(&format!(r#"^({basic}+)\s*~=\s*"?({wildcarded}+)"?$"#)).unwrap();
        let eq = Regex::new(&format!(r#"^({basic}+)\s*=\s*"?({basic}+)"?$"#)).unwrap();
        let not_eq = Regex::new(&format!(r#"^({basic}+)\s*!=\s*"?({basic}+)"?$"#)).unwrap();
        let gt = Regex::new(&format!(r"^({basic}+)\s*>\s*({basic}+)$")).unwrap();
        let gte = Regex::new(&format!(r"^({basic}+)\s*>=\s*({basic}+)$")).unwrap();
        let lt = Regex::new(&format!(r"^({basic}+)\s*<\s*({basic}+)$")).unwrap();
        let lte = Regex::new(&format!(r"^({basic}+)\s*<=\s*({basic}+)$")).unwrap();

        // Word-like operators:
        let is = Regex::new(&format!(r#"^({basic}+)\s+(IS|is)\s+"?({basic}+)"?$"#)).unwrap();
        let is_not = Regex::new(&format!(
            r#"^({basic}+)\s+(IS NOT|is not)\s+"?({basic}+)"?$"#
        ))
        .unwrap();
        let is_in = Regex::new(&format!(
            r#"^({basic}+)\s+(IN|in)\s+\(({basic}+(,\s*{basic}+)*)\)$"#
        ))
        .unwrap();
        let is_not_in = Regex::new(&format!(
            r#"^({basic}+)\s+(NOT IN|not in)\s+\(({basic}+(,\s*{basic}+)*)\)$"#
        ))
        .unwrap();

        // Closure used for text types:
        let maybe_quote_value = |value: &str| -> Result<JsonValue> {
            if value.starts_with("\"") {
                let value = serde_json::from_str(&value)?;
                Ok(value)
            } else {
                let value = serde_json::from_str(&format!(r#""{value}""#))?;
                Ok(value)
            }
        };
        for filter in filters {
            tracing::debug!("Applying filter: {filter}");
            if like.is_match(&filter) {
                let captures = like.captures(&filter).unwrap();
                let table = String::new();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = maybe_quote_value(&value)?;
                self.filters.push(Filter::Like {
                    table,
                    column,
                    value,
                });
            } else if eq.is_match(&filter) {
                let captures = eq.captures(&filter).unwrap();
                let table = String::new();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = maybe_quote_value(&value)?;
                self.filters.push(Filter::Equal {
                    table,
                    column,
                    value,
                });
            } else if not_eq.is_match(&filter) {
                let captures = not_eq.captures(&filter).unwrap();
                let table = String::new();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = maybe_quote_value(&value)?;
                self.filters.push(Filter::NotEqual {
                    table,
                    column,
                    value,
                });
            } else if gt.is_match(&filter) {
                let captures = gt.captures(&filter).unwrap();
                let table = String::new();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = maybe_quote_value(&value)?;
                self.filters.push(Filter::GreaterThan {
                    table,
                    column,
                    value,
                });
            } else if gte.is_match(&filter) {
                let captures = gte.captures(&filter).unwrap();
                let table = String::new();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = maybe_quote_value(value)?;
                self.filters.push(Filter::GreaterThanOrEqual {
                    table,
                    column,
                    value,
                });
            } else if lt.is_match(&filter) {
                let captures = lt.captures(&filter).unwrap();
                let table = String::new();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = maybe_quote_value(&value)?;
                self.filters.push(Filter::LessThan {
                    table,
                    column,
                    value,
                });
            } else if lte.is_match(&filter) {
                let captures = lte.captures(&filter).unwrap();
                let table = String::new();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = maybe_quote_value(&value)?;
                self.filters.push(Filter::LessThanOrEqual {
                    table,
                    column,
                    value,
                });
            } else if is.is_match(&filter) {
                let captures = is.captures(&filter).unwrap();
                let table = String::new();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(3).unwrap().as_str();
                let value = match value.to_lowercase().as_str() {
                    "null" => JsonValue::Null,
                    _ => maybe_quote_value(&value)?,
                };
                self.filters.push(Filter::Is {
                    table,
                    column,
                    value,
                });
            } else if is_not.is_match(&filter) {
                let captures = is_not.captures(&filter).unwrap();
                let table = String::new();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(3).unwrap().as_str();
                let value = match value.to_lowercase().as_str() {
                    "null" => JsonValue::Null,
                    _ => maybe_quote_value(&value)?,
                };
                self.filters.push(Filter::IsNot {
                    table,
                    column,
                    value,
                });
            } else if is_in.is_match(&filter) {
                let captures = is_in.captures(&filter).unwrap();
                let table = String::new();
                let column = captures.get(1).unwrap().as_str().to_string();
                let values = &captures.get(3).unwrap().as_str();
                let separator = Regex::new(r"\s*,\s*").unwrap();
                let values = separator
                    .split(values)
                    .map(|v| serde_json::from_str::<JsonValue>(v).unwrap_or(json!(v.to_string())))
                    .collect::<Vec<_>>();
                self.filters.push(Filter::In {
                    table,
                    column,
                    value: json!(values),
                });
            } else if is_not_in.is_match(&filter) {
                let captures = is_not_in.captures(&filter).unwrap();
                let table = String::new();
                let column = captures.get(1).unwrap().as_str().to_string();
                let values = &captures.get(3).unwrap().as_str();
                let separator = Regex::new(r"\s*,\s*").unwrap();
                let values = separator
                    .split(values)
                    .map(|v| serde_json::from_str::<JsonValue>(v).unwrap_or(json!(v.to_string())))
                    .collect::<Vec<_>>();
                self.filters.push(Filter::NotIn {
                    table,
                    column,
                    value: json!(values),
                });
            } else {
                return Err(RelatableError::ConfigError(format!("invalid filter {filter}")).into());
            }
        }
        Ok(self)
    }

    pub fn like<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::Like {
            table: String::new(),
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn eq<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::Equal {
            table: String::new(),
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn not_eq<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::NotEqual {
            table: String::new(),
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn gt<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::GreaterThan {
            table: String::new(),
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn gte<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::GreaterThanOrEqual {
            table: String::new(),
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn lt<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::LessThan {
            table: String::new(),
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn lte<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::LessThanOrEqual {
            table: String::new(),
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn is<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::Is {
            table: String::new(),
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn is_not<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::IsNot {
            table: String::new(),
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn is_in<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::In {
            table: String::new(),
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn is_not_in<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::NotIn {
            table: String::new(),
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn left_join_using(&mut self, table: &str, column: &str) {
        self.joins
            .push(format!(r#"LEFT JOIN "{table}" USING ("{column}")"#));
    }

    pub fn to_sqlite(&self) -> Result<(String, Vec<JsonValue>)> {
        tracing::debug!("to_sqlite: {self:?}");
        let mut lines = Vec::new();
        let mut params = Vec::new();
        if self.select.len() == 0 {
            if self.joins.len() > 0 {
                lines.push(format!(r#"SELECT "{}".*,"#, self.table_name));
            } else {
                lines.push("SELECT *".to_string());
            }
            for filter in &self.filters {
                let (_, c, _, _) = filter.parts();
                if c == "_change_id" {
                    lines.push(format!(
                        r#", (SELECT MAX(change_id) FROM history
                          WHERE "table" = '{}'
                            AND "row" = "{}"._id
                        ) AS _change_id"#,
                        self.table_name, self.table_name
                    ));
                }
            }
        } else {
            lines.push("SELECT".to_string());
            for filter in &self.filters {
                let (_, c, _, _) = filter.parts();
                if c == "_change_id" {
                    lines.push(format!(
                        r#"(SELECT MAX(change_id) FROM history
                          WHERE "table" = '{}'
                            AND "row" = "{}"._id
                        ) AS _change_id"#,
                        self.table_name, self.table_name
                    ));
                }
            }
            for column in self.select.clone() {
                let mut t = ",";
                if &column == self.select.last().unwrap() {
                    t = "";
                }
                lines.push(format!(r#"  "{column}"{t}"#));
            }
        }
        params.push(json!(self.table_name)); // the real table name
        lines.push(format!(r#"FROM "{}""#, self.table_name));
        for join in self.joins.clone() {
            lines.push(join);
        }
        for (i, filter) in self.filters.iter().enumerate() {
            let keyword = if i == 0 { "WHERE" } else { "  AND" };
            let (s, p) = filter.to_sqlite()?;
            lines.push(format!("{keyword} {s}"));
            params.append(&mut p.clone());
        }
        if self.order_by.len() == 0 && self.joins.len() == 0 {
            lines.push(format!(r#"ORDER BY "{}"._order ASC"#, self.table_name));
        }
        for (column, order) in &self.order_by {
            lines.push(format!(r#"ORDER BY "{column}" {order:?}"#));
        }
        if self.limit > 0 {
            lines.push(format!("LIMIT {}", self.limit));
        }
        if self.offset > 0 {
            lines.push(format!("OFFSET {}", self.offset));
        }
        Ok((lines.join("\n"), params))
    }

    pub fn to_sqlite_count(&self) -> Result<(String, Vec<JsonValue>)> {
        tracing::debug!("to_sqlite_count: {self:?}");
        let mut lines = Vec::new();
        let mut params = Vec::new();
        lines.push("SELECT COUNT(*) AS count".to_string());
        lines.push(format!(r#"FROM "{}""#, self.table_name));
        for join in self.joins.clone() {
            lines.push(join);
        }
        for (i, filter) in self.filters.iter().enumerate() {
            let keyword = if i == 0 { "WHERE" } else { "  AND" };
            let (s, p) = filter.to_sqlite_count()?;
            lines.push(format!("{keyword} {s}"));
            params.append(&mut p.clone());
        }
        Ok((lines.join("\n"), params))
    }

    pub fn to_params(&self) -> Result<JsonMap<String, JsonValue>> {
        if self.table_name.is_empty() {
            return Err(RelatableError::InputError(
                "Missing required field: `table` in to_sql()".to_string(),
            )
            .into());
        }

        let mut params = JsonMap::new();
        if self.select.len() > 0 {
            params.insert("select".to_string(), self.select.join(",").into());
        }
        if self.filters.len() > 0 {
            for filter in &self.filters {
                let (table, column) = match &filter {
                    Filter::Like {
                        table,
                        column,
                        value: _,
                    }
                    | Filter::Equal {
                        table,
                        column,
                        value: _,
                    }
                    | Filter::NotEqual {
                        table,
                        column,
                        value: _,
                    }
                    | Filter::GreaterThan {
                        table,
                        column,
                        value: _,
                    }
                    | Filter::GreaterThanOrEqual {
                        table,
                        column,
                        value: _,
                    }
                    | Filter::LessThan {
                        table,
                        column,
                        value: _,
                    }
                    | Filter::LessThanOrEqual {
                        table,
                        column,
                        value: _,
                    }
                    | Filter::Is {
                        table,
                        column,
                        value: _,
                    }
                    | Filter::IsNot {
                        table,
                        column,
                        value: _,
                    }
                    | Filter::In {
                        table,
                        column,
                        value: _,
                    }
                    | Filter::NotIn {
                        table,
                        column,
                        value: _,
                    } => (table, column),
                    Filter::InSubquery { .. } => {
                        return Err(RelatableError::InputError(format!(
                            "Cannot render InSubquery filter to_params {self:?}"
                        ))
                        .into());
                    }
                };

                let lhs = match table.as_str() {
                    "" => column.clone(),
                    _ => format!("{table}.{column}"),
                };
                let lhs = unquote(&lhs).unwrap_or(lhs.to_string());

                if let Err(e) = is_simple(&lhs) {
                    return Err(RelatableError::InputError(format!(
                        "While reading filters, got error: {}",
                        e
                    ))
                    .into());
                }
                params.insert(lhs, format!("{}", filter.to_url()?).into());
            }
        }
        if self.limit > 0 {
            params.insert("limit".into(), self.limit.into());
        }
        if self.offset > 0 {
            params.insert("offset".into(), self.offset.into());
        }
        Ok(params)
    }

    pub fn to_url(&self, base: &str, format: &Format) -> Result<String> {
        let table_name = unquote(&self.table_name).unwrap_or(self.table_name.to_string());
        if let Err(e) = is_simple(&table_name) {
            return Err(RelatableError::InputError(format!(
                "While reading table name, got error: {}",
                e
            ))
            .into());
        }
        let table_name = format!("{base}/{table_name}{format}");

        let params = &self.to_params()?.clone();
        if params.len() > 0 {
            let mut parts = vec![];
            for (column, value) in params.iter() {
                let s = match value {
                    serde_json::Value::String(s) => s.as_str().into(),
                    _ => format!("{}", value),
                };
                parts.push(format!("{column}={s}"));
            }
            Ok(format!("{}?{}", table_name, parts.join("&")))
        } else {
            Ok(table_name.to_string())
        }
    }
}

// Web Site Stuff

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Site {
    pub title: String,
    pub root: String,
    pub editable: bool,
    pub user: Account,
    pub users: IndexMap<String, UserCursor>,
    pub tables: IndexMap<String, Table>,
}

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct Account {
    name: String,
    color: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Cursor {
    table: String,
    row: usize,
    column: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct UserCursor {
    name: String,
    color: String,
    cursor: Cursor,
    datetime: String,
}
