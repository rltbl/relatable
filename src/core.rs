//! # rltbl/relatable
//!
//! This is relatable (rltbl::core).

use crate::sql::{
    begin, connect, is_simple, json_to_string, lock_connection, query, query_one, query_tx,
    query_value, query_value_tx, DbConnection, DbTransaction, JsonRow, VecInto,
};

use anyhow::Result;
use enquote::unquote;
use indexmap::IndexMap;
use minijinja::{path_loader, Environment};
use regex::Regex;
use serde::{Deserialize, Serialize};
use serde_json::{from_str, json, to_value, Map as JsonMap, Value as JsonValue};
use std::{fmt::Display, fs::File, io::Write, path::Path as FilePath};
use tabwriter::TabWriter;

#[derive(Debug)]
pub enum RelatableError {
    /// An error in the configuration of a ChangeSet:
    ChangeError(String),
    /// An error in the Relatable configuration:
    ConfigError(String),
    /// An error that occurred while reading or writing to a CSV/TSV:
    // CsvError(csv::Error),
    /// An error involving the data:
    DataError(String),
    /// An error generated by the underlying database:
    // DatabaseError(sqlx::Error),
    /// An error generated when the database is missing
    InitError(String),
    /// An error from an unsupported format
    FormatError(String),
    /// An error in the inputs to a function:
    InputError(String),
    /// An error that occurred while reading/writing to stdio:
    IOError(std::io::Error),
    /// An error that occurred while serialising or deserialising to/from JSON:
    // SerdeJsonError(serde_json::Error),
    /// An error that occurred while parsing a regex:
    // RegexError(regex::Error),
    /// An error that occurred because of a user's action
    UserError(String),
}

impl std::fmt::Display for RelatableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

impl std::error::Error for RelatableError {}

#[derive(Debug)]
pub struct Relatable {
    pub connection: DbConnection,
    // pub minijinja: Environment<'static>,
    pub default_limit: usize,
    pub max_limit: usize,
}

impl Relatable {
    pub async fn connect() -> Result<Self> {
        // Set up database connection.
        let path = ".relatable/relatable.db";
        let file = FilePath::new(path);
        if !file.exists() {
            return Err(RelatableError::InitError(
                "First create a database with `rltbl init`".into(),
            )
            .into());
        }
        let connection = connect(path).await?;
        Ok(Self {
            connection,
            // minijinja: env,
            default_limit: 100,
            max_limit: 1000,
        })
    }

    pub async fn init(force: &bool) -> Result<Self> {
        let path = ".relatable/relatable.db";
        let dir = FilePath::new(path)
            .parent()
            .expect("parent should be defined");
        if !dir.exists() {
            std::fs::create_dir_all(&dir).unwrap();
            tracing::info!("Created '{dir:?}' directory");
        }
        let file = FilePath::new(path);
        if file.exists() {
            if *force {
                std::fs::remove_file(&file).unwrap();
                tracing::info!("Removed '{file:?}' file");
            } else {
                return Err(RelatableError::InitError(format!(
                    "File {file:?} already exists. Use --force to overwrite"
                ))
                .into());
            }
        }
        File::create(path)?;

        let rltbl = Relatable::connect().await?;

        // Create and populate the table table
        let sql = r#"CREATE TABLE 'table' (
          _id INTEGER PRIMARY KEY,
          _order INTEGER UNIQUE,
          'table' TEXT UNIQUE
        )"#;
        query(&rltbl.connection, sql, None).await.unwrap();

        let sql = r#"CREATE TRIGGER 'table_order'
          AFTER INSERT ON 'table'
          WHEN NEW._order IS NULL
          BEGIN
            UPDATE 'table' SET _order = (1000 * NEW._id)
            WHERE _id = NEW._id;
          END
        "#;
        query(&rltbl.connection, sql, None).await.unwrap();

        let sql = "INSERT INTO 'table' ('table') VALUES ('table')";
        query(&rltbl.connection, sql, None).await.unwrap();

        // Create the change and history tables
        let sql = r#"CREATE TABLE 'user' (
          'name' TEXT PRIMARY KEY,
          'color' TEXT,
          'cursor' TEXT,
          'datetime' TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )"#;
        query(&rltbl.connection, sql, None).await.unwrap();

        // Create the change and history tables
        let sql = r#"CREATE TABLE 'change' (
          change_id INTEGER PRIMARY KEY,
          'datetime' TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          'user' TEXT NOT NULL,
          'action' TEXT NOT NULL,
          'table' TEXT NOT NULL,
          'description' TEXT,
          'content' TEXT,
          FOREIGN KEY ("user") REFERENCES user("name")
        )"#;
        query(&rltbl.connection, sql, None).await.unwrap();

        let sql = r#"CREATE TABLE 'history' (
          history_id INTEGER PRIMARY KEY,
          change_id INTEGER NOT NULL,
          'table' TEXT NOT NULL,
          'row' INTEGER NOT NULL,
          'before' TEXT,
          'after' TEXT,
          FOREIGN KEY ("change_id") REFERENCES change("change_id"),
          FOREIGN KEY ("table") REFERENCES "table"("table")
        )"#;
        query(&rltbl.connection, sql, None).await.unwrap();

        Ok(rltbl)
    }

    pub fn render<T: Serialize>(&self, template: &str, context: T) -> Result<String> {
        // TODO: Optionally we should set up the environment once and store it,
        // but during development it's very convenient to rebuild every time.
        let mut env = Environment::new();

        // Load default template strings at compile time.
        let templates = IndexMap::from([("table.html", include_str!("templates/table.html"))]);

        // Load templates dynamically if src/templates/ exists,
        // otherwise use strings from compile time.
        // TODO: This should be a configuration option.
        let dir = "src/templates/";
        if FilePath::new(dir).is_dir() {
            env.set_loader(path_loader(dir));
        };
        for (name, content) in templates {
            match env.get_template(name) {
                Ok(_) => (),
                Err(_) => env.add_template(name, content).unwrap(),
            }
        }

        env.get_template(template)?
            .render(context)
            .map_err(|e| e.into())
    }

    pub async fn get_table(&self, table_name: &str, connection: &DbConnection) -> Result<Table> {
        let statement = r#"SELECT max(change_id) FROM history WHERE "table" = ?"#;
        let params = json!([table_name]);
        let change_id = match query_value(connection, &statement, Some(&params)).await? {
            Some(value) => value.as_u64().unwrap_or_default() as usize,
            None => 0,
        };
        Ok(Table::from_change_id(table_name, change_id))
    }

    pub async fn get_table_tx(
        &self,
        table_name: &str,
        tx: &mut DbTransaction<'_>,
    ) -> Result<Table> {
        let statement = r#"SELECT max(change_id) FROM history WHERE "table" = ?"#;
        let params = json!([table_name]);
        let change_id = match query_value_tx(tx, &statement, Some(&params)).await? {
            Some(value) => value.as_u64().unwrap_or_default() as usize,
            None => 0,
        };
        Ok(Table::from_change_id(table_name, change_id))
    }

    pub fn from(&self, table_name: &str) -> Select {
        Select {
            table_name: table_name.to_string(),
            limit: self.default_limit,
            ..Default::default()
        }
    }

    pub async fn fetch_columns(&self, table_name: &str) -> Result<Vec<Column>> {
        // WARN: SQLite only!
        let statement = format!(r#"SELECT * FROM pragma_table_info("{table_name}");"#);
        Ok(query(&self.connection, &statement, None)
            .await?
            .iter()
            .map(|row| Column {
                name: row.get_string("name"),
            })
            .filter(|c| !c.name.starts_with("_"))
            .collect())
    }

    pub async fn fetch(&self, select: &Select) -> Result<ResultSet> {
        let table = self
            .get_table(select.table_name.as_str(), &self.connection)
            .await?;
        let columns = self.fetch_columns(&select.table_name).await?;
        let (statement, params) = select.to_sqlite()?;
        tracing::debug!("SQL {statement}");
        let params = json!(params);
        let json_rows = query(&self.connection, &statement, Some(&params)).await?;

        let count = json_rows.len();
        let total = match json_rows.get(0) {
            Some(row) => row
                .content
                .get("_total")
                .and_then(|x| x.as_u64())
                .unwrap_or(0) as usize,
            None => 0,
        };

        let rows: Vec<Row> = json_rows.vec_into();
        Ok(ResultSet {
            range: Range {
                count,
                total,
                start: select.offset + 1,
                end: select.offset + count,
            },
            select: select.clone(),
            table,
            columns,
            rows,
        })
    }

    pub async fn fetch_json_rows(&self, select: &Select) -> Result<Vec<JsonRow>> {
        let (statement, params) = select.to_sqlite()?;
        let params = json!(params);
        query(&self.connection, &statement, Some(&params)).await
    }

    pub async fn record_changes(changeset: &ChangeSet, tx: &mut DbTransaction<'_>) -> Result<()> {
        let user = changeset.user.clone();
        let action = changeset.action.to_string();
        let table = changeset.table.clone();
        let description = changeset.description.clone();

        let statement = r#"INSERT INTO change('user', 'action', 'table', 'description', 'content')
                           VALUES (?, ?, ?, ?, ?)
                           RETURNING change_id"#;
        let content = to_value(&changeset.changes).unwrap_or_default();
        let params = json!([user, action, table, description, content]);
        let change_id = query_value_tx(tx, &statement, Some(&params)).await?;
        let change_id = change_id
            .expect("a change_id")
            .as_u64()
            .expect("an integer");

        for change in &changeset.changes {
            match change {
                Change::Update {
                    row,
                    column: _,
                    value: _,
                }
                | Change::Add { row } => {
                    let sql = r#"INSERT INTO "history"
                                 ('change_id', 'table', 'row', 'before', 'after')
                                 VALUES (?, ?, ?, 'TODO', 'TODO')
                                 RETURNING "history_id""#;
                    let params = json!([change_id, table, row]);
                    query_value_tx(tx, &sql, Some(&params)).await?;
                }
            };
        }
        Ok(())
    }

    pub async fn set_values(&self, changeset: &ChangeSet) -> Result<()> {
        // Get the connection and begin a transaction:
        let mut locked_conn = lock_connection(&self.connection).await;
        let mut tx = begin(&self.connection, &mut locked_conn).await?;

        // Make sure the user is present.
        let user = changeset.user.clone();
        let color = random_color::RandomColor::new().to_hex();
        let statement = r#"INSERT OR IGNORE INTO user("name", "color") VALUES (?, ?)"#;
        let params = json!([user, color]);
        query_tx(&mut tx, &statement, Some(&params)).await?;

        // Update the user's cursor position.
        let cursor = changeset.to_cursor()?;
        let statement =
            r#"UPDATE user SET "cursor" = ?, "datetime" = CURRENT_TIMESTAMP WHERE "name" = ?"#;
        let params = json!([to_value(cursor).unwrap_or_default(), user]);
        query_value_tx(&mut tx, &statement, Some(&params)).await?;

        // Actually make the changes:
        let table = changeset.table.clone();
        for change in &changeset.changes {
            tracing::debug!("CHANGE {change:?}");
            match change {
                Change::Update { row, column, value } => {
                    // WARN: This just sets text!
                    let sql = format!(r#"UPDATE "{table}" SET "{column}" = ? WHERE _id = ?"#,);
                    // TODO: Render JSON to SQL properly.
                    let value = json_to_string(value);
                    let params = json!([value, row]);
                    query_tx(&mut tx, &sql, Some(&params)).await?;
                }
                _ => {
                    return Err(RelatableError::InputError(format!(
                        "Don't know how to apply set_values() to a change set like {changeset:?}"
                    ))
                    .into());
                }
            };
        }

        // Record the changes to the change and history tables:
        Self::record_changes(changeset, &mut tx).await?;

        // Commit the transaction:
        tx.commit().await?;

        Ok(())
    }

    pub async fn get_user(&self, username: &str) -> Account {
        let statement = format!(r#"SELECT * FROM user WHERE name = '{username}' LIMIT 1"#);
        let user = query_one(&self.connection, &statement).await;
        if let Ok(user) = user {
            if let Some(user) = user {
                return Account {
                    name: username.to_string(),
                    color: user.get_string("color"),
                };
            }
        }
        Account {
            ..Default::default()
        }
    }

    pub async fn get_users(&self) -> Result<IndexMap<String, UserCursor>> {
        let mut users = IndexMap::new();
        // let statement = format!(
        //     r#"SELECT * FROM user WHERE cursor IS NOT NULL
        //        AND "datetime" >= DATETIME('now', '-10 minutes')"#
        // );
        let statement = format!(r#"SELECT * FROM user WHERE cursor IS NOT NULL"#);
        let rows = query(&self.connection, &statement, None).await?;
        for row in rows {
            let name = row.get_string("name");
            users.insert(
                name.clone(),
                UserCursor {
                    name: name.clone(),
                    color: row.get_string("color"),
                    cursor: from_str(&row.get_string("cursor"))?,
                    datetime: row.get_string("datetime"),
                },
            );
        }
        Ok(users)
    }

    pub async fn get_tables(&self) -> Result<IndexMap<String, Table>> {
        let mut tables = IndexMap::new();
        let statement = format!(
            r#"SELECT *,
                 (SELECT max(change_id)
                  FROM history
                  WHERE history."table" = "table"."table"
                 ) AS _change_id
               FROM 'table'"#
        );

        let rows = query(&self.connection, &statement, None).await?;
        for row in rows {
            let name = row.get_string("table");
            tables.insert(
                name.clone(),
                Table {
                    name: name.clone(),
                    change_id: row
                        .content
                        .get("_change_id")
                        .and_then(|i| i.as_u64())
                        .unwrap_or_default() as usize,
                    ..Default::default()
                },
            );
        }
        Ok(tables)
    }

    pub async fn get_site(&self, username: &str) -> Site {
        let mut users = self.get_users().await.unwrap_or_default();
        users.shift_remove(username);
        Site {
            title: "RLTBL".to_string(),
            root: "".to_string(),
            user: self.get_user(username).await,
            users,
            tables: self.get_tables().await.unwrap_or_default(),
        }
    }

    pub async fn add_row(&self, table: &str, user: &str, row: &JsonRow) -> Result<Row> {
        // Get the connection and begin a transaction:
        let mut locked_conn = lock_connection(&self.connection).await;
        let mut tx = begin(&self.connection, &mut locked_conn).await?;

        let row = self.add_row_tx(&mut tx, table, user, row).await?;

        // Commit the transaction:
        tx.commit().await?;

        Ok(row)
    }

    pub async fn add_row_tx(
        &self,
        tx: &mut DbTransaction<'_>,
        table_name: &str,
        user: &str,
        json_row: &JsonRow,
    ) -> Result<Row> {
        let table = self.get_table_tx(table_name, tx).await?;
        if !table.editable {
            return Err(
                RelatableError::InputError(format!("{} is not editable.", table.name,)).into(),
            );
        }

        let new_row = Row::new(&table, json_row, tx).await?;
        let sql = new_row.as_insert(table_name);
        query_tx(tx, &sql, None).await?;

        // Record the change to the history table:
        let changeset = ChangeSet {
            action: ChangeAction::Do,
            table: table_name.to_string(),
            user: user.to_string(),
            description: "Add one row".to_string(),
            changes: vec![Change::Add { row: new_row.id }],
        };
        Self::record_changes(&changeset, tx).await?;

        Ok(new_row)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ChangeSet {
    pub action: ChangeAction,
    pub table: String,
    pub user: String,
    pub description: String,
    pub changes: Vec<Change>,
}

impl ChangeSet {
    fn to_cursor(&self) -> Result<Cursor> {
        let table = self.table.clone();
        match self.changes.first() {
            Some(change) => match change {
                Change::Update {
                    row,
                    column,
                    value: _,
                } => Ok(Cursor {
                    table,
                    row: *row,
                    column: column.to_string(),
                }),
                Change::Add { row: _ } => todo!(),
            },
            None => Err(RelatableError::ChangeError("No changes in set".into()).into()),
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum ChangeAction {
    Do,
    Undo,
    Redo,
}

impl Display for ChangeAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ChangeAction::Do => write!(f, "do"),
            ChangeAction::Undo => write!(f, "undo"),
            ChangeAction::Redo => write!(f, "redo"),
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum Change {
    Update {
        row: usize,
        column: String,
        value: JsonValue,
    },
    Add {
        row: usize,
    }, // Delete
       // Move
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Cell {
    value: JsonValue,
    text: String,
}

impl From<&JsonValue> for Cell {
    fn from(value: &JsonValue) -> Self {
        Self {
            value: value.clone(),
            text: match value {
                JsonValue::String(value) => value.to_string(),
                value => format!("{value}"),
            },
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Row {
    pub id: usize,
    pub order: usize,
    pub change_id: usize,
    pub cells: IndexMap<String, Cell>,
}

impl Row {
    async fn get_next_id(table: &str, tx: &mut DbTransaction<'_>) -> Result<usize> {
        let sql = format!(r#"SELECT MAX("_id") FROM "{}""#, table);
        let current_row_id = match query_value_tx(tx, &sql, None).await? {
            Some(value) => value.as_u64().unwrap_or_default() as usize,
            None => 0,
        };
        Ok(current_row_id + 1)
    }

    async fn new(table: &Table, json_row: &JsonRow, tx: &mut DbTransaction<'_>) -> Result<Self> {
        let mut row = Row::from(json_row.clone());
        row.id = Self::get_next_id(table.name.as_str(), tx).await?;
        row.order = 1000 * row.id;
        row.change_id = table.change_id;
        Ok(row)
    }

    fn to_strings(&self) -> Vec<String> {
        self.cells.values().map(|cell| cell.text.clone()).collect()
    }

    fn as_insert(&self, table: &str) -> String {
        let id = self.id;
        let order = self.order;
        let columns = self
            .cells
            .keys()
            .map(|k| format!(r#""{k}""#))
            .collect::<Vec<_>>()
            .join(", ");
        let values = self
            .to_strings()
            .iter()
            .map(|v| format!("'{v}'"))
            .collect::<Vec<_>>()
            .join(", ");
        format!(
            r#"INSERT INTO "{table}"
               ("_id", "_order", {columns})
               VALUES ({id}, {order}, {values})"#
        )
    }
}

impl From<Row> for Vec<String> {
    fn from(row: Row) -> Self {
        row.to_strings()
    }
}

impl From<JsonRow> for Row {
    fn from(row: JsonRow) -> Self {
        Self {
            id: row
                .content
                .get("_id")
                .and_then(|i| i.as_u64())
                .unwrap_or_default() as usize,
            order: row
                .content
                .get("_order")
                .and_then(|i| i.as_u64())
                .unwrap_or_default() as usize,
            change_id: row
                .content
                .get("_change_id")
                .and_then(|i| i.as_u64())
                .unwrap_or_default() as usize,
            cells: row
                .content
                .iter()
                // Ignore columns that start with "_"
                .filter(|(k, _)| !k.starts_with("_"))
                .map(|(k, v)| (k.clone(), v.into()))
                .collect(),
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Column {
    name: String,
    // sqltype: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Table {
    name: String,
    // The history_id of the most recent update to this table.
    change_id: usize,
    editable: bool,
}

impl Default for Table {
    fn default() -> Self {
        Self {
            name: String::default(),
            change_id: usize::default(),
            editable: true,
        }
    }
}

impl Table {
    fn from_change_id(table_name: &str, change_id: usize) -> Self {
        Table {
            name: table_name.to_string(),
            change_id: change_id,
            ..Default::default()
        }
    }
}

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct Range {
    count: usize,
    total: usize,
    start: usize,
    end: usize,
}

impl std::fmt::Display for Range {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Rows {}-{} of {}", self.start, self.end, self.total)
    }
}

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct ResultSet {
    select: Select,
    range: Range,
    table: Table,
    columns: Vec<Column>,
    rows: Vec<Row>,
}

impl std::fmt::Display for ResultSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut tw = TabWriter::new(vec![]);
        tw.write(format!("{}\n", self.range).as_bytes())
            .unwrap_or_default();
        let header = &self
            .columns
            .iter()
            .map(|c| c.name.clone())
            .collect::<Vec<String>>();
        tw.write(format!("{}\n", header.join("\t")).as_bytes())
            .unwrap_or_default();
        for row in &self.rows {
            tw.write(format!("{}\n", row.to_strings().join("\t")).as_bytes())
                .unwrap_or_default();
        }
        tw.flush().expect("TabWriter to flush");
        let written = String::from_utf8(tw.into_inner().unwrap()).unwrap();
        write!(f, "{written}")
    }
}

// Selects and Filters

pub type QueryParams = IndexMap<String, String>;

pub enum Format {
    Html,
    Json,
    PrettyJson,
    Default,
}

impl Display for Format {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        // TODO: This should be factored out.
        let result = match self {
            Format::Html => ".html",
            Format::Json => ".json",
            Format::PrettyJson => ".pretty.json",
            Format::Default => "",
        };
        write!(f, "{result}")
    }
}

impl TryFrom<&String> for Format {
    fn try_from(path: &String) -> Result<Self> {
        let path = path.to_lowercase();
        let format = if path.ends_with(".pretty.json") {
            Format::PrettyJson
        } else if path.ends_with(".json") {
            Format::Json
        } else if path.ends_with(".html") || path.ends_with(".htm") {
            Format::Html
        } else if path.contains(".") {
            return Err(
                RelatableError::FormatError(format!("Unknown format for path {path}")).into(),
            );
        } else {
            Format::Default
        };
        Ok(format)
    }

    type Error = anyhow::Error;
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum Filter {
    Equal { column: String, value: JsonValue },
    NotEqual { column: String, value: JsonValue },
    GreaterThan { column: String, value: JsonValue },
    GreaterThanOrEqual { column: String, value: JsonValue },
    LessThan { column: String, value: JsonValue },
    LessThanOrEqual { column: String, value: JsonValue },
    Is { column: String, value: JsonValue },
    IsNot { column: String, value: JsonValue },
    In { column: String, value: JsonValue },
    NotIn { column: String, value: JsonValue },
}

fn render_in_not_in<S: Into<String>>(
    lhs: S,
    options: &Vec<JsonValue>,
    positive: bool,
) -> Result<String> {
    let negation;
    if !positive {
        negation = " NOT";
    } else {
        negation = "";
    }

    let mut values = vec![];
    let mut is_string_list = false;
    for (i, option) in options.iter().enumerate() {
        match option {
            JsonValue::String(s) => {
                if i == 0 {
                    is_string_list = true;
                } else if !is_string_list {
                    return Err(RelatableError::InputError(format!(
                        "{:?} contains both text and numeric types.",
                        options
                    ))
                    .into());
                }
                let value = unquote(s).unwrap_or(s.clone());
                values.push(format!("'{value}'"))
            }
            JsonValue::Number(n) => {
                if i == 0 {
                    is_string_list = false;
                } else if is_string_list {
                    return Err(RelatableError::InputError(format!(
                        "{:?} contains both text and numeric types.",
                        options
                    ))
                    .into());
                }
                values.push(format!("{n}"))
            }
            _ => {
                return Err(RelatableError::InputError(format!(
                    "{:?} is not an array of strings or numbers.",
                    options
                ))
                .into())
            }
        };
    }
    let value_list = format!("({})", values.join(", "));
    let filter_sql = format!("{}{} IN {}", lhs.into(), negation, value_list);
    Ok(filter_sql)
}

impl Filter {
    pub fn to_url(&self) -> Result<String> {
        fn handle_string_value(token: &str) -> String {
            let reserved = vec![':', ',', '.', '(', ')'];
            if token.chars().all(char::is_numeric) || reserved.iter().any(|&c| token.contains(c)) {
                format!("\"{}\"", token)
            } else {
                token.to_string()
            }
        }

        let (operator, value) = match self {
            Filter::Equal { column: _, value } => ("eq.", value),
            Filter::NotEqual { column: _, value } => ("not_eq.", value),
            Filter::GreaterThan { column: _, value } => ("gt.", value),
            Filter::GreaterThanOrEqual { column: _, value } => ("gte.", value),
            Filter::LessThan { column: _, value } => ("lt.", value),
            Filter::LessThanOrEqual { column: _, value } => ("lte.", value),
            Filter::Is { column: _, value } => ("is.", value),
            Filter::IsNot { column: _, value } => ("is_not.", value),
            Filter::In { column: _, value } => ("in.", value),
            Filter::NotIn { column: _, value } => ("not_in.", value),
        };

        let rhs = match &value {
            JsonValue::String(s) => handle_string_value(&s),
            JsonValue::Number(n) => format!("{}", n),
            JsonValue::Array(v) => {
                let mut list = vec![];
                for item in v {
                    match item {
                        JsonValue::String(s) => {
                            list.push(handle_string_value(&s));
                        }
                        JsonValue::Number(n) => list.push(n.to_string()),
                        _ => {
                            return Err(RelatableError::DataError(format!(
                                "Not all list items in {:?} are strings or numbers.",
                                v
                            ))
                            .into());
                        }
                    };
                }
                format!("({})", list.join(","))
            }
            _ => {
                return Err(RelatableError::DataError(format!(
                    "RHS of Filter: {:?} is not a string, number, or list",
                    self
                ))
                .into());
            }
        };

        Ok(format!("{operator}{rhs}"))
    }

    pub fn to_sqlite(&self) -> Result<String> {
        // TODO: This should be factored out.
        fn json_to_string(value: &JsonValue) -> String {
            match value {
                JsonValue::Null => "NULL".to_string(),
                JsonValue::Bool(value) => value.to_string(),
                JsonValue::Number(value) => value.to_string(),
                JsonValue::String(value) => format!("'{value}'"),
                JsonValue::Array(value) => format!("'{value:?}'"),
                JsonValue::Object(value) => format!("'{value:?}'"),
            }
        }
        match self {
            Filter::Equal { column, value } => {
                let value = json_to_string(&value);
                Ok(format!(r#""{column}" = {value}"#))
            }
            Filter::NotEqual { column, value } => {
                let value = json_to_string(&value);
                Ok(format!(r#""{column}" <> {value}"#))
            }
            Filter::GreaterThan { column, value } => {
                let value = json_to_string(&value);
                Ok(format!(r#""{column}" > {value}"#))
            }
            Filter::GreaterThanOrEqual { column, value } => {
                let value = json_to_string(&value);
                Ok(format!(r#""{column}" >= {value}"#))
            }
            Filter::LessThan { column, value } => {
                let value = json_to_string(&value);
                Ok(format!(r#""{column}" < {value}"#))
            }
            Filter::LessThanOrEqual { column, value } => {
                let value = json_to_string(&value);
                Ok(format!(r#""{column}" <= {value}"#))
            }
            Filter::Is { column, value } => {
                // Note that we are presupposing SQLite syntax which is not universal for IS:
                let value = json_to_string(&value);
                Ok(format!(r#""{column}" IS {value}"#))
            }
            Filter::IsNot { column, value } => {
                // Note that we are presupposing SQLite syntax which is not universal for IS:
                let value = json_to_string(&value);
                Ok(format!(r#""{column}" IS NOT {value}"#))
            }
            Filter::In { column, value } => {
                if let JsonValue::Array(values) = value {
                    let filter_str = match render_in_not_in(column, values, true) {
                        Err(e) => {
                            return Err(RelatableError::DataError(format!(
                                "Error rendering 'in' filter: {e}"
                            ))
                            .into());
                        }
                        Ok(filter_str) => filter_str,
                    };
                    Ok(format!("{filter_str}"))
                } else {
                    Err(RelatableError::DataError(format!("Invalid 'in' value: {value}")).into())
                }
            }
            Filter::NotIn { column, value } => {
                if let JsonValue::Array(values) = value {
                    let filter_str = match render_in_not_in(column, values, false) {
                        Err(e) => {
                            return Err(RelatableError::DataError(format!(
                                "Error rendering 'not in' filter: {e}"
                            ))
                            .into());
                        }
                        Ok(filter_str) => filter_str,
                    };
                    Ok(format!("{filter_str}"))
                } else {
                    Err(
                        RelatableError::DataError(format!("Invalid 'not in' value: {value}"))
                            .into(),
                    )
                }
            }
        }
    }
}

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct Select {
    pub table_name: String,
    pub limit: usize,
    pub offset: usize,
    pub filters: Vec<Filter>,
}

impl Select {
    pub fn from_path_and_query(rltbl: &Relatable, path: &str, query_params: &QueryParams) -> Self {
        let table_name = path.split(".").next().unwrap_or_default().to_string();
        let mut filters = Vec::new();
        for (column, pattern) in query_params {
            if pattern.starts_with("eq.") {
                let column = column.to_string();
                let value = serde_json::from_str(&pattern.replace("eq.", ""));
                match value {
                    Ok(value) => filters.push(Filter::Equal { column, value }),
                    Err(_) => tracing::warn!("invalid filter value {pattern}"),
                }
            } else if pattern.starts_with("not_eq.") {
                let column = column.to_string();
                let value = serde_json::from_str(&pattern.replace("not_eq.", ""));
                match value {
                    Ok(value) => filters.push(Filter::NotEqual { column, value }),
                    Err(_) => tracing::warn!("invalid filter value {pattern}"),
                }
            } else if pattern.starts_with("gt.") {
                let column = column.to_string();
                let value = serde_json::from_str(&pattern.replace("gt.", ""));
                match value {
                    Ok(value) => filters.push(Filter::GreaterThan { column, value }),
                    Err(_) => tracing::warn!("invalid filter value {pattern}"),
                }
            } else if pattern.starts_with("gte.") {
                let column = column.to_string();
                let value = serde_json::from_str(&pattern.replace("gte.", ""));
                match value {
                    Ok(value) => filters.push(Filter::GreaterThanOrEqual { column, value }),
                    Err(_) => tracing::warn!("invalid filter value {pattern}"),
                }
            } else if pattern.starts_with("lt.") {
                let column = column.to_string();
                let value = serde_json::from_str(&pattern.replace("lt.", ""));
                match value {
                    Ok(value) => filters.push(Filter::LessThan { column, value }),
                    Err(_) => tracing::warn!("invalid filter value {pattern}"),
                }
            } else if pattern.starts_with("lte.") {
                let column = column.to_string();
                let value = serde_json::from_str(&pattern.replace("lte.", ""));
                match value {
                    Ok(value) => filters.push(Filter::LessThanOrEqual { column, value }),
                    Err(_) => tracing::warn!("invalid filter value {pattern}"),
                }
            } else if pattern.starts_with("is.") {
                let column = column.to_string();
                let value = pattern.replace("is.", "");
                match value.to_lowercase().as_str() {
                    "null" => filters.push(Filter::Is {
                        column,
                        value: JsonValue::Null,
                    }),
                    _ => match serde_json::from_str(&value) {
                        Ok(value) => filters.push(Filter::Is { column, value }),
                        Err(_) => tracing::warn!("invalid filter value {pattern}"),
                    },
                };
            } else if pattern.starts_with("is_not.") {
                let column = column.to_string();
                let value = pattern.replace("is_not.", "");
                match value.to_lowercase().as_str() {
                    "null" => filters.push(Filter::IsNot {
                        column,
                        value: JsonValue::Null,
                    }),
                    _ => match serde_json::from_str(&value) {
                        Ok(value) => filters.push(Filter::IsNot { column, value }),
                        Err(_) => tracing::warn!("invalid filter value {pattern}"),
                    },
                };
            } else if pattern.starts_with("in.") {
                let column = column.to_string();
                let separator = Regex::new(r"\s*,\s*").unwrap();
                let values = pattern.replace("in.", "");
                let values = match values.strip_prefix("(").and_then(|s| s.strip_suffix(")")) {
                    None => {
                        tracing::warn!("invalid filter value {pattern}");
                        ""
                    }
                    Some(s) => s,
                };
                let values = separator
                    .split(values)
                    .map(|v| serde_json::from_str::<JsonValue>(v).unwrap_or(json!(v.to_string())))
                    .collect::<Vec<_>>();
                filters.push(Filter::In {
                    column,
                    value: json!(values),
                })
            } else if pattern.starts_with("not_in.") {
                let column = column.to_string();
                let separator = Regex::new(r"\s*,\s*").unwrap();
                let values = pattern.replace("not_in.", "");
                let values = match values.strip_prefix("(").and_then(|s| s.strip_suffix(")")) {
                    None => {
                        tracing::warn!("invalid filter value {pattern}");
                        ""
                    }
                    Some(s) => s,
                };
                let values = separator
                    .split(values)
                    .map(|v| serde_json::from_str::<JsonValue>(v).unwrap_or(json!(v.to_string())))
                    .collect::<Vec<_>>();
                filters.push(Filter::NotIn {
                    column,
                    value: json!(values),
                })
            }
        }
        let limit: usize = query_params
            .get("limit")
            .and_then(|x| x.parse::<usize>().ok())
            .unwrap_or(rltbl.default_limit)
            .min(rltbl.max_limit);
        let offset: usize = query_params
            .get("offset")
            .and_then(|x| x.parse::<usize>().ok())
            .unwrap_or_default();
        Self {
            table_name,
            limit,
            offset,
            filters,
            ..Default::default()
        }
    }

    pub fn limit(mut self, limit: &usize) -> Self {
        self.limit = *limit;
        self
    }

    pub fn offset(mut self, offset: &usize) -> Self {
        self.offset = *offset;
        self
    }

    pub fn filters(mut self, filters: &Vec<String>) -> Result<Self> {
        let eq = Regex::new(r#"^(\w+)\s*=\s*"?(\w+)"?$"#).unwrap();
        let not_eq = Regex::new(r#"^(\w+)\s*!=\s*"?(\w+)"?$"#).unwrap();
        let gt = Regex::new(r"^(\w+)\s*>\s*(\w+)$").unwrap();
        let gte = Regex::new(r"^(\w+)\s*>=\s*(\w+)$").unwrap();
        let lt = Regex::new(r"^(\w+)\s*<\s*(\w+)$").unwrap();
        let lte = Regex::new(r"^(\w+)\s*<=\s*(\w+)$").unwrap();
        let is = Regex::new(r#"^(\w+)\s+(IS|is)\s+"?(\w+)"?$"#).unwrap();
        let is_not = Regex::new(r#"^(\w+)\s+(IS NOT|is not)\s+"?(\w+)"?$"#).unwrap();
        let is_in = Regex::new(r#"^(\w+)\s+(IN|in)\s+\((\w+(,\s*\w+)*)\)$"#).unwrap();
        let is_not_in = Regex::new(r#"^(\w+)\s+(NOT IN|not in)\s+\((\w+(,\s*\w+)*)\)$"#).unwrap();
        // Used for text types:
        let maybe_quote_value = |value: &str| -> Result<JsonValue> {
            if value.starts_with("\"") {
                let value = serde_json::from_str(&value)?;
                Ok(value)
            } else {
                let value = serde_json::from_str(&format!(r#""{value}""#))?;
                Ok(value)
            }
        };
        for filter in filters {
            if eq.is_match(&filter) {
                let captures = eq.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = maybe_quote_value(&value)?;
                self.filters.push(Filter::Equal { column, value });
            } else if not_eq.is_match(&filter) {
                let captures = not_eq.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = maybe_quote_value(&value)?;
                self.filters.push(Filter::NotEqual { column, value });
            } else if gt.is_match(&filter) {
                let captures = gt.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = serde_json::from_str(&value)?;
                self.filters.push(Filter::GreaterThan { column, value });
            } else if gte.is_match(&filter) {
                let captures = gte.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = serde_json::from_str(&value)?;
                self.filters
                    .push(Filter::GreaterThanOrEqual { column, value });
            } else if lt.is_match(&filter) {
                let captures = lt.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = serde_json::from_str(&value)?;
                self.filters.push(Filter::LessThan { column, value });
            } else if lte.is_match(&filter) {
                let captures = lte.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(2).unwrap().as_str();
                let value = serde_json::from_str(&value)?;
                self.filters.push(Filter::LessThanOrEqual { column, value });
            } else if is.is_match(&filter) {
                let captures = is.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(3).unwrap().as_str();
                let value = match value.to_lowercase().as_str() {
                    "null" => JsonValue::Null,
                    _ => maybe_quote_value(&value)?,
                };
                self.filters.push(Filter::Is { column, value });
            } else if is_not.is_match(&filter) {
                let captures = is_not.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let value = &captures.get(3).unwrap().as_str();
                let value = match value.to_lowercase().as_str() {
                    "null" => JsonValue::Null,
                    _ => maybe_quote_value(&value)?,
                };
                self.filters.push(Filter::IsNot { column, value });
            } else if is_in.is_match(&filter) {
                let captures = is_in.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let values = &captures.get(3).unwrap().as_str();
                let separator = Regex::new(r"\s*,\s*").unwrap();
                let values = separator
                    .split(values)
                    .map(|v| serde_json::from_str::<JsonValue>(v).unwrap_or(json!(v.to_string())))
                    .collect::<Vec<_>>();
                self.filters.push(Filter::In {
                    column,
                    value: json!(values),
                });
            } else if is_not_in.is_match(&filter) {
                let captures = is_not_in.captures(&filter).unwrap();
                let column = captures.get(1).unwrap().as_str().to_string();
                let values = &captures.get(3).unwrap().as_str();
                let separator = Regex::new(r"\s*,\s*").unwrap();
                let values = separator
                    .split(values)
                    .map(|v| serde_json::from_str::<JsonValue>(v).unwrap_or(json!(v.to_string())))
                    .collect::<Vec<_>>();
                self.filters.push(Filter::NotIn {
                    column,
                    value: json!(values),
                });
            } else {
                return Err(RelatableError::ConfigError(format!("invalid filter {filter}")).into());
            }
        }
        Ok(self)
    }

    pub fn eq<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::Equal {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn not_eq<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::NotEqual {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn gt<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::GreaterThan {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn gte<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::GreaterThanOrEqual {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn lt<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::LessThan {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn lte<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::LessThanOrEqual {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn is<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::Is {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn is_not<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::IsNot {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn is_in<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::In {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn is_not_in<T>(mut self, column: &str, value: &T) -> Result<Self>
    where
        T: Serialize,
    {
        self.filters.push(Filter::NotIn {
            column: column.to_string(),
            value: to_value(value)?,
        });
        Ok(self)
    }

    pub fn to_sqlite(&self) -> Result<(String, Vec<JsonValue>)> {
        tracing::debug!("to_sqlite: {self:?}");
        let table = &self.table_name;
        let mut lines = Vec::new();
        lines.push("SELECT *,".to_string());
        // WARN: The _total count should probably be optional.
        lines.push("  COUNT(1) OVER() AS _total,".to_string());
        lines.push(format!(
            r#"  (SELECT MAX(change_id) FROM history
                   WHERE "table" = ?
                     AND "row" = _id
                 ) AS _change_id"#
        ));
        lines.push(format!(r#"FROM "{}""#, self.table_name));
        for (i, filter) in self.filters.iter().enumerate() {
            let keyword = if i == 0 { "WHERE" } else { "  AND" };
            lines.push(format!("{keyword} {filter}", filter = filter.to_sqlite()?));
        }
        if self.limit > 0 {
            lines.push(format!("LIMIT {}", self.limit));
        }
        if self.offset > 0 {
            lines.push(format!("OFFSET {}", self.offset));
        }

        Ok((lines.join("\n"), vec![json!(table)]))
    }

    pub fn to_params(&self) -> Result<JsonMap<String, JsonValue>> {
        if self.table_name.is_empty() {
            return Err(RelatableError::InputError(
                "Missing required field: `table` in to_sql()".to_string(),
            )
            .into());
        }

        let mut params = JsonMap::new();
        if self.filters.len() > 0 {
            for filter in &self.filters {
                let column = match &filter {
                    Filter::Equal { column, value: _ }
                    | Filter::NotEqual { column, value: _ }
                    | Filter::GreaterThan { column, value: _ }
                    | Filter::GreaterThanOrEqual { column, value: _ }
                    | Filter::LessThan { column, value: _ }
                    | Filter::LessThanOrEqual { column, value: _ }
                    | Filter::Is { column, value: _ }
                    | Filter::IsNot { column, value: _ }
                    | Filter::In { column, value: _ }
                    | Filter::NotIn { column, value: _ } => column,
                };

                let column = unquote(&column).unwrap_or(column.to_string());
                if let Err(e) = is_simple(&column) {
                    return Err(RelatableError::InputError(format!(
                        "While reading filters, got error: {}",
                        e
                    ))
                    .into());
                }
                params.insert(column, format!("{}", filter.to_url()?).into());
            }
        }
        if self.limit > 0 {
            params.insert("limit".into(), self.limit.into());
        }
        if self.offset > 0 {
            params.insert("offset".into(), self.offset.into());
        }
        Ok(params)
    }

    pub fn to_url(&self, base: &str, format: &Format) -> Result<String> {
        let table_name = unquote(&self.table_name).unwrap_or(self.table_name.to_string());
        if let Err(e) = is_simple(&table_name) {
            return Err(RelatableError::InputError(format!(
                "While reading table name, got error: {}",
                e
            ))
            .into());
        }
        let table_name = format!("{base}/{table_name}{format}");

        let params = &self.to_params()?.clone();
        if params.len() > 0 {
            let mut parts = vec![];
            for (column, value) in params.iter() {
                let s = match value {
                    serde_json::Value::String(s) => s.as_str().into(),
                    _ => format!("{}", value),
                };
                parts.push(format!("{column}={s}"));
            }
            Ok(format!("{}?{}", table_name, parts.join("&")))
        } else {
            Ok(table_name.to_string())
        }
    }
}

// Web Site Stuff

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Site {
    title: String,
    root: String,
    user: Account,
    users: IndexMap<String, UserCursor>,
    tables: IndexMap<String, Table>,
}

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct Account {
    name: String,
    color: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Cursor {
    table: String,
    row: usize,
    column: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct UserCursor {
    name: String,
    color: String,
    cursor: Cursor,
    datetime: String,
}
